const fs = require('fs');
const os = require('os');
const path = require('path');
const decompress = require('decompress');
const decompressTargz = require('decompress-targz');
const decompressUnzip = require('decompress-unzip');
const { execSync } = require('child_process');
const https = require('https');
const { pipeline } = require('stream');
const { promisify } = require('util');
const streamPipeline = promisify(pipeline);

function normalizeTag(input) {
  if (!input) return null;
  const trimmed = String(input).trim();
  if (!trimmed) return null;
  return trimmed.startsWith('v') ? trimmed.slice(1) : trimmed;
}

function resolveTagFromEnvOrFile() {
  const fromEnv = normalizeTag(process.env.INWORLD_RUNTIME_RELEASE_TAG);
  if (fromEnv) return fromEnv;
  try {
    const raw = fs.readFileSync(
      path.join(__dirname, '..', 'runtime-binaries-version.txt'),
      'utf8',
    );
    const firstLine = raw.split(/\r?\n/).find((l) => l.trim().length > 0) || '';
    return normalizeTag(firstLine);
  } catch (_) {
    return null;
  }
}

async function getJson(url, token) {
  return new Promise((resolve, reject) => {
    https
      .get(
        url,
        {
          headers: {
            'User-Agent': 'node.js',
            Authorization: `token ${token}`,
          },
        },
        (res) => {
          let data = '';
          res.on('data', (chunk) => (data += chunk));
          res.on('end', () => {
            if (res.statusCode !== 200) {
              reject(
                new Error(`Failed to fetch JSON: ${res.statusCode} ${data}`),
              );
            } else {
              resolve(JSON.parse(data));
            }
          });
        },
      )
      .on('error', reject);
  });
}

async function downloadGithubAsset(
  owner,
  repo,
  tag,
  assetName,
  destPath,
  token,
) {
  const releaseUrl = `https://api.github.com/repos/${owner}/${repo}/releases/tags/v${tag}`;
  const release = await getJson(releaseUrl, token);
  const asset = release.assets.find((a) => a.name === assetName);
  if (!asset) {
    throw new Error(`Asset '${assetName}' not found in release ${tag}`);
  }

  const headers = {
    'User-Agent': 'node.js',
    Authorization: `token ${token}`,
    Accept: 'application/octet-stream',
  };
  const downloadUrl = `https://api.github.com/repos/${owner}/${repo}/releases/assets/${asset.id}`;

  return new Promise((resolve, reject) => {
    https
      .get(downloadUrl, { headers }, (res) => {
        if (res.statusCode === 302 && res.headers.location) {
          return https
            .get(res.headers.location, { headers }, (redirectedRes) => {
              if (redirectedRes.statusCode !== 200) {
                return reject(
                  new Error(
                    `Redirected download failed: ${redirectedRes.statusCode}`,
                  ),
                );
              }
              const fileStream = fs.createWriteStream(destPath);
              redirectedRes.pipe(fileStream);
              fileStream.on('finish', () => fileStream.close(resolve));
            })
            .on('error', reject);
        }
        if (res.statusCode !== 200) {
          return reject(new Error(`Download failed: ${res.statusCode}`));
        }
        const fileStream = fs.createWriteStream(destPath);
        res.pipe(fileStream);
        fileStream.on('finish', () => fileStream.close(resolve));
      })
      .on('error', reject);
  });
}

async function extractLibOnly(archivePath, targetDir, isZip) {
  const plugins = isZip ? [decompressUnzip()] : [decompressTargz()];

  const targetLibDir = path.join(targetDir, 'lib');
  fs.mkdirSync(targetLibDir, { recursive: true });

  const files = await decompress(archivePath, targetLibDir, {
    plugins,
    filter: (file) => file.path.startsWith('lib/'),
    map: (file) => {
      // Remove the 'lib/' prefix from the path
      file.path = file.path.replace(/^lib\//, '');
      return file;
    },
  });

  if (files.length === 0) {
    throw new Error(`Expected 'lib/' folder not found in archive`);
  }

  // Set proper permissions for extracted library files
  for (const file of files) {
    const filePath = path.join(targetLibDir, file.path);
    if (fs.existsSync(filePath)) {
      const stats = fs.statSync(filePath);
      if (stats.isFile()) {
        fs.chmodSync(filePath, 0o644);
      }
    }
  }
}

async function extractNodeAddonOnly(archivePath, targetDir, isZip) {
  const plugins = isZip ? [decompressUnzip()] : [decompressTargz()];

  // Possible file names
  const candidates = [
    'inworld.node',
    'inworld.dll',
    'libinworld.so',
    'libinworld.dylib',
  ];

  const addonDir = path.join(targetDir, 'node');
  fs.mkdirSync(addonDir);

  const files = await decompress(archivePath, addonDir, {
    plugins,
    filter: (file) => candidates.includes(path.basename(file.path)),
    map: (file) => {
      // Always rename to inworld.node regardless of original name
      file.path = 'inworld.node';
      return file;
    },
  });

  if (files.length === 0) {
    throw new Error(
      `Addon binary not found (expected ${candidates.join(', ')})`,
    );
  }

  // Set proper permissions for extracted node addon files
  for (const file of files) {
    const filePath = path.join(addonDir, file.path);
    if (fs.existsSync(filePath)) {
      const stats = fs.statSync(filePath);
      if (stats.isFile()) {
        fs.chmodSync(filePath, 0o644);
      }
    }
  }
}

function verifyTagFormat(tag) {
  const tagRe = /^\d+\.\d+\.\d+(-rc\d+)?$/;
  return tagRe.test(tag);
}

function getPlatformTargetKey() {
  const platform = os.platform();
  const arch = os.arch();
  const platformArchMap = {
    win32_x64: 'windows_x64',
    darwin_arm64: 'darwin_aarch64',
    linux_x64: 'linux_x86_64',
    linux_arm64: 'linux_aarch64',
  };
  const key = `${platform}_${arch}`;
  const mapped = platformArchMap[key];
  if (!mapped) {
    throw new Error(`Unsupported platform/arch: ${platform} ${arch}`);
  }
  return { key, mapped, platform };
}

async function downloadAndExtractAsset({
  tag,
  mapped,
  platform,
  targetDir,
  token,
  suffix,
  extractFn,
}) {
  const ext = platform === 'win32' ? 'zip' : 'tar.gz';
  const assetName = `inworld_api_${tag}_${mapped}_${suffix}.${ext}`;
  const destPath = path.join(os.tmpdir(), assetName);

  console.log(`Downloading ${assetName}`);
  await downloadGithubAsset(
    'inworld-ai',
    'inworld-framework-cpp',
    tag,
    assetName,
    destPath,
    token,
  );

  console.log(`Extracting ${destPath} -> ${targetDir}`);
  await extractFn(destPath, targetDir, platform === 'win32');
}

async function downloadUnzipBinaries() {
  const { key, mapped, platform } = getPlatformTargetKey();
  const token = process.env.GITHUB_TOKEN;

  const resolvedTag = resolveTagFromEnvOrFile();
  if (!resolvedTag) {
    throw new Error(
      `INWORLD_RUNTIME_RELEASE_TAG is not set and runtime-binaries-version.txt is missing or invalid`,
    );
  }
  if (!verifyTagFormat(resolvedTag)) {
    throw new Error(
      `Invalid tag format: ${resolvedTag}. Should be 1.2.3(-rc1)`,
    );
  }

  const targetDir = path.join(__dirname, '..', 'bin', key);
  fs.rmSync(targetDir, { recursive: true, force: true });
  fs.mkdirSync(targetDir, { recursive: true });

  // Main C ABI binary
  await downloadAndExtractAsset({
    tag: resolvedTag,
    mapped,
    platform,
    targetDir,
    token,
    suffix: 'cpu_full_cabi',
    extractFn: extractLibOnly,
  });

  // Node addon binary
  await downloadAndExtractAsset({
    tag: resolvedTag,
    mapped,
    platform,
    targetDir,
    token,
    suffix: 'cpu_full_node',
    extractFn: extractNodeAddonOnly,
  });

  // Write version file after successful download and extraction
  const versionFilePath = path.join(targetDir, 'version.txt');
  try {
    fs.writeFileSync(versionFilePath, resolvedTag, 'utf8');
    console.log(`Wrote version file: ${resolvedTag}`);
  } catch (err) {
    console.log(`Warning: Could not write version file: ${err.message}`);
  }

  console.log('Done.');
}

module.exports = {
  downloadUnzipBinaries,
  extractLibOnly,
  extractNodeAddonOnly,
};

if (require.main === module) {
  downloadUnzipBinaries().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
