#!/usr/bin/env python3
"""
Script to validate that JavaScript function calls in expose_binary.ts 
match the C++ function definitions in inworld_wrap.cxx.

Usage: python validate_bindings.py <expose_binary.ts> <inworld_wrap.cxx>
"""

import re
import sys
import argparse
from typing import Dict, List, Tuple, Set
from dataclasses import dataclass
from pathlib import Path


@dataclass
class FunctionSignature:
    """Represents a function signature with name, return type, and parameter types."""
    name: str
    return_type: str
    param_types: List[str]
    source_line: int
    source_file: str

    def __str__(self):
        params = ', '.join(self.param_types)
        return f"{self.return_type} {self.name}({params})"


class TypeMapper:
    """Maps between JavaScript types and C++ types."""
    
    JS_TO_CPP_TYPE_MAP = {
        'void': 'void',
        'void*': 'SwigObj*',
        'str': 'char*',
        'string': 'char*',
        'bool': 'bool',
        'int': 'int',
        'size_t': 'size_t',
        'float': 'float',
        'double': 'double',
        'uint64': 'unsigned long long',
        'int64': 'long long',
    }
    
    @classmethod
    def js_to_cpp_type(cls, js_type: str) -> str:
        """Convert JavaScript type to equivalent C++ type."""
        js_type = js_type.strip()
        
        # Normalize pointer spacing in JS types too
        js_type = re.sub(r'\s*\*\s*', '*', js_type)
        
        return cls.JS_TO_CPP_TYPE_MAP.get(js_type, js_type)
    
    @classmethod
    def normalize_cpp_type(cls, cpp_type: str) -> str:
        """Normalize C++ type (handle pointer spacing, etc.)."""
        cpp_type = cpp_type.strip()
        
        # Handle const modifiers - remove them as they don't matter for JS bindings
        cpp_type = re.sub(r'\bconst\s+', '', cpp_type)
        
        # Normalize all whitespace around pointers: "char *" -> "char*"
        cpp_type = re.sub(r'\s*\*\s*', '*', cpp_type)
        
        # Map common SWIG generated types to standard forms
        type_mappings = {
            'char*': 'char*',
            'SwigObj*': 'SwigObj*', 
            'void*': 'SwigObj*',
        }
        
        return type_mappings.get(cpp_type, cpp_type)
    
    @classmethod
    def types_equivalent(cls, js_type: str, cpp_type: str) -> bool:
        """Check if JavaScript and C++ types are equivalent."""
        js_normalized = cls.js_to_cpp_type(js_type)
        cpp_normalized = cls.normalize_cpp_type(cpp_type)
        
        # Handle numeric type equivalency - JavaScript only has 'number'
        # So all these numeric types are equivalent
        numeric_types = {
            'int', 'size_t', 'float', 'double', 
            'signed char', 'unsigned char', 'char',
            'short', 'long', 'long long',
            'unsigned int', 'unsigned short', 'unsigned long',
            'int8_t', 'int16_t', 'int32_t', 'int64_t',
            'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t'
        }
        if js_normalized in numeric_types and cpp_normalized in numeric_types:
            return True
            
        return js_normalized == cpp_normalized


class JavaScriptParser:
    """Parses expose_binary.ts to extract inworld.func calls."""
    
    def __init__(self, file_path: str):
        self.file_path = file_path
        self.functions: Dict[str, FunctionSignature] = {}
    
    def parse(self) -> Dict[str, FunctionSignature]:
        """Parse the TypeScript file and extract function signatures."""
        with open(self.file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Pattern to match inworld.func calls
        # Handles multiline function calls and various formatting
        pattern = r"inworld\.func\(\s*'([^']+)',\s*'([^']+)',\s*\[([^\]]*)\]"
        
        lines = content.split('\n')
        
        # Find all matches with line numbers
        for line_num, line in enumerate(lines, 1):
            # Skip commented lines
            stripped_line = line.strip()
            if stripped_line.startswith('//'):
                continue
            
            # Handle single-line function calls
            matches = re.finditer(pattern, line, re.DOTALL)
            for match in matches:
                self._process_match(match, line_num)
        
        # Handle multiline function calls (but skip if they start with a comment)
        multiline_pattern = r"inworld\.func\(\s*'([^']+)',\s*'([^']+)',\s*\[((?:[^\[\]]|\[[^\[\]]*\])*)\]"
        multiline_matches = re.finditer(multiline_pattern, content, re.DOTALL | re.MULTILINE)
        
        for match in multiline_matches:
            # Find the line number for multiline matches
            line_start = content[:match.start()].count('\n')
            
            # Check if the line containing the match start is commented
            lines_up_to_match = content[:match.start()].split('\n')
            if lines_up_to_match:
                match_line = lines_up_to_match[-1]
                # Check if this line or the context around the match is commented
                context_start = max(0, match.start() - 100)  # Look at some context before
                context = content[context_start:match.start()]
                last_newline = context.rfind('\n')
                if last_newline != -1:
                    line_before_match = context[last_newline + 1:].strip()
                    if line_before_match.startswith('//'):
                        continue
                
            line_num = line_start + 1
            self._process_match(match, line_num)
        
        return self.functions
    
    def _process_match(self, match, line_num: int):
        """Process a regex match and create a FunctionSignature."""
        func_name = match.group(1)
        return_type = match.group(2)
        params_str = match.group(3)
        
        # Parse parameter types
        param_types = []
        if params_str.strip():
            # Split by comma, but handle nested brackets
            params = self._split_params(params_str)
            param_types = [p.strip().strip('\'"') for p in params if p.strip()]
        
        # Convert JS types to C++ types
        cpp_return_type = TypeMapper.js_to_cpp_type(return_type)
        cpp_param_types = [TypeMapper.js_to_cpp_type(pt) for pt in param_types]
        
        signature = FunctionSignature(
            name=func_name,
            return_type=cpp_return_type,
            param_types=cpp_param_types,
            source_line=line_num,
            source_file=self.file_path
        )
        
        self.functions[func_name] = signature
    
    def _split_params(self, params_str: str) -> List[str]:
        """Split parameter string by comma, handling nested structures and comments."""
        params = []
        current_param = ""
        bracket_depth = 0
        quote_char = None
        i = 0
        
        while i < len(params_str):
            char = params_str[i]
            
            if quote_char:
                current_param += char
                if char == quote_char and (i == 0 or params_str[i-1] != '\\'):
                    quote_char = None
            elif char in ['"', "'", '`']:
                quote_char = char
                current_param += char
            elif char in ['[', '(']:
                bracket_depth += 1
                current_param += char
            elif char in [']', ')']:
                bracket_depth -= 1
                current_param += char
            elif char == '/' and i + 1 < len(params_str) and params_str[i + 1] == '/' and bracket_depth == 0:
                # Handle inline comments - skip to end of line or end of string
                while i < len(params_str) and params_str[i] not in ['\n', '\r']:
                    i += 1
                continue
            elif char == ',' and bracket_depth == 0:
                if current_param.strip():
                    # Clean up the parameter - remove inline comments
                    param = current_param.strip()
                    # Remove inline comments from parameter
                    if '//' in param:
                        param = param.split('//')[0].strip()
                    params.append(param)
                current_param = ""
            else:
                current_param += char
            
            i += 1
        
        if current_param.strip():
            # Clean up the last parameter
            param = current_param.strip()
            if '//' in param:
                param = param.split('//')[0].strip()
            params.append(param)
        
        return params


class CppParser:
    """Parses inworld_wrap.cxx to extract SWIGEXPORT function definitions."""
    
    def __init__(self, file_path: str):
        self.file_path = file_path
        self.type_mapper = TypeMapper() # Initialize TypeMapper
        self.functions: Dict[str, FunctionSignature] = {}
    
    def parse(self) -> Dict[str, FunctionSignature]:
        """Parse the C++ file and extract function signatures."""
        with open(self.file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Pattern to match SWIGEXPORT function definitions across multiple lines
        # Handle: SWIGEXPORTC const char * funcname(...) {
        #         SWIGEXPORTC char* funcname(...)  {
        #         SWIGEXPORTC SwigObj* funcname(...) {
        #         SWIGEXPORTC unsigned long long funcname(...) {
        pattern = r'SWIGEXPORTC?\s+((?:const\s+)?(?:signed\s+|unsigned\s+)?(?:\w+\s+)*\w+(?:\s*\*)?)\s+(\w+)\s*\((.*?)\)\s*\{'
        
        functions = {}
        for match in re.finditer(pattern, content, re.MULTILINE | re.DOTALL):
            return_type = match.group(1).strip()
            func_name = match.group(2).strip()
            params_str = match.group(3).strip()
            
            # Find line number
            line_num = content[:match.start()].count('\n') + 1
            
            # Parse parameters
            param_types = self._parse_cpp_params(params_str)
            
            # Normalize types
            normalized_return = self.type_mapper.normalize_cpp_type(return_type)
            normalized_params = [self.type_mapper.normalize_cpp_type(p) for p in param_types]
            
            functions[func_name] = FunctionSignature(
                name=func_name,
                return_type=normalized_return,
                param_types=normalized_params,
                source_line=line_num,
                source_file=self.file_path
            )
        
        return functions
    
    def _parse_cpp_params(self, params_str: str) -> List[str]:
        """Parse C++ parameter string and extract types."""
        if not params_str.strip():
            return []
        
        params = []
        param_parts = params_str.split(',')
        
        for param in param_parts:
            param = param.strip()
            if not param:
                continue
            
            # Extract type from "type name" or "const type* name" format
            # Handle cases like "SwigObj* carg1", "int carg2", "const char* carg3", etc.
            parts = param.split()
            if len(parts) >= 2:
                # Join all parts except the last one (parameter name)
                # This handles "const char*" and "const char *" cases
                param_type = ' '.join(parts[:-1])
            else:
                # If only one part, it's probably just the type
                param_type = parts[0] if parts else param
            
            params.append(param_type)
        
        return params


class ValidationReport:
    """Generates validation reports comparing JS and C++ functions."""
    
    def __init__(self, js_functions: Dict[str, FunctionSignature], 
                 cpp_functions: Dict[str, FunctionSignature]):
        self.js_functions = js_functions
        self.cpp_functions = cpp_functions
    
    def validate(self) -> bool:
        """Validate all functions and return True if all are valid."""
        print("=== Function Binding Validation Report ===\n")
        
        all_valid = True
        
        # Check for missing functions
        missing_in_cpp = self._check_missing_functions()
        if missing_in_cpp:
            all_valid = False
        
        # Check for signature mismatches
        mismatches = self._check_signature_mismatches()
        if mismatches:
            all_valid = False
        
        # Check for extra functions in C++
        extra_in_cpp = self._check_extra_functions()
        
        # Summary
        print(f"\n=== Summary ===")
        print(f"JavaScript functions: {len(self.js_functions)}")
        print(f"C++ functions: {len(self.cpp_functions)}")
        print(f"Missing in C++: {len(missing_in_cpp)}")
        print(f"Signature mismatches: {len(mismatches)}")
        print(f"Extra in C++ (not called from JS): {len(extra_in_cpp)}")
        
        if all_valid:
            print("\n✅ All validations passed!")
        else:
            print("\n❌ Validation failed!")
            print(f"\n🔧 Action needed:")
            if missing_in_cpp:
                print(f"  - Add {len(missing_in_cpp)} missing function(s) to C++ wrapper")
            if mismatches:
                print(f"  - Fix {len(mismatches)} function signature mismatch(es)")
        
        return all_valid
    
    def _check_missing_functions(self) -> Set[str]:
        """Check for functions called in JS but missing in C++."""
        missing = set(self.js_functions.keys()) - set(self.cpp_functions.keys())
        
        if missing:
            print("❌ Functions called in JavaScript but missing in C++:")
            for func_name in sorted(missing):
                js_sig = self.js_functions[func_name]
                print(f"  - {func_name} (called at {js_sig.source_file}:{js_sig.source_line})")
                print(f"    Expected signature: {js_sig}")
            print()
        
        return missing
    
    def _check_signature_mismatches(self) -> List[Tuple[str, FunctionSignature, FunctionSignature]]:
        """Check for functions with mismatched signatures."""
        mismatches = []
        
        common_functions = set(self.js_functions.keys()) & set(self.cpp_functions.keys())
        
        for func_name in sorted(common_functions):
            js_sig = self.js_functions[func_name]
            cpp_sig = self.cpp_functions[func_name]
            
            if not self._signatures_match(js_sig, cpp_sig):
                mismatches.append((func_name, js_sig, cpp_sig))
        
        if mismatches:
            print("❌ Functions with signature mismatches:")
            for func_name, js_sig, cpp_sig in mismatches:
                print(f"  - {func_name}")
                print(f"    JavaScript: {js_sig} (line {js_sig.source_line})")
                print(f"    C++:        {cpp_sig} (line {cpp_sig.source_line})")
                self._diagnose_mismatch(js_sig, cpp_sig)
                print()
        
        return mismatches
    
    def _check_extra_functions(self) -> Set[str]:
        """Check for functions in C++ that are not called from JavaScript."""
        extra = set(self.cpp_functions.keys()) - set(self.js_functions.keys())
        
        if extra and len(extra) < 50:  # Only show if manageable number
            print("ℹ️  Functions defined in C++ but not called from JavaScript:")
            for func_name in sorted(list(extra)[:20]):  # Limit to first 20
                cpp_sig = self.cpp_functions[func_name]
                print(f"  - {func_name} (line {cpp_sig.source_line})")
            if len(extra) > 20:
                print(f"  ... and {len(extra) - 20} more")
            print()
        
        return extra
    
    def _signatures_match(self, js_sig: FunctionSignature, cpp_sig: FunctionSignature) -> bool:
        """Check if two function signatures match."""
        # Compare return types
        if not TypeMapper.types_equivalent(js_sig.return_type, cpp_sig.return_type):
            return False
        
        # Compare parameter count
        if len(js_sig.param_types) != len(cpp_sig.param_types):
            return False
        
        # Compare parameter types
        for js_param, cpp_param in zip(js_sig.param_types, cpp_sig.param_types):
            if not TypeMapper.types_equivalent(js_param, cpp_param):
                return False
        
        return True
    
    def _diagnose_mismatch(self, js_sig: FunctionSignature, cpp_sig: FunctionSignature):
        """Provide specific diagnosis of what doesn't match."""
        issues = []
        
        # Check return type
        if not TypeMapper.types_equivalent(js_sig.return_type, cpp_sig.return_type):
            issues.append(f"Return type: expected '{js_sig.return_type}', got '{cpp_sig.return_type}'")
        
        # Check parameter count
        if len(js_sig.param_types) != len(cpp_sig.param_types):
            issues.append(f"Parameter count: expected {len(js_sig.param_types)}, got {len(cpp_sig.param_types)}")
        
        # Check individual parameters
        for i, (js_param, cpp_param) in enumerate(zip(js_sig.param_types, cpp_sig.param_types)):
            if not TypeMapper.types_equivalent(js_param, cpp_param):
                issues.append(f"Parameter {i+1}: expected '{js_param}', got '{cpp_param}'")
        
        if issues:
            print(f"    Issues: {'; '.join(issues)}")


def main():
    parser = argparse.ArgumentParser(
        description="Validate JavaScript function calls against C++ function definitions"
    )
    parser.add_argument("expose_binary", help="Path to expose_binary.ts file")
    parser.add_argument("inworld_wrap", help="Path to inworld_wrap.cxx file")
    parser.add_argument("--verbose", "-v", action="store_true", 
                       help="Enable verbose output")
    parser.add_argument("--show-missing-only", action="store_true",
                       help="Only show missing functions, not mismatches")
    
    args = parser.parse_args()
    
    # Validate file paths
    if not Path(args.expose_binary).exists():
        print(f"Error: File not found: {args.expose_binary}")
        sys.exit(1)
    
    if not Path(args.inworld_wrap).exists():
        print(f"Error: File not found: {args.inworld_wrap}")
        sys.exit(1)
    
    try:
        # Parse JavaScript functions
        print("Parsing JavaScript functions...")
        js_parser = JavaScriptParser(args.expose_binary)
        js_functions = js_parser.parse()
        
        # Parse C++ functions
        print("Parsing C++ functions...")
        cpp_parser = CppParser(args.inworld_wrap)
        cpp_functions = cpp_parser.parse()
        
        if args.verbose:
            print(f"Found {len(js_functions)} JavaScript function calls")
            print(f"Found {len(cpp_functions)} C++ function definitions")
        
        # Validate and generate report
        report = ValidationReport(js_functions, cpp_functions)
        success = report.validate()
        
        sys.exit(0 if success else 1)
        
    except Exception as e:
        print(f"Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
