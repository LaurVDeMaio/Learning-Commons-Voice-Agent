"use strict";
/**
 * Alternative approach using Zod for runtime type validation
 * This is just an example - you would need to install zod first: npm install zod
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.zodApproachInfo = void 0;
// Note: This is a demonstration file showing how you could use Zod
// Uncomment the following if you decide to use this approach:
/*
import { z } from 'zod';

// Define Zod schemas that mirror your TypeScript interfaces
const ImageUrlSchema = z.object({
  url: z.string(),
  detail: z.string().optional()
});

const ContentItemSchema = z.object({
  type: z.enum(['text', 'image']),
  text: z.string().optional(),
  image_url: ImageUrlSchema.optional()
});

const ToolCallSchema = z.object({
  id: z.string(),
  name: z.string(),
  args: z.string()
});

const FunctionChoiceSchema = z.object({
  type: z.string().optional(),
  name: z.string()
});

const ToolChoiceSchema = z.object({
  choice: z.union([z.string(), FunctionChoiceSchema])
});

const ToolSchema = z.object({
  name: z.string(),
  description: z.string(),
  properties: z.record(z.any())
});

const LLMMessageSchema = z.object({
  role: z.string(),
  content: z.union([z.string(), z.array(ContentItemSchema)]),
  toolCalls: z.array(ToolCallSchema).optional(),
  toolCallId: z.string().optional()
});

const LLMChatRequestSchema = z.object({
  messages: z.array(LLMMessageSchema),
  tools: z.array(ToolSchema).optional(),
  toolChoice: ToolChoiceSchema.optional(),
  responseFormat: z.enum(['text', 'json', 'json_schema']).optional()
});

// Zod automatically creates type guards with .safeParse()
export const isLLMMessage = (input: any): input is z.infer<typeof LLMMessageSchema> => {
  return LLMMessageSchema.safeParse(input).success;
};

export const isLLMChatRequest = (input: any): input is z.infer<typeof LLMChatRequestSchema> => {
  return LLMChatRequestSchema.safeParse(input).success;
};

// You can also get detailed error information
export function validateLLMChatRequest(input: any) {
  const result = LLMChatRequestSchema.safeParse(input);
  
  if (result.success) {
    return { valid: true, data: result.data };
  } else {
    return {
      valid: false,
      errors: result.error.issues.map(issue => ({
        path: issue.path.join('.'),
        message: issue.message
      }))
    };
  }
}

// Example usage:
export function demonstrateZodValidation() {
  const testInput = {
    messages: [
      { role: 'user', content: 'Hello' },
      { role: 'assistant', content: 'Hi there!', extraProp: 'invalid' }
    ]
  };

  const result = validateLLMChatRequest(testInput);
  
  if (result.valid) {
    console.log('Valid input:', result.data);
  } else {
    console.log('Validation errors:');
    result.errors.forEach(error => {
      console.log(`  ${error.path}: ${error.message}`);
    });
  }
}
*/
exports.zodApproachInfo = `
=== Zod Approach Pros & Cons ===

PROS:
✅ Very mature and well-tested library
✅ Excellent TypeScript integration
✅ Built-in type inference from schemas
✅ Detailed error messages with paths
✅ Supports complex validations (regex, custom validators, etc.)
✅ Can parse/transform data during validation
✅ Large ecosystem and community

CONS:
❌ Additional dependency (~2.8MB)
❌ Learning curve for Zod-specific syntax
❌ Schemas can become verbose for complex types
❌ Need to maintain both TS interfaces and Zod schemas
❌ Runtime overhead (though minimal)

=== When to Choose Each Approach ===

Choose CUSTOM SCHEMA GENERATOR when:
- You want minimal dependencies
- You have specific validation requirements
- You prefer full control over the validation logic
- Performance is critical

Choose ZOD when:
- You want battle-tested validation
- You need complex validation rules
- You want detailed error reporting
- You're building a new project and can adopt it from the start

=== Our Implementation Benefits ===

Our custom schema-based approach provides:
1. Zero external dependencies
2. Tailored to your exact needs
3. Minimal runtime overhead
4. Easy to extend and customize
5. Perfect integration with existing codebase
`;
console.log(exports.zodApproachInfo);
