"use strict";
/**
 * Schema-based type guard generator utility
 * Automatically generates type guards from interface schemas
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypeGuard = createTypeGuard;
exports.TypeGuard = TypeGuard;
exports.GenerateTypeGuards = GenerateTypeGuards;
/**
 * Generates a type guard function from an interface schema
 */
function createTypeGuard(schema, customValidators) {
    return function (input) {
        if (typeof input !== 'object' || input === null) {
            return false;
        }
        const keys = Object.keys(input);
        const allowedKeys = Object.keys(schema);
        // Check that all keys are allowed
        if (!keys.every(key => allowedKeys.includes(key))) {
            return false;
        }
        // Check each property in the schema
        for (const [propertyName, propertySchema] of Object.entries(schema)) {
            const hasProperty = input.hasOwnProperty(propertyName);
            // Check required properties
            if (propertySchema.required && !hasProperty) {
                return false;
            }
            // Skip validation if property is optional and not present
            if (!hasProperty) {
                continue;
            }
            const value = input[propertyName];
            if (!validateProperty(value, propertySchema, customValidators)) {
                return false;
            }
        }
        return true;
    };
}
function validateProperty(value, schema, customValidators) {
    var _a, _b;
    // Custom validator takes precedence
    if (schema.validator) {
        return schema.validator(value);
    }
    switch (schema.type) {
        case 'string':
            return typeof value === 'string';
        case 'number':
            return typeof value === 'number';
        case 'boolean':
            return typeof value === 'boolean';
        case 'array':
            if (!Array.isArray(value)) {
                return false;
            }
            if (schema.arrayItemSchema) {
                return value.every(item => validateProperty(item, schema.arrayItemSchema, customValidators));
            }
            return true;
        case 'object':
            if (typeof value !== 'object' || value === null) {
                return false;
            }
            if (schema.objectSchema) {
                const nestedTypeGuard = createTypeGuard(schema.objectSchema, customValidators);
                return nestedTypeGuard(value);
            }
            return true;
        case 'enum':
            return (_b = (_a = schema.enumValues) === null || _a === void 0 ? void 0 : _a.includes(value)) !== null && _b !== void 0 ? _b : false;
        case 'union':
            if (!schema.unionSchemas) {
                return false;
            }
            return schema.unionSchemas.some(unionSchema => validateProperty(value, unionSchema, customValidators));
        default:
            return false;
    }
}
/**
 * Decorator factory for creating type guard methods
 */
function TypeGuard(schema) {
    return function (target, propertyKey, descriptor) {
        const typeGuard = createTypeGuard(schema);
        descriptor.value = typeGuard;
        return descriptor;
    };
}
/**
 * Class decorator for automatically generating type guards
 */
function GenerateTypeGuards(schemas) {
    return function (constructor) {
        return class extends constructor {
            constructor(...args) {
                super(...args);
                // Generate type guard methods
                for (const [methodName, schema] of Object.entries(schemas)) {
                    this[methodName] = createTypeGuard(schema);
                }
            }
        };
    };
}
