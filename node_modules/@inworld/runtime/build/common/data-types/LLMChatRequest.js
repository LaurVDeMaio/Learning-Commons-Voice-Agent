"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseFormatName = exports.LLMChatRequest = void 0;
const expose_binary_1 = require("../../expose_binary");
const messages_1 = require("../vector/messages");
const BaseData_1 = require("./BaseData");
/**
 * Class for handling chat messages in graphs.
 * Extends BaseData with chat message-specific functionality.
 */
class LLMChatRequest extends BaseData_1.BaseData {
    constructor(messagesOrExternalOrInterface) {
        let external;
        let messages = null;
        let storedTools = null;
        let storedToolChoice;
        let storedResponseFormat;
        if (Array.isArray(messagesOrExternalOrInterface)) {
            // Handle LLMMessageInterface[] case
            const chatMessages = messages_1.Messages.fromLLMMessageInterfaces(messagesOrExternalOrInterface);
            external = expose_binary_1.LLMChatRequestFunctions.new(chatMessages.getExternal());
            messages = chatMessages;
        }
        else if (typeof messagesOrExternalOrInterface === 'object' &&
            messagesOrExternalOrInterface !== null &&
            'messages' in messagesOrExternalOrInterface &&
            Array.isArray(messagesOrExternalOrInterface.messages)) {
            // Handle LLMChatRequestInterface case
            const chatRequest = messagesOrExternalOrInterface;
            const chatMessages = messages_1.Messages.fromLLMMessageInterfaces(chatRequest.messages);
            let tools = null;
            let responseFormatId = 1; // Default to Text format
            if (chatRequest.responseFormat) {
                responseFormatId = getFormatId(chatRequest.responseFormat);
                storedResponseFormat = chatRequest.responseFormat;
            }
            const optionalToolChoice = LLMChatRequest.createOptionalToolChoice(chatRequest.toolChoice);
            if (chatRequest.tools) {
                tools = new messages_1.Tools(chatRequest.tools);
            }
            else {
                tools = new messages_1.Tools([]);
            }
            external = expose_binary_1.LLMChatRequestFunctions.newFull(chatMessages.getExternal(), tools.getExternal(), optionalToolChoice, responseFormatId);
            expose_binary_1.OptionalToolChoiceFunctions.delete(optionalToolChoice);
            tools.destroy();
            messages = chatMessages;
            storedTools = tools;
            storedToolChoice = chatRequest.toolChoice;
            storedResponseFormat = chatRequest.responseFormat;
        }
        else {
            // Handle ExternalReference case
            external = messagesOrExternalOrInterface;
        }
        super(external);
        this.messages = null;
        this.messages = messages;
        this.tools = storedTools;
        this.toolChoice = storedToolChoice;
        this.responseFormat = storedResponseFormat;
    }
    /**
     * Creates an OptionalToolChoice from toolChoice value
     *
     * @param {ToolChoiceInterface} [toolChoice] - Optional tool choice configuration
     * @returns {ExternalReference} External reference to the optional tool choice
     * @private
     */
    static createOptionalToolChoice(toolChoice) {
        if (!toolChoice) {
            return expose_binary_1.OptionalToolChoiceFunctions.new();
        }
        const toolChoiceExternal = expose_binary_1.ToolChoiceFunctions.new();
        if (typeof toolChoice.choice === 'string') {
            expose_binary_1.ToolChoiceFunctions.setStringChoice(toolChoiceExternal, toolChoice.choice);
        }
        else {
            const functionChoice = expose_binary_1.FunctionChoiceFunctions.new();
            expose_binary_1.FunctionChoiceFunctions.setType(functionChoice, toolChoice.choice.type || 'function');
            expose_binary_1.FunctionChoiceFunctions.setName(functionChoice, toolChoice.choice.name);
            expose_binary_1.ToolChoiceFunctions.setFunctionChoice(toolChoiceExternal, functionChoice);
            expose_binary_1.FunctionChoiceFunctions.delete(functionChoice);
        }
        const optionalToolChoice = expose_binary_1.OptionalToolChoiceFunctions.newWithValue(toolChoiceExternal);
        expose_binary_1.ToolChoiceFunctions.delete(toolChoiceExternal);
        return optionalToolChoice;
    }
    /**
     * @internal
     * Creates a new LLMChatRequest instance from an external reference.
     *
     * @param {ExternalReference} external - The external reference to create the instance from
     * @returns {LLMChatRequest | null} A new LLMChatRequest instance or null if invalid
     */
    static fromExternal(external) {
        const baseData = expose_binary_1.LLMChatRequestFunctions.toBaseData(external);
        if (baseData && expose_binary_1.LLMChatRequestFunctions.isValid(baseData)) {
            return new LLMChatRequest(baseData);
        }
        return null;
    }
    /**
     * Gets the LLMChatRequest data as an interface.
     * If external is set, it will parse the external reference,
     * else it will use the stored properties
     *
     * @returns {LLMChatRequestInterface} The LLMChatRequest interface object
     */
    getLLMChatRequest() {
        var _a, _b;
        // If we have stored properties (from LLMChatRequestInterface constructor), use them
        if (this.messages) {
            return {
                messages: this.messages.getMessages() || [],
                tools: ((_a = this.tools) === null || _a === void 0 ? void 0 : _a.getTools()) || [],
                toolChoice: this.toolChoice,
                responseFormat: this.responseFormat,
            };
        }
        // Otherwise, try to parse from external reference
        if (this.external) {
            const responseFormatId = expose_binary_1.LLMChatRequestFunctions.getResponseFormat(this.external);
            let responseFormat;
            if (responseFormatId && responseFormatId > 0) {
                try {
                    responseFormat = getFormatName(responseFormatId);
                }
                catch (_c) {
                    // Handle invalid format ID gracefully
                    responseFormat = ResponseFormatName.Text;
                }
            }
            return {
                messages: messages_1.Messages.fromExternal(expose_binary_1.LLMChatRequestFunctions.getMessages(this.external)).getMessages(),
                tools: expose_binary_1.LLMChatRequestFunctions.getTools(this.external),
                toolChoice: expose_binary_1.LLMChatRequestFunctions.getToolChoice(this.external),
                responseFormat: responseFormat,
            };
        }
        // Fallback
        return {
            messages: ((_b = this.messages) === null || _b === void 0 ? void 0 : _b.getMessages()) || [],
        };
    }
    /**
     * Cleans up resources used by the LLMChatRequest instance.
     */
    destroy() {
        var _a, _b;
        (_a = this.messages) === null || _a === void 0 ? void 0 : _a.destroy();
        this.messages = null;
        (_b = this.tools) === null || _b === void 0 ? void 0 : _b.destroy();
        this.tools = null;
        this.toolChoice = undefined;
        super.destroy();
    }
}
exports.LLMChatRequest = LLMChatRequest;
/** Response format name. */
var ResponseFormatName;
(function (ResponseFormatName) {
    /** Plain text response format */
    ResponseFormatName["Text"] = "text";
    /** JSON response format */
    ResponseFormatName["Json"] = "json";
    /** JSON Schema response format */
    ResponseFormatName["JsonSchema"] = "json_schema";
})(ResponseFormatName || (exports.ResponseFormatName = ResponseFormatName = {}));
const FORMAT_ID_MAP = new Map([
    [ResponseFormatName.Text, 1],
    [ResponseFormatName.Json, 2],
    [ResponseFormatName.JsonSchema, 3],
]);
const FORMAT_NAME_MAP = new Map([
    [1, ResponseFormatName.Text],
    [2, ResponseFormatName.Json],
    [3, ResponseFormatName.JsonSchema],
]);
/**
 * Gets the format ID for a given response format name.
 *
 * @param {ResponseFormatName} formatName - The response format name
 * @returns {number} The corresponding format ID
 * @throws {Error} If the format name is unknown
 */
function getFormatId(formatName) {
    const id = FORMAT_ID_MAP.get(formatName);
    if (id === undefined) {
        throw new Error(`Unknown response format name: ${formatName}`);
    }
    return id;
}
/**
 * Gets the format name for a given response format ID.
 *
 * @param {number} formatId - The response format ID
 * @returns {ResponseFormatName} The corresponding format name
 * @throws {Error} If the format ID is unknown
 */
function getFormatName(formatId) {
    const name = FORMAT_NAME_MAP.get(formatId);
    if (name === undefined) {
        throw new Error(`Unknown response format id: ${formatId}`);
    }
    return name;
}
