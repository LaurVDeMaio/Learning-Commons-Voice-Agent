"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseFormatName = exports.OptionalToolChoiceData = exports.LLMChatRequestData = void 0;
const expose_binary_1 = require("../../../expose_binary");
const messages_1 = require("../../vector/messages");
const base_data_1 = require("./base_data");
/**
 * Class for handling chat messages in graphs.
 * Extends BaseData with chat message-specific functionality.
 */
class LLMChatRequestData extends base_data_1.BaseData {
    constructor(external) {
        super(external);
    }
    static fromLLMChatRequestInterface(chatRequest) {
        const chatMessages = messages_1.Messages.fromLLMMessageInterfaces(chatRequest.messages);
        let tools = null;
        let responseFormatId = 1; // Default to Text format
        if (chatRequest.responseFormat) {
            responseFormatId = getFormatId(chatRequest.responseFormat);
        }
        const optionalToolChoice = OptionalToolChoiceData.fromToolChoiceInterface(chatRequest.toolChoice);
        if (chatRequest.tools) {
            tools = messages_1.Tools.fromToolInterfaces(chatRequest.tools);
        }
        else {
            tools = messages_1.Tools.fromToolInterfaces([]);
        }
        const external = expose_binary_1.LLMChatRequestFunctions.newFull(chatMessages.getExternal(), tools.getExternal(), optionalToolChoice.getExternal(), responseFormatId);
        tools.destroy();
        chatMessages.destroy();
        optionalToolChoice.destroy();
        return new LLMChatRequestData(external);
    }
    /**
     * @internal
     * Creates a new LLMChatRequest instance from an external reference.
     *
     * @param {ExternalReference} external - The external reference to create the instance from
     * @returns {LLMChatRequestData | null} A new LLMChatRequest instance or null if invalid
     */
    static fromExternal(external) {
        const baseData = expose_binary_1.LLMChatRequestFunctions.toBaseData(external);
        if (baseData && expose_binary_1.LLMChatRequestFunctions.isValid(baseData)) {
            return new LLMChatRequestData(baseData);
        }
        return null;
    }
    /**
     * Gets the LLMChatRequest data as an interface.
     * If external is set, it will parse the external reference,
     * else it will use the stored properties
     *
     * @returns {LLMChatRequestInterface} The LLMChatRequest interface object
     */
    getLLMChatRequest() {
        if (this.external) {
            const responseFormatId = expose_binary_1.LLMChatRequestFunctions.getResponseFormat(this.external);
            let responseFormat;
            if (responseFormatId && responseFormatId > 0) {
                try {
                    responseFormat = getFormatName(responseFormatId);
                }
                catch (_a) {
                    // Handle invalid format ID gracefully
                    responseFormat = ResponseFormatName.Text;
                }
            }
            return {
                messages: messages_1.Messages.fromExternal(expose_binary_1.LLMChatRequestFunctions.getMessages(this.external)).getMessages(),
                tools: messages_1.Tools.fromExternal(expose_binary_1.LLMChatRequestFunctions.getTools(this.external)).getTools(),
                toolChoice: OptionalToolChoiceData.fromExternal(expose_binary_1.LLMChatRequestFunctions.getToolChoice(this.external)).getToolChoice(),
                responseFormat: responseFormat,
            };
        }
        // Fallback
        return {
            messages: [],
        };
    }
    /**
     * Cleans up resources used by the LLMChatRequest instance.
     */
    destroy() {
        super.destroy();
    }
}
exports.LLMChatRequestData = LLMChatRequestData;
class OptionalToolChoiceData {
    constructor(external) {
        this.external = external;
    }
    static fromExternal(external) {
        return new OptionalToolChoiceData(external);
    }
    getToolChoice() {
        if (expose_binary_1.OptionalToolChoiceFunctions.hasValue(this.external)) {
            const toolChoice = expose_binary_1.OptionalToolChoiceFunctions.getValue(this.external);
            if (expose_binary_1.ToolChoiceFunctions.isFunctionChoice(toolChoice)) {
                const functionChoice = expose_binary_1.ToolChoiceFunctions.getFunctionChoice(toolChoice);
                return {
                    choice: {
                        type: expose_binary_1.FunctionChoiceFunctions.getType(functionChoice),
                        name: expose_binary_1.FunctionChoiceFunctions.getName(functionChoice),
                    },
                };
            }
            return {
                choice: expose_binary_1.ToolChoiceFunctions.getStringChoice(toolChoice),
            };
        }
        return null;
    }
    getExternal() {
        return this.external;
    }
    /**
     * Creates an OptionalToolChoice from toolChoice value
     *
     * @param {ToolChoiceInterface} [toolChoice] - Optional tool choice configuration
     * @returns {ExternalReference} External reference to the optional tool choice
     * @private
     */
    static fromToolChoiceInterface(toolChoice) {
        if (!toolChoice) {
            return new OptionalToolChoiceData(expose_binary_1.OptionalToolChoiceFunctions.new());
        }
        const toolChoiceExternal = expose_binary_1.ToolChoiceFunctions.new();
        if (typeof toolChoice.choice === 'string') {
            expose_binary_1.ToolChoiceFunctions.setStringChoice(toolChoiceExternal, toolChoice.choice);
        }
        else {
            const functionChoice = expose_binary_1.FunctionChoiceFunctions.new();
            expose_binary_1.FunctionChoiceFunctions.setType(functionChoice, toolChoice.choice.type || 'function');
            expose_binary_1.FunctionChoiceFunctions.setName(functionChoice, toolChoice.choice.name);
            expose_binary_1.ToolChoiceFunctions.setFunctionChoice(toolChoiceExternal, functionChoice);
            expose_binary_1.FunctionChoiceFunctions.delete(functionChoice);
        }
        const optionalToolChoice = new OptionalToolChoiceData(expose_binary_1.OptionalToolChoiceFunctions.newWithValue(toolChoiceExternal));
        expose_binary_1.ToolChoiceFunctions.delete(toolChoiceExternal);
        return optionalToolChoice;
    }
    destroy() {
        if (this.external) {
            expose_binary_1.OptionalToolChoiceFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.OptionalToolChoiceData = OptionalToolChoiceData;
/** Response format name. */
var ResponseFormatName;
(function (ResponseFormatName) {
    /** Plain text response format */
    ResponseFormatName["Text"] = "text";
    /** JSON response format */
    ResponseFormatName["Json"] = "json";
    /** JSON Schema response format */
    ResponseFormatName["JsonSchema"] = "json_schema";
})(ResponseFormatName || (exports.ResponseFormatName = ResponseFormatName = {}));
const FORMAT_ID_MAP = new Map([
    [ResponseFormatName.Text, 1],
    [ResponseFormatName.Json, 2],
    [ResponseFormatName.JsonSchema, 3],
]);
const FORMAT_NAME_MAP = new Map([
    [1, ResponseFormatName.Text],
    [2, ResponseFormatName.Json],
    [3, ResponseFormatName.JsonSchema],
]);
/**
 * Gets the format ID for a given response format name.
 *
 * @param {ResponseFormatName} formatName - The response format name
 * @returns {number} The corresponding format ID
 * @throws {Error} If the format name is unknown
 */
function getFormatId(formatName) {
    const id = FORMAT_ID_MAP.get(formatName);
    if (id === undefined) {
        throw new Error(`Unknown response format name: ${formatName}`);
    }
    return id;
}
/**
 * Gets the format name for a given response format ID.
 *
 * @param {number} formatId - The response format ID
 * @returns {ResponseFormatName} The corresponding format name
 * @throws {Error} If the format ID is unknown
 */
function getFormatName(formatId) {
    const name = FORMAT_NAME_MAP.get(formatId);
    if (name === undefined) {
        throw new Error(`Unknown response format id: ${formatId}`);
    }
    return name;
}
