"use strict";
/**
 * Base transformation stream implementation using Node-API approach with createTransformStreamWrapper.
 * This replaces the previous deasync and koffi callback approach with native async support.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransformationStream = void 0;
const expose_binary_1 = require("../../expose_binary");
const node_api_1 = require("../../node-api");
const audio_data_1 = require("../data_types/external/audio_data");
const external_1 = require("../error/external");
const inworld_1 = require("../error/inworld");
const float_1 = require("../vector/float");
const string_1 = require("../vector/string");
const interfaces_1 = require("./interfaces");
/**
 * Base class for transformation streams.
 * @internal
 */
class BaseTransformationStream {
    constructor(options) {
        this.outputType = options.outputType;
        this.streamFunctions = BaseTransformationStream.getStreamFunctions(this.outputType);
        const transformCallback = this.createTransformCallback(options.transform);
        const stringStringTransformationStream = this.streamFunctions.newStreamWithCallbackOnly(options.stream, transformCallback);
        const inputStream = this.streamFunctions.getInputStream(stringStringTransformationStream);
        this.external = this.streamFunctions.newDataStream(inputStream, null);
    }
    /**
     * Returns the external reference to the native data implementation.
     *
     * @returns External reference object
     */
    getExternal() {
        return this.external;
    }
    destroy() {
        if (this.external) {
            this.streamFunctions.deleteStream(this.external);
            this.external = null;
        }
    }
    transformInputType(input) {
        if (this.outputType === interfaces_1.TransformationStreamType.TEXT_TO_TEXT) {
            return input;
        }
        else if (this.outputType === interfaces_1.TransformationStreamType.TEXT_TO_TTS) {
            return input; // TODO:
        }
        else if (this.outputType === interfaces_1.TransformationStreamType.CONTENT_TO_TEXT) {
            return input;
        }
        else {
            throw new inworld_1.InworldError(`Invalid transformation stream type: ${this.outputType}`);
        }
    }
    static getStreamFunctions(type) {
        switch (type) {
            case interfaces_1.TransformationStreamType.TEXT_TO_TEXT:
                return expose_binary_1.TransformationStreamStringToStringFunctions;
            case interfaces_1.TransformationStreamType.CONTENT_TO_TEXT:
                return expose_binary_1.TransformationStreamContentToTextFunctions;
            case interfaces_1.TransformationStreamType.TEXT_TO_TTS:
                return expose_binary_1.TransformationStreamStrToTTSOutputFunctions;
            default:
                throw new inworld_1.InworldError(`Invalid transformation stream type: ${type}`);
        }
    }
    prepareOutput(transformResult) {
        switch (this.outputType) {
            case interfaces_1.TransformationStreamType.TEXT_TO_TEXT:
                return transformResult;
            case interfaces_1.TransformationStreamType.TEXT_TO_TTS:
                const { text, phonemes, timestamps, audio } = transformResult;
                const phonemesExternal = new string_1.VectorString(phonemes);
                const timestampsExternal = new float_1.VectorFloat(timestamps);
                const audioExternal = new audio_data_1.AudioData(audio);
                return expose_binary_1.TTSOutputFunctions.new(text, audioExternal.getExternal(), phonemesExternal.getExternal(), timestampsExternal.getExternal());
            default:
                throw new inworld_1.InworldError(`Invalid transformation stream type: ${this.outputType}`);
        }
    }
    static getError(e) {
        const error = new external_1.ExternalProcessError(e.message, external_1.ExternalProcessStatusCode.Unknown);
        return expose_binary_1.StatusOrBaseDataFunctions.newFromBaseData(error.getExternal());
    }
    createTransformCallback(transform) {
        const callback = async (inputExternal) => {
            try {
                const transformResult = await transform(this.transformInputType(inputExternal));
                return this.streamFunctions.newEntity(this.prepareOutput(transformResult));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.log('transform callback error', e);
                return BaseTransformationStream.getError(e);
            }
        };
        const returnTypeTag = this.getReturnTypeTag();
        return (0, node_api_1.createTransformStreamWrapper)(callback, returnTypeTag);
    }
    getReturnTypeTag() {
        switch (this.outputType) {
            case interfaces_1.TransformationStreamType.TEXT_TO_TEXT:
                return 'String';
            case interfaces_1.TransformationStreamType.TEXT_TO_TTS:
                return 'TTSOutput';
            default:
                throw new inworld_1.InworldError(`Invalid transformation stream type: ${this.outputType}`);
        }
    }
}
exports.BaseTransformationStream = BaseTransformationStream;
