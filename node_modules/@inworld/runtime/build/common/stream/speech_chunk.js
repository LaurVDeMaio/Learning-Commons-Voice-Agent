"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpeechChunkStream = void 0;
const expose_binary_1 = require("../../expose_binary");
const helpers_1 = require("../helpers");
const index_1 = require("../index");
const base_1 = require("./base");
/**
 * Class for handling string-based streams.
 * Provides functionality to read text data from native stream implementations.
 * @internal
 */
class SpeechChunkStream extends base_1.BaseDataStream {
    /**
     * Creates a new SpeechChunkStream instance.
     *
     * @param stream - External reference to the native stream implementation
     * @param onDestroy - Optional callback to execute when stream is consumed
     */
    constructor(stream, onDestroy) {
        super(stream, onDestroy);
    }
    /**
     * Asynchronously reads the next item from the stream.
     *
     * @returns Promise resolving to a result object with text content or done flag
     * @throws InworldError if reading from the stream fails
     */
    async next() {
        var _a, _b;
        while (await expose_binary_1.SpeechChunkInputStreamFunctions.hasNext(this.stream)) {
            const chunkStatus = await expose_binary_1.SpeechChunkInputStreamFunctions.read(this.stream);
            if (!expose_binary_1.SpeechChunkStatusFunctions.isOK(chunkStatus)) {
                (_a = this.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
                throw new index_1.InworldError('Failed to read speech chunk', (0, helpers_1.getStatus)(chunkStatus));
            }
            // Get the chunk
            const chunk = expose_binary_1.SpeechChunkStatusFunctions.getValue(chunkStatus);
            try {
                // Get the waveform
                const waveformPtr = expose_binary_1.SpeechChunkFunctions.getWaveform(chunk);
                // Convert the waveform to a Float32Array
                const audio = index_1.VectorFloat.toArray(waveformPtr);
                // Get phoneme timestamps if available
                let phonemeTimestamps = this.getPhonemeTimestamps(chunk) || [];
                // return chunk
                return { done: false, audio, phonemeTimestamps };
            }
            finally {
                // Clean up the chunk
                expose_binary_1.SpeechChunkFunctions.delete(chunk);
            }
        }
        (_b = this.onDestroy) === null || _b === void 0 ? void 0 : _b.call(this);
        return { done: true };
    }
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                const result = await this.next();
                if (result.done) {
                    return { done: true, value: undefined };
                }
                return { done: false, value: result };
            },
        };
    }
    /**
     * Extracts phoneme timestamps from a speech chunk.
     *
     * @param chunk - Speech chunk to extract phoneme timestamps from
     * @returns Array of phoneme timestamps or undefined if not available
     * @private
     */
    getPhonemeTimestamps(chunk) {
        const phonemeTimestampsVector = expose_binary_1.SpeechChunkFunctions.getPhonemeTimestamps(chunk);
        let phonemeTimestamps = undefined;
        if (phonemeTimestampsVector) {
            const vectorSize = expose_binary_1.PhonemeTimestampVectorFunctions.size(phonemeTimestampsVector);
            if (vectorSize > 0) {
                phonemeTimestamps = [];
                for (let i = 0; i < vectorSize; i++) {
                    const timestampPtr = expose_binary_1.PhonemeTimestampVectorFunctions.get(phonemeTimestampsVector, i);
                    const phoneme = expose_binary_1.PhonemeTimestampFunctions.getPhoneme(timestampPtr);
                    const startTimeSec = expose_binary_1.PhonemeTimestampFunctions.getStartTimeSec(timestampPtr);
                    phonemeTimestamps.push({ phoneme, startTimeSec });
                }
            }
        }
        return phonemeTimestamps;
    }
    /**
     * Creates a new SpeechChunkStream instance from an external reference.
     *
     * @param stream - External reference to the native stream implementation
     * @returns A new SpeechChunkStream instance
     * @internal
     */
    static fromExternal(stream) {
        const streamData = expose_binary_1.SpeechChunkFunctions.toStream(stream);
        return new SpeechChunkStream(streamData);
    }
}
exports.SpeechChunkStream = SpeechChunkStream;
