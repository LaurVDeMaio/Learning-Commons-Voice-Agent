"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateExecutionId = exports.logger = exports.startSpanWithParent = exports.startSpanWithAttributes = exports.startSpan = exports.Span = exports.configureMetric = exports.init = exports.shutdown = exports.getInstance = exports.metric = exports.ExporterType = exports.LogLevel = exports.MetricType = void 0;
const process = __importStar(require("node:process"));
const auth_1 = require("../common/auth");
const constants_1 = require("../common/constants");
const inworld_1 = require("../common/error/inworld");
const expose_binary_1 = require("../expose_binary");
const process_context_Impl_1 = require("../graph/nodes/custom/process_context_Impl");
/**
 * Metric types for telemetry data collection
 * @description Defines the different types of metrics that can be recorded
 */
var MetricType;
(function (MetricType) {
    /**
     * Counter with unsigned integer values
     * @description Monotonically increasing counter for counting events
     */
    MetricType[MetricType["COUNTER_UINT"] = 0] = "COUNTER_UINT";
    /**
     * Counter with double values
     * @description Monotonically increasing counter with floating-point precision
     */
    MetricType[MetricType["COUNTER_DOUBLE"] = 1] = "COUNTER_DOUBLE";
    /**
     * Gauge with integer values
     * @description Point-in-time measurement that can go up or down
     */
    MetricType[MetricType["GAUGE_INT"] = 2] = "GAUGE_INT";
    /**
     * Gauge with double values
     * @description Point-in-time measurement with floating-point precision
     */
    MetricType[MetricType["GAUGE_DOUBLE"] = 3] = "GAUGE_DOUBLE";
    /**
     * Histogram with unsigned integer values
     * @description Distribution of values over time for integer data
     */
    MetricType[MetricType["HISTOGRAM_UINT"] = 4] = "HISTOGRAM_UINT";
    /**
     * Histogram with double values
     * @description Distribution of values over time for floating-point data
     */
    MetricType[MetricType["HISTOGRAM_DOUBLE"] = 5] = "HISTOGRAM_DOUBLE";
})(MetricType || (exports.MetricType = MetricType = {}));
/**
 * Log levels for telemetry logging
 * @description Maps to VERBOSITY values in the underlying telemetry system
 */
var LogLevel;
(function (LogLevel) {
    /**
     * Trace level - most verbose logging
     * @description Verbosity = 2, captures all possible log messages
     */
    LogLevel["TRACE"] = "TRACE";
    /**
     * Debug level - detailed debugging information
     * @description Verbosity = 1, useful for development and troubleshooting
     */
    LogLevel["DEBUG"] = "DEBUG";
    /**
     * Info level - general information messages
     * @description Verbosity = 0, standard operational information
     */
    LogLevel["INFO"] = "INFO";
    /**
     * Warning level - potential issues
     * @description Important messages about potential problems
     */
    LogLevel["WARN"] = "WARN";
    /**
     * Error level - error conditions
     * @description Error messages for actual problems
     */
    LogLevel["ERROR"] = "ERROR";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
/**
 * Exporter types for telemetry data
 * @description Defines where telemetry data is sent
 */
var ExporterType;
(function (ExporterType) {
    /**
     * Local exporter - data stays on the local machine
     * @description Useful for development, debugging, or local analysis
     */
    ExporterType["LOCAL"] = "LOCAL";
    /**
     * Remote exporter - data sent to remote telemetry service
     * @description Production-ready, sends data to configured endpoint
     */
    ExporterType["REMOTE"] = "REMOTE";
})(ExporterType || (exports.ExporterType = ExporterType = {}));
/**
 * Telemetry class for managing telemetry lifecycle
 * @description Internal class that handles telemetry initialization, configuration, and cleanup
 */
class Telemetry {
    /**
     * Creates a new Telemetry instance
     * @param {TelemetryConfigInterface} props - Configuration for telemetry initialization
     * @throws {InworldError} When apiKey is missing or initialization fails
     */
    constructor(props) {
        var _a;
        this.initialized = false;
        if (!(props === null || props === void 0 ? void 0 : props.apiKey)) {
            throw new inworld_1.InworldError('apiKey is required to initialize telemetry');
        }
        const { apiKey, appName = constants_1.DEFAULT_TELEMETRY_APP_NAME, appVersion = constants_1.DEFAULT_TELEMETRY_APP_VERSION, endpoint, logger, tracer, exporterType = ExporterType.REMOTE, } = props;
        // Select endpoint based on env if not explicitly provided
        const resolvedEndpoint = endpoint || (0, auth_1.getAuthEndpointFromEnv)();
        try {
            this.config = expose_binary_1.TelemetryFunctions.configNew();
            if (apiKey) {
                expose_binary_1.TelemetryFunctions.configSetApiKey(this.config, apiKey);
            }
            if (appName) {
                expose_binary_1.TelemetryFunctions.configSetServiceName(this.config, appName);
            }
            if (appVersion) {
                expose_binary_1.TelemetryFunctions.configSetAppVersion(this.config, appVersion);
            }
            if (resolvedEndpoint) {
                process.env.INWORLD_ENDPOINT = resolvedEndpoint;
                expose_binary_1.TelemetryFunctions.configSetEndpoint(this.config, resolvedEndpoint);
            }
            expose_binary_1.TelemetryFunctions.configSetExporterType(this.config, this.mapExporterTypeToExternal(exporterType));
            // Create logger config
            this.loggerConfig = expose_binary_1.TelemetryFunctions.configLoggerNew();
            expose_binary_1.TelemetryFunctions.configLoggerSetSinkAbslLogs(this.loggerConfig, (_a = logger === null || logger === void 0 ? void 0 : logger.sinkAbslLogs) !== null && _a !== void 0 ? _a : true);
            const level = (logger === null || logger === void 0 ? void 0 : logger.level) && this.mapLogLevelToExternal(logger.level);
            if (level != null) {
                expose_binary_1.TelemetryFunctions.configLoggerSetLevel(this.loggerConfig, level);
            }
            expose_binary_1.TelemetryFunctions.configSetLogger(this.config, this.loggerConfig);
            // Create tracer config
            if ((tracer === null || tracer === void 0 ? void 0 : tracer.samplingRate) != null) {
                this.tracerConfig = expose_binary_1.TelemetryFunctions.configTracerNew();
                expose_binary_1.TelemetryFunctions.configTracerSetSamplingRate(this.tracerConfig, tracer.samplingRate);
                expose_binary_1.TelemetryFunctions.configSetTracer(this.config, this.tracerConfig);
            }
        }
        catch (error) {
            this.destroy();
            throw new inworld_1.InworldError('Failed to initialize telemetry', error);
        }
    }
    /**
     * Initializes the telemetry system
     * @description Starts telemetry collection and makes the instance globally available
     */
    init() {
        if (!this.initialized) {
            expose_binary_1.TelemetryFunctions.init(this.config);
            this.initialized = true;
            Telemetry.instance = this;
        }
    }
    /**
     * Shuts down the telemetry system
     * @description Stops telemetry collection and cleans up resources
     */
    shutdown() {
        Telemetry.instance = undefined;
        if (this.initialized) {
            expose_binary_1.TelemetryFunctions.shutdown();
            this.initialized = false;
            this.destroy();
        }
    }
    /**
     * Gets the singleton telemetry instance
     * @returns {Telemetry | undefined} The current telemetry instance or undefined if not initialized
     */
    static getInstance() {
        return Telemetry.instance;
    }
    /**
     * Cleans up telemetry resources
     * @description Destroys all configuration objects and frees memory
     * @private
     */
    destroy() {
        if (this.config) {
            expose_binary_1.TelemetryFunctions.configDelete(this.config);
            this.config = undefined;
        }
        if (this.loggerConfig) {
            expose_binary_1.TelemetryFunctions.configLoggerDelete(this.loggerConfig);
            this.loggerConfig = undefined;
        }
        if (this.tracerConfig) {
            expose_binary_1.TelemetryFunctions.configTracerDelete(this.tracerConfig);
            this.tracerConfig = undefined;
        }
    }
    /**
     * Maps exporter type enum to internal numeric value
     * @param {ExporterType} exporterType - The exporter type to map
     * @returns {number} Internal numeric representation
     * @private
     */
    mapExporterTypeToExternal(exporterType) {
        switch (exporterType) {
            case ExporterType.LOCAL:
                return 0;
            case ExporterType.REMOTE:
                return 1;
        }
    }
    /**
     * Maps log level enum to internal numeric value
     * @param {LogLevel} logLevel - The log level to map
     * @returns {number} Internal numeric representation
     * @private
     */
    mapLogLevelToExternal(logLevel) {
        switch (logLevel) {
            case LogLevel.TRACE:
                return 0;
            case LogLevel.DEBUG:
                return 1;
            case LogLevel.INFO:
                return 2;
            case LogLevel.WARN:
                return 3;
            case LogLevel.ERROR:
                return 4;
        }
    }
}
/**
 * MetricConfig class for configuring metrics
 * @description Internal class for creating and managing metric configurations
 * @internal
 */
class MetricConfig {
    /**
     * Creates a new metric configuration
     * @param {MetricConfigInterface} props - Configuration properties for the metric
     * @throws {InworldError} When metric name is missing or configuration fails
     */
    constructor(props) {
        this.config = expose_binary_1.TelemetryFunctions.metricConfigNew();
        try {
            expose_binary_1.TelemetryFunctions.metricConfigSetMetricType(this.config, props.metricType);
            if (!props.name) {
                throw new inworld_1.InworldError('Metric name is required');
            }
            expose_binary_1.TelemetryFunctions.metricConfigSetName(this.config, props.name);
            if (props.description) {
                expose_binary_1.TelemetryFunctions.metricConfigSetDescription(this.config, props.description);
            }
            if (props.unit) {
                expose_binary_1.TelemetryFunctions.metricConfigSetUnit(this.config, props.unit);
            }
        }
        catch (error) {
            this.destroy();
            throw new inworld_1.InworldError('Failed to create metric config', error);
        }
    }
    /**
     * Registers the metric with the telemetry system
     * @description Makes the metric available for recording data
     */
    configure() {
        expose_binary_1.TelemetryFunctions.configureMetric(this.config);
    }
    /**
     * Gets the configured metric type
     * @returns {MetricType} The type of this metric
     */
    getMetricType() {
        return expose_binary_1.TelemetryFunctions.metricConfigGetMetricType(this.config);
    }
    /**
     * Gets the configured metric name
     * @returns {string} The name of this metric
     */
    getName() {
        return expose_binary_1.TelemetryFunctions.metricConfigGetName(this.config);
    }
    /**
     * Gets the configured metric description
     * @returns {string} The description of this metric
     */
    getDescription() {
        return expose_binary_1.TelemetryFunctions.metricConfigGetDescription(this.config);
    }
    /**
     * Gets the configured metric unit
     * @returns {string} The unit of this metric
     */
    getUnit() {
        return expose_binary_1.TelemetryFunctions.metricConfigGetUnit(this.config);
    }
    /**
     * Cleans up metric configuration resources
     * @description Destroys the configuration object and frees memory
     * @private
     */
    destroy() {
        if (this.config) {
            expose_binary_1.TelemetryFunctions.metricConfigDelete(this.config);
            this.config = undefined;
        }
    }
}
/**
 * Converts JavaScript object to native map for telemetry functions
 * @param {Record<string, string> | undefined} tags - Key-value pairs to convert
 * @returns {any | undefined} Native map object or undefined if no tags provided
 * @private
 */
function toNativeMap(tags) {
    if (!tags)
        return undefined;
    const map = expose_binary_1.MapStringStringFunctions.new();
    for (const [k, v] of Object.entries(tags)) {
        expose_binary_1.MapStringStringFunctions.set(map, k, v);
    }
    return map;
}
/**
 * Metric recording utilities
 * @description Provides functions to record different types of metrics with optional tags
 */
exports.metric = {
    /**
     * Records an unsigned integer counter metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The counter value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the metric
     * @example
     * ```typescript
     * metric.recordCounterUInt('requests_total', 1, { endpoint: '/api/users', method: 'GET' });
     * ```
     */
    recordCounterUInt(name, value, tags) {
        if (tags) {
            const map = toNativeMap(tags);
            expose_binary_1.TelemetryFunctions.recordCounterUIntWithTags(name, value, map);
            expose_binary_1.MapStringStringFunctions.delete(map);
        }
        else {
            expose_binary_1.TelemetryFunctions.recordCounterUInt(name, value);
        }
    },
    /**
     * Records a double precision counter metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The counter value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the metric
     * @example
     * ```typescript
     * metric.recordCounterDouble('bytes_processed', 1024.5, { data_type: 'json' });
     * ```
     */
    recordCounterDouble(name, value, tags) {
        if (tags) {
            const map = toNativeMap(tags);
            expose_binary_1.TelemetryFunctions.recordCounterDoubleWithTags(name, value, map);
            expose_binary_1.MapStringStringFunctions.delete(map);
        }
        else {
            expose_binary_1.TelemetryFunctions.recordCounterDouble(name, value);
        }
    },
    /**
     * Records an integer gauge metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The gauge value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the metric
     * @example
     * ```typescript
     * metric.recordGaugeInt('active_connections', 42, { server: 'web-01' });
     * ```
     */
    recordGaugeInt(name, value, tags) {
        if (tags) {
            const map = toNativeMap(tags);
            expose_binary_1.TelemetryFunctions.recordGaugeIntWithTags(name, value, map);
            expose_binary_1.MapStringStringFunctions.delete(map);
        }
        else {
            expose_binary_1.TelemetryFunctions.recordGaugeInt(name, value);
        }
    },
    /**
     * Records a double precision gauge metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The gauge value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the metric
     * @example
     * ```typescript
     * metric.recordGaugeDouble('cpu_usage_percent', 75.5, { core: '0' });
     * ```
     */
    recordGaugeDouble(name, value, tags) {
        if (tags) {
            const map = toNativeMap(tags);
            expose_binary_1.TelemetryFunctions.recordGaugeDoubleWithTags(name, value, map);
            expose_binary_1.MapStringStringFunctions.delete(map);
        }
        else {
            expose_binary_1.TelemetryFunctions.recordGaugeDouble(name, value);
        }
    },
    /**
     * Records an unsigned integer histogram metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The value to record in the histogram
     * @param {Record<string, string>} [tags] - Optional key-value tags for the metric
     * @example
     * ```typescript
     * metric.recordHistogramUInt('request_duration_ms', 150, { endpoint: '/api/data' });
     * ```
     */
    recordHistogramUInt(name, value, tags) {
        if (tags) {
            const map = toNativeMap(tags);
            expose_binary_1.TelemetryFunctions.recordHistogramUIntWithTags(name, value, map);
            expose_binary_1.MapStringStringFunctions.delete(map);
        }
        else {
            expose_binary_1.TelemetryFunctions.recordHistogramUInt(name, value);
        }
    },
    /**
     * Records a double precision histogram metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The value to record in the histogram
     * @param {Record<string, string>} [tags] - Optional key-value tags for the metric
     * @example
     * ```typescript
     * metric.recordHistogramDouble('memory_usage_mb', 512.75, { process: 'worker-1' });
     * ```
     */
    recordHistogramDouble(name, value, tags) {
        if (tags) {
            const map = toNativeMap(tags);
            expose_binary_1.TelemetryFunctions.recordHistogramDoubleWithTags(name, value, map);
            expose_binary_1.MapStringStringFunctions.delete(map);
        }
        else {
            expose_binary_1.TelemetryFunctions.recordHistogramDouble(name, value);
        }
    },
};
let initialized = false;
/**
 * Gets the current telemetry instance
 * @description Returns the singleton telemetry instance if initialized
 * @returns {Telemetry | undefined} The telemetry instance or undefined if not initialized
 * @example
 * ```typescript
 * const telemetry = getInstance();
 * if (telemetry) {
 *   // Telemetry is initialized and available
 * }
 * ```
 */
const getInstance = () => {
    return Telemetry.getInstance();
};
exports.getInstance = getInstance;
/**
 * Shuts down the telemetry system
 * @description Stops telemetry collection and cleans up all resources
 * @example
 * ```typescript
 * // Gracefully shutdown telemetry before application exit
 * shutdown();
 * ```
 */
const shutdown = () => {
    var _a;
    (_a = (0, exports.getInstance)()) === null || _a === void 0 ? void 0 : _a.shutdown();
};
exports.shutdown = shutdown;
/**
 * Initializes the telemetry system
 * @description Sets up telemetry collection with the provided configuration
 * @param {TelemetryConfigInterface} props - Configuration for telemetry initialization
 * @throws {InworldError} When apiKey is missing or initialization fails
 * @example
 * ```typescript
 * init({
 *   apiKey: 'your-api-key',
 *   appName: 'my-application',
 *   appVersion: '1.0.0',
 *   logger: { level: LogLevel.INFO },
 *   tracer: { samplingRate: 0.1 }
 * });
 * ```
 */
const init = (props) => {
    if (initialized) {
        (0, exports.shutdown)();
        new Telemetry(props).init();
    }
    else {
        new Telemetry(props).init();
        initialized = true;
    }
};
exports.init = init;
/**
 * Configures a metric with the telemetry system
 * @description Registers a metric definition for later use in recording data
 * @param {MetricConfigInterface} config - Configuration for the metric to register
 * @throws {InworldError} When metric name is missing or configuration fails
 * @example
 * ```typescript
 * configureMetric({
 *   metricType: MetricType.COUNTER_UINT,
 *   name: 'requests_total',
 *   description: 'Total number of HTTP requests',
 *   unit: 'requests'
 * });
 * ```
 */
const configureMetric = (config) => {
    const metricConfig = new MetricConfig(config);
    metricConfig.configure();
};
exports.configureMetric = configureMetric;
/**
 * Span class for distributed tracing
 * @description Represents a span in distributed tracing, allowing you to track operations and add attributes
 */
class Span {
    /**
     * Creates a new Span instance
     * @param {ExternalReference} span - The native span reference
     * @internal
     */
    constructor(span) {
        this.isEnded = false;
        this.span = span;
    }
    /**
     * Sets a string attribute on the span
     * @param {string} key - The attribute key
     * @param {string} value - The attribute value
     * @example
     * ```typescript
     * span.setAttribute('user.id', '12345');
     * span.setAttribute('operation.type', 'database_query');
     * ```
     */
    setAttribute(key, value) {
        if (this.isEnded) {
            throw new inworld_1.InworldError('Cannot set attribute on ended span');
        }
        expose_binary_1.TelemetryFunctions.spanSetAttribute(this.span, key, value);
    }
    /**
     * Sets an array of strings as an attribute on the span
     * @param {string} key - The attribute key
     * @param {string[]} values - The array of string values
     * @example
     * ```typescript
     * span.setAttributeArray('tags', ['production', 'critical']);
     * span.setAttributeArray('endpoints', ['/api/users', '/api/posts']);
     * ```
     */
    setAttributeArray(key, values) {
        if (this.isEnded) {
            throw new inworld_1.InworldError('Cannot set attribute on ended span');
        }
        const vector = expose_binary_1.VectorStringFunctions.new();
        try {
            for (const value of values) {
                expose_binary_1.VectorStringFunctions.pushBack(vector, value);
            }
            expose_binary_1.TelemetryFunctions.spanSetAttributeArray(this.span, key, vector);
        }
        finally {
            expose_binary_1.VectorStringFunctions.delete(vector);
        }
    }
    /**
     * Sets the span status to OK
     * @description Marks the span as successfully completed
     * @example
     * ```typescript
     * try {
     *   // ... operation ...
     *   span.setOK();
     * } catch (error) {
     *   span.setError(error.message);
     * }
     * ```
     */
    setOK() {
        if (this.isEnded) {
            throw new inworld_1.InworldError('Cannot set status on ended span');
        }
        expose_binary_1.TelemetryFunctions.spanSetOK(this.span);
    }
    /**
     * Sets the span status to Error with a description
     * @param {string} description - Description of the error
     * @description Marks the span as failed with an error description
     * @example
     * ```typescript
     * try {
     *   // ... operation ...
     *   span.setOK();
     * } catch (error) {
     *   span.setError(`Database query failed: ${error.message}`);
     * }
     * ```
     */
    setError(description) {
        if (this.isEnded) {
            throw new inworld_1.InworldError('Cannot set status on ended span');
        }
        expose_binary_1.TelemetryFunctions.spanSetError(this.span, description);
    }
    /**
     * Ends the span
     * @description Marks the span as completed and sends it to the telemetry system
     * @example
     * ```typescript
     * const span = startSpan('database_operation');
     * try {
     *   // ... operation ...
     *   span.setOK();
     * } finally {
     *   span.end();
     * }
     * ```
     */
    end() {
        if (!this.isEnded) {
            expose_binary_1.TelemetryFunctions.spanEnd(this.span);
            this.isEnded = true;
        }
    }
    /**
     * Gets the native span reference
     * @returns {ExternalReference} The native span reference
     * @internal
     */
    getNativeSpan() {
        return this.span;
    }
    /**
     * Cleans up the span resources
     * @description Destroys the native span object and frees memory
     * @internal
     */
    destroy() {
        if (this.span) {
            expose_binary_1.TelemetryFunctions.spanDelete(this.span);
            this.span = undefined;
        }
    }
}
exports.Span = Span;
/**
 * Starts a new span for distributed tracing
 * @param {string} name - The name of the span
 * @returns {Span} A new span instance
 * @example
 * ```typescript
 * const span = startSpan('user_authentication');
 * span.setAttribute('user.id', '12345');
 * // ... operation ...
 * span.setOK();
 * span.end();
 * ```
 */
const startSpan = (name) => {
    const nativeSpan = expose_binary_1.TelemetryFunctions.startSpan(name);
    return new Span(nativeSpan);
};
exports.startSpan = startSpan;
/**
 * Starts a new span with initial attributes
 * @param {string} name - The name of the span
 * @param {Record<string, string>} attributes - Initial attributes to set on the span
 * @returns {Span} A new span instance with the specified attributes
 * @example
 * ```typescript
 * const span = startSpanWithAttributes('api_request', {
 *   'http.method': 'GET',
 *   'http.url': '/api/users',
 *   'user.id': '12345'
 * });
 * ```
 */
const startSpanWithAttributes = (name, attributes) => {
    const map = toNativeMap(attributes);
    try {
        const nativeSpan = expose_binary_1.TelemetryFunctions.startSpanWithAttributes(name, map);
        const span = new Span(nativeSpan);
        return span;
    }
    finally {
        expose_binary_1.MapStringStringFunctions.delete(map);
    }
};
exports.startSpanWithAttributes = startSpanWithAttributes;
/**
 * Starts a new span with a parent span for distributed tracing
 * @param {string} name - The name of the span
 * @param {Record<string, string>} attributes - Initial attributes to set on the span
 * @param {Span[]} links - Array of spans to link to this span
 * @param {Span} parent - The parent span
 * @returns {Span} A new span instance with parent relationship
 * @example
 * ```typescript
 * const parentSpan = startSpan('parent_operation');
 * const childSpan = startSpanWithParent('child_operation', {
 *   'operation.type': 'sub_task'
 * }, [], parentSpan);
 * ```
 */
const startSpanWithParent = (name, attributes, links, parent) => {
    const map = toNativeMap(attributes);
    const vector = expose_binary_1.TelemetryFunctions.vectorSpanNew();
    try {
        for (const link of links) {
            expose_binary_1.TelemetryFunctions.vectorSpanPushBack(vector, link.getNativeSpan());
        }
        const nativeSpan = expose_binary_1.TelemetryFunctions.startSpanWithParent(name, map, vector, parent.getNativeSpan());
        const span = new Span(nativeSpan);
        return span;
    }
    finally {
        expose_binary_1.MapStringStringFunctions.delete(map);
        expose_binary_1.TelemetryFunctions.vectorSpanDelete(vector);
    }
};
exports.startSpanWithParent = startSpanWithParent;
/**
 * Logging utilities
 * @description Provides functions to log messages with different levels and optional context
 */
exports.logger = {
    /**
     * Maps log level enum to internal numeric value
     * @param {LogLevel} logLevel - The log level to map
     * @returns {number} Internal numeric representation
     * @private
     */
    mapLogLevelToExternal(logLevel) {
        switch (logLevel) {
            case LogLevel.TRACE:
                return 0;
            case LogLevel.DEBUG:
                return 1;
            case LogLevel.INFO:
                return 2;
            case LogLevel.WARN:
                return 3;
            case LogLevel.ERROR:
                return 4;
            default:
                return 2; // Default to INFO
        }
    },
    /**
     * Logs a message with the specified log level
     * @param {LogLevel} level - The log level for the message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for the log message
     * @param {ProcessContext} [processContext] - Optional process context to add execution info
     * @example
     * ```typescript
     * logger.log(LogLevel.INFO, 'User logged in', { userId: '123', method: 'oauth' });
     * logger.log(LogLevel.ERROR, 'Database connection failed', {}, processContext);
     * logger.log(LogLevel.DEBUG, 'Processing node', { nodeId: 'abc' }, processContext);
     * ```
     */
    log(level, message, context, processContext) {
        const levelValue = this.mapLogLevelToExternal(level);
        const external = processContext instanceof process_context_Impl_1.ProcessContextImpl
            ? processContext.getExternal()
            : null;
        if (external && typeof external.asExternal === 'function') {
            // ProcessContext provided - use dedicated function with context (or empty map if no context)
            const map = toNativeMap(context || {});
            try {
                expose_binary_1.TelemetryFunctions.logMessageWithMapAndProcessContext(levelValue, message, external.asExternal(), map);
            }
            finally {
                expose_binary_1.MapStringStringFunctions.delete(map);
            }
        }
        else if (context) {
            // Only context provided
            const map = toNativeMap(context);
            try {
                expose_binary_1.TelemetryFunctions.logMessageWithMap(levelValue, message, map);
            }
            finally {
                expose_binary_1.MapStringStringFunctions.delete(map);
            }
        }
        else {
            // No context or processContext
            expose_binary_1.TelemetryFunctions.logMessage(levelValue, message);
        }
    },
    /**
     * Logs a trace level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for the log message
     * @param {ProcessContext} [processContext] - Optional process context to add execution info
     * @example
     * ```typescript
     * logger.trace('Entering function processData', { functionName: 'processData', args: 'user123' });
     * logger.trace('Processing node', {}, processContext);
     * ```
     */
    trace(message, context, processContext) {
        this.log(LogLevel.TRACE, message, context, processContext);
    },
    /**
     * Logs a debug level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for the log message
     * @param {ProcessContext} [processContext] - Optional process context to add execution info
     * @example
     * ```typescript
     * logger.debug('Processing user data', { userId: '123', operation: 'update' });
     * logger.debug('Node processing', {}, processContext);
     * ```
     */
    debug(message, context, processContext) {
        this.log(LogLevel.DEBUG, message, context, processContext);
    },
    /**
     * Logs an info level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for the log message
     * @param {ProcessContext} [processContext] - Optional process context to add execution info
     * @example
     * ```typescript
     * logger.info('User successfully authenticated', { userId: '123', provider: 'google' });
     * logger.info('Node execution completed', {}, processContext);
     * ```
     */
    info(message, context, processContext) {
        this.log(LogLevel.INFO, message, context, processContext);
    },
    /**
     * Logs a warning level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for the log message
     * @param {ProcessContext} [processContext] - Optional process context to add execution info
     * @example
     * ```typescript
     * logger.warn('API rate limit approaching', { currentUsage: '80%', endpoint: '/api/users' });
     * logger.warn('Node processing slow', {}, processContext);
     * ```
     */
    warn(message, context, processContext) {
        this.log(LogLevel.WARN, message, context, processContext);
    },
    /**
     * Logs an error level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for the log message
     * @param {ProcessContext} [processContext] - Optional process context to add execution info
     * @example
     * ```typescript
     * logger.error('Database connection failed', { error: 'ECONNREFUSED', host: 'db.example.com' });
     * logger.error('Node execution failed', { error: 'timeout' }, processContext);
     * ```
     */
    error(message, context, processContext) {
        this.log(LogLevel.ERROR, message, context, processContext);
    },
};
/**
 * Generates a unique execution ID
 * @returns {string} A unique execution identifier
 * @description Useful for correlating operations across different spans and services
 * @example
 * ```typescript
 * const executionId = generateExecutionId();
 * console.log(`Starting execution: ${executionId}`);
 * ```
 */
const generateExecutionId = () => {
    return expose_binary_1.TelemetryFunctions.generateExecutionId();
};
exports.generateExecutionId = generateExecutionId;
