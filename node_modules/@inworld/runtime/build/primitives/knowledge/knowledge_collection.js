"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnowledgeCollection = void 0;
const common_1 = require("../../common");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class representing a collection of knowledge records.
 * Manages a set of knowledge entries with their embeddings for retrieval.
 */
class KnowledgeCollection {
    /**
     * Creates a new KnowledgeCollection instance.
     *
     * @param factory - External reference to the factory that created this collection
     * @param embedder - Text embedder for generating embeddings
     * @param texts - Initial knowledge text entries
     * @internal
     */
    constructor(factory, embedder, texts) {
        let vector = null;
        try {
            vector = new common_1.VectorString(texts);
            this.factory = factory;
            this.external =
                expose_binary_1.KnowledgeCollectionFactoryFunctions.createKnowledgeCollection(this.factory, embedder.getExternal(), vector.getExternal());
        }
        finally {
            vector === null || vector === void 0 ? void 0 : vector.destroy();
        }
    }
    /**
     * Sets or updates the knowledge records in this collection.
     * Creates embeddings for each knowledge record.
     *
     * @param embedder - Text embedder to use for generating embeddings
     * @param knowledge - Array of knowledge text entries
     */
    async setKnowledgeRecords(embedder, knowledge) {
        let records;
        try {
            records = expose_binary_1.VectorKnowledgeRecordFunctions.new();
            for (const k of knowledge) {
                let record;
                let metadata;
                let embedding;
                try {
                    record = expose_binary_1.KnowledgeRecordFunctions.new();
                    metadata = new common_1.VectorString();
                    embedding = new common_1.VectorFloat(await embedder.embed(k));
                    expose_binary_1.KnowledgeRecordFunctions.setText(record, k);
                    expose_binary_1.KnowledgeRecordFunctions.setEmbedding(record, embedding.getExternal());
                    expose_binary_1.KnowledgeRecordFunctions.setMetadata(record, metadata.getExternal());
                    expose_binary_1.VectorKnowledgeRecordFunctions.pushBack(records, record);
                }
                finally {
                    if (record) {
                        expose_binary_1.KnowledgeRecordFunctions.delete(record);
                    }
                    if (metadata) {
                        metadata.destroy();
                    }
                    if (embedding) {
                        embedding.destroy();
                    }
                }
            }
            expose_binary_1.KnowledgeCollectionFunctions.setKnowledgeRecords(this.external, records);
        }
        finally {
            if (records) {
                expose_binary_1.VectorKnowledgeRecordFunctions.delete(records);
            }
        }
    }
    /**
     * Returns the external reference to the native collection implementation.
     *
     * @returns External reference object
     * @internal
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this knowledge collection.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.KnowledgeCollectionFunctions.delete(this.external);
            this.external = null;
        }
        if (this.factory) {
            expose_binary_1.KnowledgeCollectionFactoryFunctions.delete(this.factory);
            this.factory = null;
        }
    }
}
exports.KnowledgeCollection = KnowledgeCollection;
