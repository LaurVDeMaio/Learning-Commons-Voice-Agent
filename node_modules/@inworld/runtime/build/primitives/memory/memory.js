"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Memory = void 0;
const common_1 = require("../../common");
const expose_binary_1 = require("../../expose_binary");
const retrieval_config_1 = require("../knowledge/retrieval_config");
const memory_snapshot_1 = require("./memory_snapshot");
/**
 * Class for managing conversational memory in agents.
 * Provides functionality to retrieve and update memory based on conversation history.
 */
class Memory {
    /**
     * Creates a new Memory instance.
     *
     * @param memory - External reference to the native memory implementation
     * @param factory - External reference to the factory that created this memory
     * @internal
     */
    constructor(memory, factory) {
        this.memory = memory;
        this.factory = factory;
    }
    /**
     * Retrieves memory content based on conversation history.
     *
     * @param history - Conversation history to retrieve memory from
     * @param memorySnapshot - Current memory snapshot
     * @param retrievalConfig - Configuration for memory retrieval
     * @param returnRollingSummary - Whether to include rolling summary in the result
     * @returns Promise resolving to array of memory strings
     */
    async get(history, memorySnapshot, retrievalConfig, returnRollingSummary) {
        let status;
        let result;
        let config;
        try {
            // Check if memory interface is valid
            if (!this.memory || !expose_binary_1.MemoryInterfaceFunctions.isValid(this.memory)) {
                throw new Error('Memory interface is not valid');
            }
            if (retrievalConfig) {
                config = new retrieval_config_1.RetrievalConfig(retrievalConfig);
            }
            else {
                config = new retrieval_config_1.RetrievalConfig({});
            }
            if (returnRollingSummary !== undefined) {
                status = await expose_binary_1.MemoryInterfaceFunctions.getMemoryWithRollingSummary(this.memory, history.getExternal(), memorySnapshot.getExternal(), config.getExternal(), returnRollingSummary);
            }
            else {
                status = await expose_binary_1.MemoryInterfaceFunctions.getMemory(this.memory, history.getExternal(), memorySnapshot.getExternal(), config.getExternal());
            }
            if (!expose_binary_1.KnowledgeVectorStatusFunctions.isOK(status)) {
                const errorStatus = expose_binary_1.KnowledgeVectorStatusFunctions.getStatus(status);
                const errorMessage = expose_binary_1.StatusFunctions.toString(errorStatus);
                throw new Error(`Failed to get memory: ${errorMessage}`);
            }
            const value = expose_binary_1.KnowledgeVectorStatusFunctions.getValue(status);
            result = common_1.VectorString.toArray(value);
        }
        finally {
            config === null || config === void 0 ? void 0 : config.destroy();
            expose_binary_1.KnowledgeVectorStatusFunctions.delete(status);
        }
        return result;
    }
    /**
     * Updates memory content based on conversation history.
     *
     * @param history - Conversation history to update memory with
     * @param memorySnapshot - Current memory snapshot to update
     * @returns Promise resolving to new memory snapshot
     */
    async update(history, memorySnapshot) {
        let status;
        let newMemorySnapshot;
        try {
            // Check if memory interface is valid
            if (!this.memory || !expose_binary_1.MemoryInterfaceFunctions.isValid(this.memory)) {
                throw new Error('Memory interface is not valid');
            }
            status = await expose_binary_1.MemoryInterfaceFunctions.updateMemory(this.memory, history.getExternal(), memorySnapshot.getExternal());
            if (!expose_binary_1.StatusOrMemorySnapshotFunctions.isOK(status)) {
                const errorStatus = expose_binary_1.StatusOrMemorySnapshotFunctions.getStatus(status);
                const errorMessage = expose_binary_1.StatusFunctions.toString(errorStatus);
                throw new Error(`Failed to update memory: ${errorMessage}`);
            }
            const value = expose_binary_1.StatusOrMemorySnapshotFunctions.getValue(status);
            newMemorySnapshot = new memory_snapshot_1.MemorySnapshot({ external: value });
        }
        finally {
            expose_binary_1.StatusOrMemorySnapshotFunctions.delete(status);
        }
        return newMemorySnapshot;
    }
    /**
     * Cleans up resources associated with this memory instance.
     */
    destroy() {
        if (this.memory) {
            expose_binary_1.MemoryInterfaceFunctions.delete(this.memory);
            this.memory = null;
        }
        if (this.factory) {
            expose_binary_1.MemoryFactoryFunctions.delete(this.factory);
            this.factory = null;
        }
    }
}
exports.Memory = Memory;
