"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextEmbedderConfigUtils = exports.TextEmbedderCreationConfig = exports.LocalTextEmbedderConfig = exports.RemoteTextEmbedderConfig = void 0;
const common_1 = require("../../common");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for configuring remote text embedder settings.
 * Manages parameters for cloud-based embedding services.
 * @internal
 */
class RemoteTextEmbedderConfig {
    /**
     * Creates a new RemoteTextEmbedderConfig instance.
     *
     * @param config - Configuration parameters for remote text embedder
     */
    constructor(config) {
        var _a;
        this.external = expose_binary_1.RemoteTextEmbedderConfigFunctions.new();
        if (config.apiKey) {
            expose_binary_1.RemoteTextEmbedderConfigFunctions.setAPIKey(this.external, config.apiKey);
        }
        if (config.modelName) {
            expose_binary_1.RemoteTextEmbedderConfigFunctions.setModelName(this.external, config.modelName);
        }
        expose_binary_1.RemoteTextEmbedderConfigFunctions.setProvider(this.external, (_a = config.provider) !== null && _a !== void 0 ? _a : common_1.DEFAULT_PROVIDER);
    }
    /**
     * Returns the external reference to the native config implementation.
     *
     * @returns External reference object
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this configuration.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.RemoteTextEmbedderConfigFunctions.delete(this.external);
            this.external = null;
        }
    }
    /**
     * Converts the configuration to JSON format.
     *
     * @returns JSON representation of the configuration
     */
    toJSON() {
        return {
            provider: this.external ? 'inworld' : '', // Would need getter methods to get actual values
            model_name: '',
            api_key: '',
        };
    }
}
exports.RemoteTextEmbedderConfig = RemoteTextEmbedderConfig;
/**
 * Class for configuring local text embedder settings.
 * Manages parameters for locally running embedding models.
 * @internal
 */
class LocalTextEmbedderConfig {
    /**
     * Creates a new LocalTextEmbedderConfig instance.
     *
     * @param config - Configuration parameters for local text embedder
     */
    constructor(config) {
        this.external = expose_binary_1.LocalTextEmbedderConfigFunctions.new();
        if (config.modelPath) {
            expose_binary_1.LocalTextEmbedderConfigFunctions.setModelPath(this.external, config.modelPath);
        }
        if (config.device) {
            expose_binary_1.LocalTextEmbedderConfigFunctions.setDevice(this.external, config.device.getExternal());
        }
    }
    /**
     * Returns the external reference to the native config implementation.
     *
     * @returns External reference object
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this configuration.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.LocalTextEmbedderConfigFunctions.delete(this.external);
            this.external = null;
        }
    }
    /**
     * Converts the configuration to JSON format.
     *
     * @returns JSON representation of the configuration
     */
    toJSON() {
        return {
            model_path: '', // Would need getter methods to get actual values
            device: null,
        };
    }
}
exports.LocalTextEmbedderConfig = LocalTextEmbedderConfig;
/**
 * Class for configuring text embedder creation settings.
 * Manages the variant type that can hold either local or remote config.
 * @internal
 */
class TextEmbedderCreationConfig {
    /**
     * Creates a new TextEmbedderCreationConfig instance.
     *
     * @param config - Configuration parameters for text embedder creation
     */
    constructor(config) {
        this.external = expose_binary_1.TextEmbedderCreationConfigFunctions.new();
        if (config instanceof LocalTextEmbedderConfig) {
            // Direct config object
            expose_binary_1.TextEmbedderCreationConfigFunctions.setLocalConfig(this.external, config.getExternal());
        }
        else if (config instanceof RemoteTextEmbedderConfig) {
            // Direct config object
            expose_binary_1.TextEmbedderCreationConfigFunctions.setRemoteConfig(this.external, config.getExternal());
        }
        else {
            // Interface config - create new config objects
            if (config.type === 'local') {
                const localConfig = new LocalTextEmbedderConfig(config.config);
                expose_binary_1.TextEmbedderCreationConfigFunctions.setLocalConfig(this.external, localConfig.getExternal());
                localConfig.destroy();
            }
            else if (config.type === 'remote') {
                const remoteConfig = new RemoteTextEmbedderConfig(config.config);
                expose_binary_1.TextEmbedderCreationConfigFunctions.setRemoteConfig(this.external, remoteConfig.getExternal());
                remoteConfig.destroy();
            }
        }
    }
    /**
     * Returns the external reference to the native config implementation.
     *
     * @returns External reference object
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this configuration.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.TextEmbedderCreationConfigFunctions.delete(this.external);
            this.external = null;
        }
    }
    /**
     * Checks if the configuration has a local config.
     *
     * @returns True if local config is set
     */
    hasLocalConfig() {
        return this.external
            ? expose_binary_1.TextEmbedderCreationConfigFunctions.hasLocalConfig(this.external)
            : false;
    }
    /**
     * Checks if the configuration has a remote config.
     *
     * @returns True if remote config is set
     */
    hasRemoteConfig() {
        return this.external
            ? expose_binary_1.TextEmbedderCreationConfigFunctions.hasRemoteConfig(this.external)
            : false;
    }
}
exports.TextEmbedderCreationConfig = TextEmbedderCreationConfig;
/**
 * Utility functions for configuration validation and conversion.
 */
class TextEmbedderConfigUtils {
    /**
     * Validates a text embedder configuration.
     * Ensures all required fields are present.
     *
     * @param config - Configuration to validate
     * @throws Error if configuration is invalid
     */
    static validateConfig(config) {
        if (!config.type || !['local', 'remote'].includes(config.type)) {
            throw new Error('Invalid embedder type. Must be "local" or "remote"');
        }
        if (!config.config) {
            throw new Error('Configuration is required');
        }
        if (config.type === 'local') {
            const localConfig = config.config;
            if (!localConfig.modelPath) {
                throw new Error('Model path is required for local embedder');
            }
        }
        else if (config.type === 'remote') {
            const remoteConfig = config.config;
            if (!remoteConfig.apiKey) {
                throw new Error('API key is required for remote embedder');
            }
            if (!remoteConfig.modelName) {
                throw new Error('Model name is required for remote embedder');
            }
        }
    }
    /**
     * Converts a configuration to JSON format.
     *
     * @param config - Configuration to convert
     * @returns JSON representation
     */
    static toJSON(config) {
        this.validateConfig(config);
        const json = {
            type: config.type,
        };
        if (config.type === 'local') {
            const localConfig = config.config;
            json.config = {
                model_path: localConfig.modelPath,
                device: localConfig.device
                    ? {
                        type: localConfig.device.getType(),
                        index: localConfig.device.getIndex(),
                        info: localConfig.device.getInfo(),
                    }
                    : null,
            };
        }
        else if (config.type === 'remote') {
            const remoteConfig = config.config;
            json.config = {
                provider: remoteConfig.provider || common_1.DEFAULT_PROVIDER,
                model_name: remoteConfig.modelName,
                api_key: remoteConfig.apiKey,
            };
        }
        return json;
    }
    /**
     * Creates a configuration from JSON format.
     *
     * @param json - JSON representation of configuration
     * @returns Configuration object
     * @throws Error if JSON is invalid
     */
    static fromJSON(json) {
        try {
            const type = json.type;
            if (!type || !['local', 'remote'].includes(type)) {
                throw new Error('Invalid configuration type');
            }
            if (type === 'local') {
                const config = json.config;
                if (!config || !config.model_path) {
                    throw new Error('Local configuration requires model_path');
                }
                return {
                    type: 'local',
                    config: {
                        modelPath: config.model_path,
                        device: config.device
                            ? this.createDeviceFromJSON(config.device)
                            : undefined,
                    },
                };
            }
            else if (type === 'remote') {
                const config = json.config;
                if (!config || !config.model_name || !config.api_key) {
                    throw new Error('Remote configuration requires model_name and api_key');
                }
                return {
                    type: 'remote',
                    config: {
                        provider: config.provider || common_1.DEFAULT_PROVIDER,
                        modelName: config.model_name,
                        apiKey: config.api_key,
                    },
                };
            }
            throw new Error('Unknown configuration type');
        }
        catch (error) {
            throw new Error(`Failed to parse configuration from JSON: ${error.message}`);
        }
    }
    /**
     * Creates a Device instance from JSON representation.
     * This is a simplified implementation - in practice, you'd need to
     * create the device through the DeviceRegistry.
     *
     * @param deviceJson - JSON representation of device
     * @returns Device instance
     * @private
     */
    static createDeviceFromJSON(_) {
        throw new Error('Not implemented');
    }
}
exports.TextEmbedderConfigUtils = TextEmbedderConfigUtils;
