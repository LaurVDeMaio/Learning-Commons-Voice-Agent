"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextEmbedder = void 0;
const common_1 = require("../../common");
const helpers_1 = require("../../common/helpers");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for text embedding functionality.
 * Converts text into vector representations (embeddings) for semantic processing.
 */
class TextEmbedder {
    /**
     * @internal
     * Creates a new TextEmbedder instance.
     *
     * @param {ExternalReference} embedder - External reference to the native embedder implementation
     * @param {ExternalReference} factory - External reference to the factory that created this embedder
     */
    constructor(embedder, factory) {
        this.embedder = embedder;
        this.factory = factory;
    }
    /**
     * Creates an embedding vector for a single text string.
     *
     * @param {string} text - Text to convert to embedding
     * @returns {Promise<number[]>} Promise resolving to array of numbers representing the embedding vector
     * @throws InworldError if embedding generation fails
     */
    async embed(text) {
        let statusOrEmbedding;
        const embedding = [];
        try {
            statusOrEmbedding = await expose_binary_1.TextEmbedderInterfaceFunctions.embed(this.embedder, text);
            if (!expose_binary_1.EmbeddingsStatusFunctions.isOK(statusOrEmbedding)) {
                throw new common_1.InworldError(`Failed to generate embedding for text: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`, (0, helpers_1.getStatus)(statusOrEmbedding));
            }
            const embeddingRef = expose_binary_1.EmbeddingsStatusFunctions.getValue(statusOrEmbedding);
            embedding.push(...common_1.VectorFloat.toArray(embeddingRef));
        }
        finally {
            if (statusOrEmbedding) {
                expose_binary_1.EmbeddingsStatusFunctions.delete(statusOrEmbedding);
            }
        }
        return embedding;
    }
    /**
     * Creates embedding vectors for multiple text strings in a batch.
     *
     * @param {string[]} texts - Array of text strings to convert to embeddings
     * @returns {Promise<number[][]>} Promise resolving to array of embedding vectors
     * @throws InworldError if batch embedding generation fails
     */
    async embedBatch(texts) {
        let statusOrEmbeddings;
        let embeddingsRef;
        let vector;
        const embeddings = [];
        try {
            vector = new common_1.VectorString(texts);
            statusOrEmbeddings = await expose_binary_1.TextEmbedderInterfaceFunctions.embedBatch(this.embedder, vector.getExternal());
            if (!expose_binary_1.BatchEmbeddingsStatusFunctions.isOK(statusOrEmbeddings)) {
                throw new common_1.InworldError(`Failed to generate batch embeddings for ${texts.length} texts`, (0, helpers_1.getStatus)(statusOrEmbeddings));
            }
            embeddingsRef =
                expose_binary_1.BatchEmbeddingsStatusFunctions.getValue(statusOrEmbeddings);
            const count = expose_binary_1.VectorVectorFloatFunctions.size(embeddingsRef);
            for (let i = 0; i < count; i++) {
                const embeddingItemRef = expose_binary_1.VectorVectorFloatFunctions.get(embeddingsRef, i);
                embeddings.push(common_1.VectorFloat.toArray(embeddingItemRef));
            }
        }
        finally {
            vector === null || vector === void 0 ? void 0 : vector.destroy();
            if (embeddingsRef) {
                expose_binary_1.VectorVectorFloatFunctions.delete(embeddingsRef);
            }
            if (statusOrEmbeddings) {
                expose_binary_1.BatchEmbeddingsStatusFunctions.delete(statusOrEmbeddings);
            }
        }
        return embeddings;
    }
    /**
     * Returns the external reference to the native embedder implementation.
     *
     * @returns External reference object
     * @internal
     */
    getExternal() {
        return this.embedder;
    }
    /**
     * Cleans up resources associated with this text embedder.
     * Should be called when the embedder is no longer needed.
     */
    destroy() {
        if (this.embedder) {
            expose_binary_1.TextEmbedderInterfaceFunctions.delete(this.embedder);
            this.embedder = null;
        }
        if (this.factory) {
            expose_binary_1.TextEmbedderFactoryFunctions.delete(this.factory);
            this.factory = null;
        }
    }
}
exports.TextEmbedder = TextEmbedder;
