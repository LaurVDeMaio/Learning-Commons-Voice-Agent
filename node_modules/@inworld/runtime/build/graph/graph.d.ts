import { UserContext } from '../common/data_types';
import { GraphOutputStream } from './GraphOutputStream';
export type DeclarativeGraphOptions = {
    jsonConfig: string;
    enableRemoteConfig?: boolean;
    apiKey?: string;
    substitutions?: Record<string, string>;
    id?: never;
};
export type GraphOptions = DeclarativeGraphOptions;
/**
 * Represents a graph that can be executed.
 */
export declare class Graph {
    private options;
    private jsonConfig;
    private compiled;
    private external;
    private executor;
    private parser;
    private graphManagerConfig;
    private graphId;
    private getGraphExecutionManager;
    /**
     * Creates a new Graph instance.
     *
     * @param options
     */
    constructor(options: GraphOptions);
    /**
     * Validates that the compiled graph is ready for execution.
     *
     * @private
     */
    private validateCompiledGraph;
    /**
     * Executes the compiled graph with user context.
     *
     * @param input - Input data to execute the graph
     * @param executionId - Unique identifier for this execution
     * @param userContext - User context for this execution
     * @returns Promise resolving to the execution output stream
     */
    start(input: any, executionId?: string): GraphOutputStream;
    start(input: any, userContext?: UserContext): GraphOutputStream;
    /**
     * Visualizes the compiled graph and saves the visualization to a file.
     *
     * @param path - File path where the visualization will be saved
     */
    visualize(path: string): Promise<void>;
    /**
     * Closes a specific execution.
     *
     * @param outputStream - Output stream of the execution to close
     */
    closeExecution(outputStream: GraphOutputStream | number): void;
    /**
     * Returns the JSON configuration of the graph.
     *
     * @returns The JSON configuration of the graph
     */
    toJSON(): string;
    /**
     * Cleans up all active executions.
     */
    cleanupAllExecutions(): void;
    /**
     * Stops the graph executor.
     */
    stopExecutor(): void;
    /**
     * Gets the unique identifier for this graph.
     *
     * @returns The graph's unique ID
     */
    getGraphId(): string;
    /**
     * Cleans up resources associated with this graph.
     */
    destroy(): void;
    private initializeExecutor;
    private compile;
}
