"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomNode = void 0;
const nodes_1 = require("../../nodes");
const abstract_node_1 = require("./abstract_node");
/**
 * Base class for creating custom (user-defined) nodes.
 *
 * Subclasses must implement the `process` method. A unique node type is
 * automatically registered once per subclass.
 *
 * @example
 * ```typescript
 * import { CustomNode, ProcessContext } from '@inworld/runtime/graph';
 *
 * // Define a custom node that processes the input text
 * class CustomTextNode extends CustomNode {
 *   async process(
 *     context: ProcessContext,
 *     input: string,
 *   ): Promise<{ processedText: string }> {
 *     return {
 *       processedText: input.toUpperCase(),
 *     };
 *   }
 * }
 *
 * // Create an instance of the custom node
 * const customTextNode = new CustomTextNode();
 * ```
 */
class CustomNode extends abstract_node_1.AbstractNode {
    /**
     * Creates a new `CustomNode`.
     *
     * @remarks
     * Subclasses can pass an `executionConfig` object to surface additional
     * execution-time properties. Execution config would be available to the
     * process function in the {@link ProcessContext}.
     *
     * @typeParam InputType - The type of the inputs to the node, should be one of {@link CustomNodeInputTypes} or any for custom processing.
     * @typeParam OutputType - The type of the outputs from the node, should be one of {@link CustomNodeOutputTypes} or any for custom processing.
     *
     * @param props - Custom node options including optional `executionConfig`.
     */
    constructor(props = {}) {
        var _a;
        super(props);
        this.executionConfig = (_a = props === null || props === void 0 ? void 0 : props.executionConfig) !== null && _a !== void 0 ? _a : {};
        if (!CustomNode.typeReferences[this.constructor.name]) {
            CustomNode.typeReferences[this.constructor.name] = (0, nodes_1.registerCustomNodeType)(this.constructor.name + 'Type', this.process);
        }
    }
    /**
     * Converts this custom node to a graph configuration node, including the
     * registered type and the provided execution configuration.
     */
    toGraphConfigNode() {
        return {
            type: this.constructor.name + 'Type',
            id: this.id,
            execution_config: {
                type: 'NodeExecutionConfig',
                properties: Object.assign({ report_to_client: this.reportToClient }, this.executionConfig),
            },
        };
    }
}
exports.CustomNode = CustomNode;
CustomNode.typeReferences = {};
