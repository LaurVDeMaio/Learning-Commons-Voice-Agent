"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KnowledgeNode = void 0;
const remote_knowledge_component_1 = require("../components/remote_knowledge_component");
const constants_1 = require("../constants");
const snakify_1 = __importDefault(require("../utils/snakify"));
const abstract_node_1 = require("./abstract_node");
/**
 * Knowledge retrieval node for accessing stored information.
 * You can either use a pre-configured knowledge component that could be reused across multiple nodes
 * or node will create a new component for you.
 *
 * @input {String} {@link String} - The data type that KnowledgeNode accepts as input
 * @output {GraphTypes.KnowledgeRecords} {@link GraphTypes.KnowledgeRecords} - The data type that KnowledgeNode outputs
 *
 * @example
 * ```typescript
 * // Using knowledge provider configuration
 * const knowledgeNode = new KnowledgeNode({
 *   id: 'my-knowledge-node',
 *   knowledgeId: 'company-docs',
 *   knowledgeRecords: ['policy-1', 'policy-2', 'faq-1'],
 *   retrievalConfig: {
 *     threshold: 0.8,
 *     topK: 3
 *   }
 * });
 *
 * // Using existing knowledge component
 * const knowledgeComponent = new RemoteKnowledgeComponent({ id: 'existing-knowledge-component' });
 * const knowledgeNodeWithComponent = new KnowledgeNode({
 *   id: 'my-knowledge-node',
 *   knowledgeId: 'company-docs',
 *   knowledgeRecords: ['policy-1', 'policy-2', 'faq-1'],
 *   knowledgeComponent
 * });
 * ```
 */
class KnowledgeNode extends abstract_node_1.AbstractNode {
    /**
     * Creates a new KnowledgeNode instance.
     *
     * @remarks
     * Provide knowledge provider settings to create a new internal component, or
     * pass `knowledgeComponent` to reuse an existing one.
     *
     * @param props - Configuration for the knowledge node.
     */
    constructor(props) {
        super(props);
        this.knowledgeId = props.knowledgeId;
        this.knowledgeRecords = props.knowledgeRecords;
        this.retrievalConfig = Object.assign(Object.assign({}, constants_1.DEFAULT_RETRIEVAL_CONFIG), props.retrievalConfig);
        let knowledgeComponent;
        if ('knowledgeComponent' in props) {
            knowledgeComponent = props.knowledgeComponent;
        }
        else {
            knowledgeComponent = new remote_knowledge_component_1.RemoteKnowledgeComponent({
                id: `${this.id}_knowledge_component`,
                maxCharsPerChunk: props.maxCharsPerChunk,
                maxChunksPerDocument: props.maxChunksPerDocument,
            });
        }
        this.addComponent(knowledgeComponent);
    }
    /**
     * Converts the knowledge node to a graph configuration node.
     *
     * @returns The configured knowledge node for graph execution
     */
    toGraphConfigNode() {
        return {
            id: this.id,
            type: 'KnowledgeNode',
            creation_config: {
                type: 'KnowledgeNodeCreationConfig',
                properties: {
                    knowledge_id: this.knowledgeId,
                    knowledge_records: this.knowledgeRecords,
                    knowledge_component_id: this.getFirstComponent().id,
                },
            },
            execution_config: {
                type: 'KnowledgeNodeExecutionConfig',
                properties: {
                    knowledge_ids: [this.knowledgeId],
                    retrieval_config: (0, snakify_1.default)(this.retrievalConfig),
                },
            },
        };
    }
}
exports.KnowledgeNode = KnowledgeNode;
