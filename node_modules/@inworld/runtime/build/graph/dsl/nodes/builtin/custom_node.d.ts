import { CustomNodeInputTypes, CustomNodeOutputTypes } from '../../../../common/data_types/type_mapping';
import { ProcessContext } from '../../../nodes';
import { CustomNodeTypeReference } from '../../../nodes/types';
import { Node as GraphConfigNode } from '../../graph_config_schema';
import { AbstractNode, AbstractNodeProps } from './abstract_node';
/**
 * Configuration for a `CustomNode`.
 */
interface CustomNodeProps extends AbstractNodeProps {
    executionConfig?: {
        [key: string]: string | number | boolean;
    };
}
/**
 * Base class for creating custom (user-defined) nodes.
 *
 * Subclasses must implement the `process` method. A unique node type is
 * automatically registered once per subclass, and used when producing the
 * graph configuration via `toGraphConfigNode`.
 */
export declare abstract class CustomNode extends AbstractNode {
    private executionConfig;
    protected static typeReferences: {
        [key: string]: CustomNodeTypeReference;
    };
    /**
     * Creates a new `CustomNode`.
     *
     * @param props - Custom node options including optional execution configuration.
     */
    constructor(props?: CustomNodeProps);
    /**
     * The execution function of the custom node. Must be implemented by subclasses.
     */
    abstract process(context: ProcessContext, ...inputs: CustomNodeInputTypes[]): CustomNodeOutputTypes | Promise<CustomNodeOutputTypes>;
    /**
     * Converts this custom node to a graph configuration node, including the
     * registered type and the provided execution configuration.
     */
    protected toGraphConfigNode(): GraphConfigNode;
}
export {};
