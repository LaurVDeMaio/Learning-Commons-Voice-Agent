"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphBuilder = exports.SubgraphBuilder = void 0;
const common_1 = require("../../common");
const init_1 = require("../../init");
const graph_1 = require("../graph");
const nodes_1 = require("../nodes");
const intent_subgraph_1 = require("./builtin/intent_subgraph");
const abstract_component_1 = require("./components/abstract_component");
const remote_embedder_component_1 = require("./components/remote_embedder_component");
const remote_llm_component_1 = require("./components/remote_llm_component");
const constants_1 = require("./constants");
const abstract_node_1 = require("./nodes/builtin/abstract_node");
const snakify_1 = __importDefault(require("./utils/snakify"));
const API_KEY_SUBSTITUTION_KEY = '{{INWORLD_API_KEY}}';
/**
 * Builder class for creating subgraphs with a fluent API.
 * Subgraphs are reusable graph components that can be referenced by other graphs.
 *
 * @example
 * ```typescript
 * const subgraph = new SubgraphBuilder('my_subgraph')
 *   .addParameter({ name: 'user_input', type: 'string' })
 *   .addNode(intentNode)
 *   .addNode(llmNode)
 *   .addEdge(intentNode, llmNode)
 *   .setStartNode(intentNode)
 *   .setEndNode(llmNode)
 *   .build();
 * ```
 */
class SubgraphBuilder {
    /**
     * Creates a new subgraph builder with the specified ID.
     *
     * @constructor
     * @param {string} id - Unique identifier for the subgraph
     */
    constructor(id) {
        this[_a] = [];
        this.nodes = [];
        this.edges = [];
        this.subgraph = {
            id,
        };
    }
    /**
     * Adds a parameter to the subgraph that can be passed from the parent graph.
     *
     * @param {Object} config - Parameter configuration
     * @param {string} config.name - Parameter name
     * @param {string} config.type - Parameter type ('string', 'number', 'integer', 'boolean')
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addParameter(config) {
        if (!this.subgraph.parameters) {
            this.subgraph.parameters = [];
        }
        this.subgraph.parameters.push(config);
        return this;
    }
    addComponent(component) {
        this[abstract_node_1.INTERNAL_COMPONENTS].push(component);
        return this;
    }
    /**
     * Adds multiple parameters to the subgraph at once.
     *
     * @param {Array<Object>} parameters - Array of parameter configurations
     * @param {string} parameters[].name - Parameter name
     * @param {string} parameters[].type - Parameter type ('string', 'number', 'integer', 'boolean')
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addParameters(parameters) {
        parameters.forEach((param) => this.addParameter(param));
        return this;
    }
    /**
     * Adds a node to the subgraph.
     *
     * @param {AbstractNode} node - Node to add to the subgraph
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addNode(node) {
        if (node instanceof abstract_node_1.AbstractNode) {
            return this.addClassNode(node);
        }
        this.nodes.push(node);
        return this;
    }
    addClassNode(node) {
        const graphConfigNode = node[abstract_node_1.TO_GRAPH_CONFIG_NODE]();
        const components = node[abstract_node_1.INTERNAL_COMPONENTS];
        components.forEach((component) => {
            const graphConfigComponent = component[abstract_component_1.TO_GRAPH_CONFIG_COMPONENT]();
            this.addComponent(graphConfigComponent);
        });
        this.nodes.push(graphConfigNode);
        return this;
    }
    /**
     * Adds an edge connecting two nodes in the subgraph.
     *
     * @param {AbstractNode} fromNode - Source node or node ID
     * @param {AbstractNode} toNode - Destination node or node ID
     * @param {Object} [options] - Optional edge configuration
     * @param {string} [options.conditionExpression] - CEL expression for conditional execution
     * @param {CustomEdgeConditionReference} [options.conditionRef] - Reference to a custom edge condition
     * @param {boolean} [options.optional] - Whether the edge is optional
     * @param {boolean} [options.loop] - Whether the edge creates a loop
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addEdge(fromNode, toNode, options) {
        const fromId = typeof fromNode === 'string' ? fromNode : fromNode.id;
        const toId = typeof toNode === 'string' ? toNode : toNode.id;
        const edge = {
            from_node: fromId,
            to_node: toId,
        };
        if (options === null || options === void 0 ? void 0 : options.conditionExpression) {
            edge.condition_expression = options.conditionExpression;
        }
        else if (options === null || options === void 0 ? void 0 : options.conditionRef) {
            edge.condition_id = options.conditionRef.id;
        }
        if ((options === null || options === void 0 ? void 0 : options.optional) !== undefined) {
            edge.optional = options.optional;
        }
        if ((options === null || options === void 0 ? void 0 : options.loop) !== undefined) {
            edge.loop = options.loop;
        }
        this.edges.push(edge);
        return this;
    }
    /**
     * Sets the start node of the subgraph (subgraphs can only have one start node).
     *
     * @param {AbstractNode} node - Start node or node ID
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    setStartNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.startNode = nodeId;
        return this;
    }
    /**
     * Sets the end node of the subgraph (subgraphs can only have one end node).
     *
     * @param {AbstractNode} node - End node or node ID
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    setEndNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.endNode = nodeId;
        return this;
    }
    /**
     * Builds and returns the final subgraph configuration.
     *
     * @returns {Subgraph} The completed subgraph configuration
     * @throws {Error} If the subgraph has no nodes
     */
    build() {
        // Ensure we have at least one node
        if (this.nodes.length === 0) {
            throw new Error('Subgraph must have at least one node');
        }
        this.subgraph.nodes = this.nodes;
        this.subgraph.edges = this.edges.length > 0 ? this.edges : undefined;
        this.subgraph.start_nodes = this.startNode ? [this.startNode] : undefined;
        this.subgraph.end_nodes = this.endNode ? [this.endNode] : undefined;
        return this.subgraph;
    }
}
exports.SubgraphBuilder = SubgraphBuilder;
_a = abstract_node_1.INTERNAL_COMPONENTS;
/**
 * Main graph builder class for creating complete graph configurations.
 * Provides a fluent API for building graphs with nodes, edges, components, and subgraphs.
 *
 * @example
 * ```typescript
 * const graph = new Graph('my_graph')
 *   .addComponent(llmComponent)
 *   .addComponent(embedderComponent)
 *   .addNode(intentNode)
 *   .addNode(llmNode)
 *   .addEdge(intentNode, llmNode)
 *   .setStartNode(intentNode)
 *   .setEndNode(llmNode)
 *   .build();
 * ```
 */
class GraphBuilder {
    /**
     * Creates a new graph builder.
     * Accepts either an options object or a graph ID string.
     *
     * @constructor
     * @param {GraphBuilderProps | string} opts - Graph builder options or graph ID string
     */
    constructor(opts) {
        var _b, _c;
        this.nodes = [];
        this.startNodes = [];
        this.endNodes = [];
        this.enableRemoteConfig = false;
        this.edges = [];
        this.components = [];
        this.subgraphs = [];
        if (typeof opts === 'string') {
            opts = { id: opts };
        }
        this.apiKey = (_b = opts.apiKey) !== null && _b !== void 0 ? _b : process.env.INWORLD_API_KEY;
        this.enableRemoteConfig = (_c = opts.enableRemoteConfig) !== null && _c !== void 0 ? _c : false;
        (0, init_1.initializeInworldRuntime)({
            apiKey: this.apiKey,
            appName: opts.appName,
            appVersion: opts.appVersion,
        });
        this.config = {
            schema_version: '1.0.0',
            main: {
                id: opts.id,
                nodes: [],
                edges: [],
                end_nodes: [],
            },
        };
    }
    /**
     * Adds a subgraph to the graph configuration.
     *
     * @param {SubgraphBuilder} subgraph - Subgraph builder instance to be added
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addSubgraph(subgraph) {
        const finalSubgraph = subgraph.build();
        this.subgraphs.push(finalSubgraph);
        this.components.push(...subgraph[abstract_node_1.INTERNAL_COMPONENTS]);
        return this;
    }
    /**
     * Adds an intent subgraph to the graph.
     * @param {string} id - Unique identifier for the subgraph
     * @param {Object} parameters - Intent subgraph parameters
     * @param {Array} parameters.intents - Array of intent configurations
     * @param {string} parameters.promptTemplate - Template for LLM prompting
     * @param {RemoteLLMComponent|Object} [parameters.llmComponent] - LLM component instance or configuration
     * @param {RemoteEmbedderComponent|Object} [parameters.embedderComponent] - Embedder component instance or configuration
     * @param {number} [parameters.similarityThreshold] - Similarity threshold for matching
     * @param {TextGenerationConfig} [parameters.textGenerationConfig] - Text generation configuration
     * @param {number} [parameters.maxIntentsForLLM] - Maximum intents to send to LLM
     * @param {number} [parameters.maxPhrasesPerIntent] - Maximum phrases per intent
     * @param {number} [parameters.embeddingSimilarityThreshold] - Embedding similarity threshold
     * @param {number} [parameters.topNIntents] - Number of top intents to return
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addIntentSubgraph(id, parameters) {
        // Handle LLM component - either use provided instance or create new one
        let llmComponentId;
        if (parameters.llmComponent instanceof remote_llm_component_1.RemoteLLMComponent) {
            // Use existing component instance
            this.addComponent(parameters.llmComponent);
            llmComponentId = parameters.llmComponent.id;
        }
        else if (parameters.llmComponent) {
            // Create new component from configuration
            llmComponentId = `${id}_subgraph_llm_component`;
            const llmComponent = new remote_llm_component_1.RemoteLLMComponent(Object.assign({ id: llmComponentId }, parameters.llmComponent));
            this.addComponent(llmComponent);
        }
        else {
            // Use default configuration
            llmComponentId = `${id}_default_llm_component`;
            const llmComponent = new remote_llm_component_1.RemoteLLMComponent({
                id: llmComponentId,
            });
            this.addComponent(llmComponent);
        }
        // Handle Embedder component - either use provided instance or create new one
        let embedderComponentId;
        if (parameters.embedderComponent instanceof remote_embedder_component_1.RemoteEmbedderComponent) {
            // Use existing component instance
            this.addComponent(parameters.embedderComponent);
            embedderComponentId = parameters.embedderComponent.id;
        }
        else if (parameters.embedderComponent) {
            // Create new component from configuration
            embedderComponentId = `${id}_embedder_component`;
            const embedderComponent = new remote_embedder_component_1.RemoteEmbedderComponent(Object.assign({ id: embedderComponentId }, parameters.embedderComponent));
            this.addComponent(embedderComponent);
        }
        else {
            // Use default configuration
            embedderComponentId = `${id}_default_embedder_component`;
            const embedderComponent = new remote_embedder_component_1.RemoteEmbedderComponent({
                id: embedderComponentId,
            });
            this.addComponent(embedderComponent);
        }
        const subgraph = (0, intent_subgraph_1.intentSubgraph)(Object.assign(Object.assign(Object.assign({}, constants_1.DEFAULT_INTENT_SUBGRAPH_CONFIG), parameters), { textGenerationConfig: (0, snakify_1.default)(parameters.textGenerationConfig), embedderComponentId,
            llmComponentId }));
        subgraph.id = id;
        this.subgraphs.push(subgraph);
        return this;
    }
    /**
     * Adds a node to the graph.
     * If an {@link AbstractNode} is provided without corresponding component, internal components are automatically added.
     *
     * @param {AbstractNode} node - Node to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addNode(node) {
        if (node instanceof abstract_node_1.AbstractNode) {
            return this.addClassNode(node);
        }
        this.nodes.push(node);
        return this;
    }
    addClassNode(node) {
        const graphConfigNode = node[abstract_node_1.TO_GRAPH_CONFIG_NODE]();
        const components = node[abstract_node_1.INTERNAL_COMPONENTS];
        components.forEach((component) => {
            const graphConfigComponent = component[abstract_component_1.TO_GRAPH_CONFIG_COMPONENT]();
            this.addComponent(graphConfigComponent);
        });
        this.nodes.push(graphConfigNode);
        return this;
    }
    /**
     * Adds an edge connecting two nodes in the graph.
     *
     * @param {AbstractNode} fromNode - Source node
     * @param {AbstractNodeg} toNode - Destination node
     * @param {Object} [options] - Optional edge configuration
     * @param {string} [options.conditionExpression] - CEL expression for conditional execution
     * @param {CustomEdgeConditionReference|EdgeConditionCallback} [options.condition] - Reference to a registered custom condition or a callback to register one
     * @param {boolean} [options.optional] - Whether the edge is optional
     * @param {boolean} [options.loop] - Whether the edge creates a loop
     *
     * @returns {GraphBuilder} The builder instance for method chaining
     */
    addEdge(fromNode, toNode, options) {
        const fromId = typeof fromNode === 'string' ? fromNode : fromNode.id;
        const toId = typeof toNode === 'string' ? toNode : toNode.id;
        const edge = {
            from_node: fromId,
            to_node: toId,
        };
        if (options === null || options === void 0 ? void 0 : options.conditionExpression) {
            edge.condition_expression = options.conditionExpression;
        }
        else if (options === null || options === void 0 ? void 0 : options.condition) {
            if ('id' in options.condition) {
                edge.condition_id = options.condition.id;
            }
            else {
                const id = (0, nodes_1.registerCustomEdgeCondition)(`custom-condition-from-${fromId}-to-${toId}`, options.condition).id;
                this.addComponent({
                    id,
                    type: id,
                });
                edge.condition_id = id;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.optional) !== undefined) {
            edge.optional = options.optional;
        }
        if ((options === null || options === void 0 ? void 0 : options.loop) !== undefined) {
            edge.loop = options.loop;
        }
        this.edges.push(edge);
        return this;
    }
    /**
     * Adds a component to the graph configuration.
     *
     * @param {AbstractComponent} component - Component to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addComponent(component) {
        if (component instanceof abstract_component_1.AbstractComponent) {
            component = component[abstract_component_1.TO_GRAPH_CONFIG_COMPONENT]();
        }
        // MCPClientInterface does not require an API key
        if (component.type !== 'MCPClientInterface' &&
            !component.type.startsWith('custom-condition-')) {
            if (!this.apiKey) {
                throw new common_1.InworldError('API key is not set. Either pass it to the GraphBuilder options or set the INWORLD_API_KEY environment variable');
            }
            component.creation_config.properties['api_key'] =
                API_KEY_SUBSTITUTION_KEY;
        }
        this.components.push(component);
        return this;
    }
    /**
     * Sets the start node of the graph.
     *
     * @param {AbstractNode} node - Start node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.startNodes = [nodeId];
        return this;
    }
    /**
     * Sets the end node of the graph.
     *
     * @param {AbstractNode} node - End node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.endNodes = [nodeId];
        return this;
    }
    /**
     * Sets multiple start nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of start nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNodes(nodes) {
        this.startNodes = nodes.map((n) => (typeof n === 'string' ? n : n.id));
        return this;
    }
    /**
     * Sets multiple end nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of end nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNodes(nodes) {
        this.endNodes = nodes.map((n) => (typeof n === 'string' ? n : n.id));
        return this;
    }
    getSchema() {
        this.config.main.nodes = this.nodes;
        this.config.main.edges = this.edges;
        this.config.main.start_nodes =
            this.startNodes.length > 0
                ? this.startNodes
                : undefined;
        this.config.main.end_nodes = this.endNodes;
        if (this.components.length > 0) {
            this.config.components = this.components;
        }
        if (this.subgraphs.length > 0) {
            this.config.subgraphs = this.subgraphs;
        }
        return this.config;
    }
    /**
     * Converts the graph configuration to a JSON string.
     *
     * @returns {string} JSON string representation of the graph configuration
     */
    toJSON() {
        return JSON.stringify(this.getSchema(), null, 2);
    }
    /**
     * Creates a graph executor instance for running the graph.
     *
     * @returns {Graph} GraphExecutor instance configured with this graph
     */
    build() {
        return new graph_1.Graph({
            jsonConfig: this.toJSON(),
            enableRemoteConfig: this.enableRemoteConfig,
            apiKey: this.apiKey,
            substitutions: {},
        });
    }
}
exports.GraphBuilder = GraphBuilder;
