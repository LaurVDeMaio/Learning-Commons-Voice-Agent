"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextChunkingNodeExecutionConfig = exports.TextAggregatorNodeExecutionConfig = exports.LLMChatNodeExecutionConfig = exports.IntentNodeExecutionConfig = exports.TTSNodeExecutionConfig = exports.STTNodeExecutionConfig = exports.ExecutionConfig = exports.NodeExecutionConfig = void 0;
const common_1 = require("../../common");
const expose_binary_1 = require("../../expose_binary");
const intent_1 = require("../../primitives/intent");
const llm_1 = require("../../primitives/llm");
const stt_1 = require("../../primitives/stt");
const tts_1 = require("../../primitives/tts");
/**
 * TODO: implement it with ConfigWrapperClass
 */
class NodeExecutionConfig {
    constructor(props) {
        var _a;
        this.reportToClient = (_a = props === null || props === void 0 ? void 0 : props.reportToClient) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * @internal
     */
    getExternal() {
        throw new Error('Not implemented');
    }
    /**
     * @internal
     */
    destroy() {
        throw new Error('Not implemented');
    }
}
exports.NodeExecutionConfig = NodeExecutionConfig;
/**
 * Represents the execution config.
 * @internal
 */
class ExecutionConfig {
    constructor(external, props) {
        var _a;
        this.external = external;
        if (props) {
            this.reportToClient = (_a = props === null || props === void 0 ? void 0 : props.reportToClient) !== null && _a !== void 0 ? _a : false;
        }
        else {
            this.reportToClient =
                expose_binary_1.ExecutionConfigFunctions.getReportToClientForNodeExecutionConfig(this.external);
        }
    }
    /**
     * Gets the external reference.
     *
     * @returns The external reference.
     */
    getExternal() {
        return this.external;
    }
    /**
     * Destroys the execution config.
     */
    destroy() {
        this.external = null;
    }
}
exports.ExecutionConfig = ExecutionConfig;
/**
 * Represents the STT node execution config.
 * @internal
 */
class STTNodeExecutionConfig extends ExecutionConfig {
    /**
     * Constructs a new STT node execution config.
     *
     * @param props - The properties.
     */
    constructor(props) {
        super(expose_binary_1.ExecutionConfigFunctions.newSTTNodeExecutionConfig(), props);
        try {
            this.speechRecognitionConfig = new stt_1.SpeechRecognitionConfig(props === null || props === void 0 ? void 0 : props.speechRecognitionConfig);
            this.stt_component_id = props.stt_component_id;
            expose_binary_1.ExecutionConfigFunctions.setSTTComponentIdForSTTNodeExecutionConfig(this.external, props.stt_component_id);
            expose_binary_1.ExecutionConfigFunctions.setReportToClientForSTTNodeExecutionConfig(this.external, this.reportToClient);
        }
        catch (error) {
            this.destroy();
            throw error;
        }
    }
    /**
     * Destroys the STT node execution config.
     */
    destroy() {
        var _a;
        (_a = this.speechRecognitionConfig) === null || _a === void 0 ? void 0 : _a.destroy();
        this.speechRecognitionConfig = null;
        if (this.external) {
            expose_binary_1.ExecutionConfigFunctions.deleteSTTNodeExecutionConfig(this.external);
        }
        super.destroy();
    }
}
exports.STTNodeExecutionConfig = STTNodeExecutionConfig;
/**
 * Represents the TTS node execution config.
 * @internal
 */
class TTSNodeExecutionConfig extends ExecutionConfig {
    constructor(props) {
        super(expose_binary_1.ExecutionConfigFunctions.newTTSNodeExecutionConfig(), props);
        let voice;
        let speechSynthesisConfig;
        try {
            voice = new common_1.Voice(props.speakerId);
            speechSynthesisConfig = new tts_1.SpeechSynthesisConfig(props.synthesisConfig);
            this.tts_component_id = props.tts_component_id;
            expose_binary_1.ExecutionConfigFunctions.setTTSComponentIdForTTSNodeExecutionConfig(this.external, props.tts_component_id);
            expose_binary_1.ExecutionConfigFunctions.setVoiceForTTSNodeExecutionConfig(this.external, voice.getExternal());
            expose_binary_1.ExecutionConfigFunctions.setReportToClientForTTSNodeExecutionConfig(this.external, this.reportToClient);
            this.voice = voice;
            this.speechSynthesisConfig = speechSynthesisConfig;
        }
        catch (error) {
            this.destroy();
            throw error;
        }
    }
    /**
     * Destroys the TTS node execution config.
     */
    destroy() {
        var _a, _b;
        (_a = this.speechSynthesisConfig) === null || _a === void 0 ? void 0 : _a.destroy();
        this.speechSynthesisConfig = null;
        (_b = this.voice) === null || _b === void 0 ? void 0 : _b.destroy();
        this.voice = null;
        if (this.external) {
            expose_binary_1.ExecutionConfigFunctions.deleteTTSNodeExecutionConfig(this.external);
        }
        super.destroy();
    }
}
exports.TTSNodeExecutionConfig = TTSNodeExecutionConfig;
/**
 * Represents the intent node execution config.
 * @internal
 */
class IntentNodeExecutionConfig extends ExecutionConfig {
    /**
     * Constructs a new intent node execution config.
     *
     * @param props - The properties.
     */
    constructor(props) {
        super(expose_binary_1.ExecutionConfigFunctions.newIntentNodeExecutionConfig(), props);
        try {
            this.matcherConfig = new intent_1.IntentMatcherCreationConfig(props.matcherConfig);
            expose_binary_1.ExecutionConfigFunctions.setMatcherConfigForIntentNodeExecutionConfig(this.external, this.matcherConfig.getExternal());
            expose_binary_1.ExecutionConfigFunctions.setReportToClientForIntentNodeExecutionConfig(this.external, this.reportToClient);
        }
        catch (error) {
            this.destroy();
            throw error;
        }
    }
    /**
     * Destroys the intent node execution config.
     */
    destroy() {
        var _a;
        (_a = this.matcherConfig) === null || _a === void 0 ? void 0 : _a.destroy();
        this.matcherConfig = null;
        if (this.external) {
            expose_binary_1.ExecutionConfigFunctions.deleteIntentNodeExecutionConfig(this.external);
        }
        super.destroy();
    }
}
exports.IntentNodeExecutionConfig = IntentNodeExecutionConfig;
/**
 * Represents the LLM node execution config.
 * @internal
 */
class LLMChatNodeExecutionConfig extends ExecutionConfig {
    /**
     * Constructs a new LLM node execution config.
     *
     * @param props - The properties.
     */
    constructor(props) {
        var _a;
        super(expose_binary_1.ExecutionConfigFunctions.newLLMNodeExecutionConfig(), props);
        try {
            this.textGenerationConfig = new llm_1.TextGenerationConfig(props.textGenerationConfig);
            expose_binary_1.ExecutionConfigFunctions.setTextGenerationConfigForLLMNodeExecutionConfig(this.external, this.textGenerationConfig.getExternal());
            this.llm_component_id = props.llm_component_id;
            expose_binary_1.ExecutionConfigFunctions.setLLMComponentIdForLLMNodeExecutionConfig(this.external, props.llm_component_id);
            this.stream = (_a = props.stream) !== null && _a !== void 0 ? _a : false;
            expose_binary_1.ExecutionConfigFunctions.setStreamIdForLLMNodeExecutionConfig(this.external, props.stream);
            expose_binary_1.ExecutionConfigFunctions.setReportToClientForLLMNodeExecutionConfig(this.external, this.reportToClient);
        }
        catch (error) {
            this.destroy();
            throw error;
        }
    }
    /**
     * Destroys the LLM node execution config.
     */
    destroy() {
        var _a;
        (_a = this.textGenerationConfig) === null || _a === void 0 ? void 0 : _a.destroy();
        this.textGenerationConfig = null;
        if (this.external) {
            expose_binary_1.ExecutionConfigFunctions.deleteLLMNodeExecutionConfig(this.external);
        }
        super.destroy();
    }
}
exports.LLMChatNodeExecutionConfig = LLMChatNodeExecutionConfig;
/**
 * Represents the text aggregator node execution config.
 * @internal
 */
class TextAggregatorNodeExecutionConfig extends ExecutionConfig {
    /**
     * Constructs a new text aggregator node execution config.
     *
     * @param props - The properties.
     */
    constructor(props) {
        super(expose_binary_1.ExecutionConfigFunctions.newNodeExecutionConfig(), props);
        try {
            expose_binary_1.ExecutionConfigFunctions.setReportToClientForNodeExecutionConfig(this.external, this.reportToClient);
        }
        catch (error) {
            this.destroy();
            throw error;
        }
    }
    /**
     * Destroys the text aggregator node execution config.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.ExecutionConfigFunctions.deleteNodeExecutionConfig(this.external);
        }
        super.destroy();
    }
}
exports.TextAggregatorNodeExecutionConfig = TextAggregatorNodeExecutionConfig;
/**
 * Represents the text chunking node execution config.
 * @internal
 */
class TextChunkingNodeExecutionConfig extends ExecutionConfig {
    /**
     * Constructs a new text chunking node execution config.
     *
     * @param props - The properties.
     */
    constructor(props) {
        super(expose_binary_1.ExecutionConfigFunctions.newNodeExecutionConfig(), props);
        try {
            expose_binary_1.ExecutionConfigFunctions.setReportToClientForNodeExecutionConfig(this.external, this.reportToClient);
        }
        catch (error) {
            this.destroy();
            throw error;
        }
    }
    /**
     * Destroys the text chunking node execution config.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.ExecutionConfigFunctions.deleteNodeExecutionConfig(this.external);
        }
        super.destroy();
    }
}
exports.TextChunkingNodeExecutionConfig = TextChunkingNodeExecutionConfig;
