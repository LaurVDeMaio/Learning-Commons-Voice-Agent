"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigRegistry = void 0;
const koffi = __importStar(require("koffi"));
const uuid_1 = require("uuid");
const external_1 = require("../../../common/error/external");
const inworld_1 = require("../../../common/error/inworld");
const expose_binary_1 = require("../../../expose_binary");
class ConfigRegistry {
    constructor() {
        this.registeredCallbacks = new Map();
        this.external = expose_binary_1.ConfigRegistryFunctions.getInstance();
        if (!this.external) {
            throw new inworld_1.InworldError('Failed to get ConfigRegistry instance');
        }
    }
    static getInstance() {
        if (!ConfigRegistry.instance) {
            ConfigRegistry.instance = new ConfigRegistry();
        }
        return ConfigRegistry.instance;
    }
    /**
     * Registers a custom config type with the registry.
     * @param type The config type name
     * @param deserializeExecutor Pointer to the deserialize executor
     * @param serializeExecutor Pointer to the serialize executor
     * @returns true if registration succeeded
     */
    registerCustomConfig(type, deserializeExecutor, serializeExecutor) {
        const statusPtr = expose_binary_1.ConfigRegistryFunctions.registerCustomConfig(this.external, type, deserializeExecutor, serializeExecutor);
        // TODO: Add status checking logic if needed
        return !!statusPtr;
    }
    /**
     * Creates a generic config executor pair for JSON-based configs
     * @param configType The config type name
     * @returns Object containing deserializeExecutor, serializeExecutor, and callback references
     */
    createGenericConfigExecutors(configType) {
        const DeserializeCallback = koffi.proto(`${configType}DeserializeCallback-${(0, uuid_1.v4)()}`, 'void', ['void *', 'int']);
        const deserializeCallback = (_, executionId) => {
            try {
                const jsonInput = expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.getInput(executionId);
                const config = JSON.parse(jsonInput);
                const destructor = expose_binary_1.ConfigWrapperDestructorFunctions.new(null, null);
                const configWrapper = expose_binary_1.CustomConfigWrapperFunctions.new(configType, JSON.stringify(config), destructor);
                const outputPtr = expose_binary_1.StatusOrCustomConfigWrapperFunctions.newFromCustomConfigWrapper(configWrapper);
                expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.setOutput(executionId, outputPtr);
                expose_binary_1.StatusOrCustomConfigWrapperFunctions.delete(outputPtr);
                expose_binary_1.CustomConfigWrapperFunctions.delete(configWrapper);
                expose_binary_1.ConfigWrapperDestructorFunctions.delete(destructor);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error('Error in deserializeCallback:', error);
                const processError = new external_1.ExternalProcessError(error.message, external_1.ExternalProcessStatusCode.Internal);
                const errorPtr = expose_binary_1.StatusOrCustomConfigWrapperFunctions.newFromStatus(processError.getExternal());
                expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.setOutput(executionId, errorPtr);
                expose_binary_1.StatusOrCustomConfigWrapperFunctions.delete(errorPtr);
            }
        };
        const externalDeserializeCallback = koffi.register(deserializeCallback, koffi.pointer(DeserializeCallback));
        const deserializeExecutor = expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.new(null, // context
        externalDeserializeCallback);
        const SerializeCallback = koffi.proto(`${configType}SerializeCallback-${(0, uuid_1.v4)()}`, 'void', ['void *', 'int']);
        const serializeCallback = (_, executionId) => {
            try {
                const configWrapperPtr = expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.getInput(executionId);
                if (configWrapperPtr) {
                    const typeId = expose_binary_1.CustomConfigWrapperFunctions.typeId(configWrapperPtr);
                    const value = expose_binary_1.CustomConfigWrapperFunctions.value(configWrapperPtr);
                    let jsonOutput = '';
                    if (typeId === 'json') {
                        jsonOutput = value;
                    }
                    else {
                        jsonOutput = JSON.stringify({ type: typeId, value });
                    }
                    expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.setOutput(executionId, jsonOutput);
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
            }
            catch (error) {
                expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.setOutput(executionId, '{}');
            }
        };
        const externalSerializeCallback = koffi.register(serializeCallback, koffi.pointer(SerializeCallback));
        const serializeExecutor = expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.new(null, // context
        externalSerializeCallback);
        return {
            deserializeExecutor,
            serializeExecutor,
            externalDeserializeCallback,
            externalSerializeCallback,
        };
    }
    /**
     * Registers the CustomNodeExecutionConfig type with the registry.
     * This is needed for deserializing custom node execution configurations.
     * @returns true if registration succeeded
     */
    registerCustomNodeExecutionConfig(configType) {
        const executors = this.createGenericConfigExecutors(configType);
        const result = this.registerCustomConfig(configType, executors.deserializeExecutor, executors.serializeExecutor);
        this.registeredCallbacks.set(configType, {
            deserialize: executors.externalDeserializeCallback,
            serialize: executors.externalSerializeCallback,
        });
        expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.delete(executors.deserializeExecutor);
        expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.delete(executors.serializeExecutor);
        return result;
    }
    /**
     * Registers the LLMChatNodeExecutionConfig type with the registry.
     * @returns true if registration succeeded
     */
    registerLLMChatNodeExecutionConfig() {
        const configType = 'LLMChatNodeExecutionConfig';
        const executors = this.createGenericConfigExecutors(configType);
        const result = this.registerCustomConfig(configType, executors.deserializeExecutor, executors.serializeExecutor);
        this.registeredCallbacks.set(configType, {
            deserialize: executors.externalDeserializeCallback,
            serialize: executors.externalSerializeCallback,
        });
        expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.delete(executors.deserializeExecutor);
        expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.delete(executors.serializeExecutor);
        return result;
    }
    /**
     * Registers the TTSNodeExecutionConfig type with the registry.
     * @returns true if registration succeeded
     */
    registerTTSNodeExecutionConfig() {
        const configType = 'TTSNodeExecutionConfig';
        const executors = this.createGenericConfigExecutors(configType);
        const result = this.registerCustomConfig(configType, executors.deserializeExecutor, executors.serializeExecutor);
        this.registeredCallbacks.set(configType, {
            deserialize: executors.externalDeserializeCallback,
            serialize: executors.externalSerializeCallback,
        });
        expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.delete(executors.deserializeExecutor);
        expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.delete(executors.serializeExecutor);
        return result;
    }
    /**
     * Registers the NodeExecutionConfig type with the registry.
     * @returns true if registration succeeded
     */
    registerNodeExecutionConfig() {
        const configType = 'NodeExecutionConfig';
        const executors = this.createGenericConfigExecutors(configType);
        const result = this.registerCustomConfig(configType, executors.deserializeExecutor, executors.serializeExecutor);
        this.registeredCallbacks.set(configType, {
            deserialize: executors.externalDeserializeCallback,
            serialize: executors.externalSerializeCallback,
        });
        expose_binary_1.CustomConfigThreadedDeserializeExecutorFunctions.delete(executors.deserializeExecutor);
        expose_binary_1.CustomConfigThreadedSerializeExecutorFunctions.delete(executors.serializeExecutor);
        return result;
    }
    /**
     * Registers all config types needed for the custom TTS dynamic config example.
     * @returns true if all registrations succeeded
     */
    registerAllDefaultConfigs() {
        const results = [
            this.registerLLMChatNodeExecutionConfig(),
            this.registerTTSNodeExecutionConfig(),
            this.registerNodeExecutionConfig(),
        ];
        return results.every((result) => result);
    }
    /**
     * Deserializes a custom config from JSON.
     * @param type The config type name
     * @param jsonData The JSON string
     * @returns Pointer to the deserialized config wrapper
     */
    deserializeCustomConfig(type, jsonData) {
        const resultPtr = expose_binary_1.ConfigRegistryFunctions.deserializeCustomConfig(this.external, type, jsonData);
        if (!resultPtr) {
            throw new inworld_1.InworldError('Failed to deserialize custom config');
        }
        return resultPtr;
    }
    /**
     * Serializes a custom config to JSON.
     * @param type The config type name
     * @param configPtr Pointer to the config wrapper
     * @returns JSON string
     */
    serializeCustomConfig(type, configPtr) {
        const resultPtr = expose_binary_1.ConfigRegistryFunctions.serializeCustomConfig(this.external, type, configPtr);
        if (!resultPtr) {
            throw new inworld_1.InworldError('Failed to serialize custom config');
        }
        // TODO: Convert resultPtr to string if needed
        return resultPtr;
    }
    /**
     * Cleans up resources associated with this config registry.
     * Unregisters all stored callbacks to prevent memory leaks.
     */
    destroy() {
        for (const [_, callbacks] of this.registeredCallbacks.entries()) {
            if (callbacks.deserialize) {
                koffi.unregister(callbacks.deserialize);
            }
            if (callbacks.serialize) {
                koffi.unregister(callbacks.serialize);
            }
        }
        this.registeredCallbacks.clear();
    }
}
exports.ConfigRegistry = ConfigRegistry;
