"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomNodeRegistry = void 0;
exports.registerCustomEdgeCondition = registerCustomEdgeCondition;
exports.clearCustomEdgeCondition = clearCustomEdgeCondition;
exports.clearCustomNodeTypeCallback = clearCustomNodeTypeCallback;
exports.registerCustomNodeType = registerCustomNodeType;
const common_1 = require("../../../common");
const external_1 = require("../../../common/error/external");
const helpers_1 = require("../../../common/helpers");
const Deferred_1 = require("../../../common/utils/Deferred");
const expose_binary_1 = require("../../../expose_binary");
const node_api_1 = require("../../../node-api");
const ComponentRegistry_1 = __importDefault(require("../../ComponentRegistry"));
const EdgeConditionExecutor_1 = require("../../EdgeConditionExecutor");
const from_external_1 = require("../../utils/from_external");
const to_external_1 = require("../../utils/to_external");
const process_context_Impl_1 = require("./process_context_Impl");
/**
 * Registry for custom node types that can be used in graph configurations.
 * Allows registration of custom node types that can be referenced by name in JSON configurations.
 */
class CustomNodeRegistry {
    constructor() {
        this.registeredTypes = new Map();
        this.registeredCallbacks = new Map();
        this.registeredEdgeConditions = new Map();
    }
    /**
     * Gets the singleton instance of the CustomNodeRegistry.
     */
    static getInstance() {
        if (!CustomNodeRegistry.instance) {
            CustomNodeRegistry.instance = new CustomNodeRegistry();
        }
        return CustomNodeRegistry.instance;
    }
    /**
     * Registers a custom node type with the runtime.
     *
     * @param type - The type name to register (e.g., 'InputNode', 'MyCustomNode')
     * @param processFunction - Function that processes the node inputs
     * @throws InworldError if registration fails
     */
    registerType(type, processFunction) {
        if (this.registeredTypes.has(type)) {
            throw new common_1.InworldError(`Custom node type '${type}' is already registered`);
        }
        this.registeredTypes.set(type, new Deferred_1.Deferred());
        return this.registerWithCpp(type, processFunction);
    }
    /**
     * Clears all registered custom node types and cleanup resources.
     */
    clear() {
        this.registeredTypes.clear();
        this.registeredCallbacks.clear();
        this.registeredEdgeConditions.clear();
    }
    /**
     * Static method to cleanup the singleton instance.
     * Call this during application shutdown to prevent memory leaks.
     */
    static destroy() {
        if (CustomNodeRegistry.instance) {
            CustomNodeRegistry.instance.clear();
            CustomNodeRegistry.instance = null;
        }
    }
    /**
     * Processes inputs based on input type specifications.
     */
    processInputs(inputs) {
        if (!inputs || inputs.length === 0) {
            throw new external_1.ExternalProcessError('No inputs provided for custom node', external_1.ExternalProcessStatusCode.InvalidArgument);
        }
        const results = [];
        for (let i = 0; i < inputs.length; i++) {
            results[i] = (0, from_external_1.fromExternal)(inputs[i]);
        }
        return results;
    }
    /**
     * Processes the output based on output type specification.
     */
    async processOutput(outputResult) {
        if (outputResult instanceof Promise) {
            outputResult = await outputResult;
        }
        return expose_binary_1.StatusOrBaseDataFunctions.newFromBaseData((0, to_external_1.toExternal)(outputResult).getExternal());
    }
    createNodeCallback(type, processFunction) {
        return (0, node_api_1.createNodeCallbackWrapper)(async (context, ...inputs) => {
            try {
                const processedInputs = this.processInputs(inputs);
                const processContext = new process_context_Impl_1.ProcessContextImpl(context.processCtx);
                const outputResult = processFunction(processContext, ...processedInputs);
                return await this.processOutput(outputResult);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error(`Error in custom node ${type}:`, error);
                const processError = new external_1.ExternalProcessError(`Custom node ${type} failed: ${error.message}`, external_1.ExternalProcessStatusCode.Internal);
                return expose_binary_1.StatusOrBaseDataFunctions.newFromBaseData(processError.getExternal());
            }
        });
    }
    /**
     * @internal
     */
    registerWithCpp(type, processFunction) {
        const callbackWrapper = this.createNodeCallback(type, processFunction);
        const status = expose_binary_1.FFIFunctions.registerCallbackNode(ComponentRegistry_1.default.getComponentRegistry(), type, callbackWrapper);
        if (!status) {
            throw new common_1.InworldError(`Failed to register custom node type '${type}'`);
        }
        this.registeredCallbacks.set(type, callbackWrapper);
        const result = (0, helpers_1.getStatus)(status) === 'OK';
        if (!result) {
            throw new Error('Failed to register new custom node');
        }
        return result;
    }
}
exports.CustomNodeRegistry = CustomNodeRegistry;
/**
 * Registers a custom edge condition for conditional graph execution.
 */
function registerCustomEdgeCondition(id, condition) {
    const edgeConditionExecutor = new EdgeConditionExecutor_1.EdgeConditionExecutor(condition);
    const status = expose_binary_1.FFIFunctions.registerEdgeConditionCallback(expose_binary_1.ComponentRegistryFunctions.getInstance(), id, edgeConditionExecutor.getCallbackWrapper());
    if (!status) {
        throw new common_1.InworldError('Failed to register custom edge condition');
    }
    const registry = CustomNodeRegistry.getInstance();
    registry['registeredEdgeConditions'].set(id, () => {
        edgeConditionExecutor.destroy();
    });
    return {
        id,
    };
}
/**
 * Clears a custom edge condition by ID.
 */
function clearCustomEdgeCondition(id) {
    const registry = CustomNodeRegistry.getInstance();
    const destroy = registry['registeredEdgeConditions'].get(id);
    if (destroy) {
        try {
            destroy();
        }
        finally {
            registry['registeredEdgeConditions'].delete(id);
        }
    }
}
/**
 * Clears a custom node type callback by ID.
 */
function clearCustomNodeTypeCallback(id) {
    const registry = CustomNodeRegistry.getInstance();
    if (registry['registeredCallbacks'].get(id)) {
        registry['registeredCallbacks'].delete(id);
    }
}
/**
 * Helper function to register a simple custom node type with improved type safety.
 */
function registerCustomNodeType(type, processFunction) {
    const registry = CustomNodeRegistry.getInstance();
    const success = registry.registerType(type, processFunction);
    if (!success) {
        throw new common_1.InworldError(`Failed to register custom node type '${type}'`);
    }
    return {
        typeName: type,
    };
}
