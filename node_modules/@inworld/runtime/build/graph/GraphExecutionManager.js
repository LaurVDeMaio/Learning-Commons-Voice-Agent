"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphExecutionManager = void 0;
/**
 * Global registry for managing graph executions and registered graphs
 * This singleton class tracks execution counts per graph ID and registered graph instances
 */
class GraphExecutionManager {
    constructor() {
        this.executionCounts = new Map();
        this.registeredGraphs = new Map();
    }
    static getInstance() {
        if (!GraphExecutionManager.instance) {
            GraphExecutionManager.instance = new GraphExecutionManager();
        }
        return GraphExecutionManager.instance;
    }
    /**
     * Register a graph instance (separate from executions)
     */
    registerGraph(graphId, graph) {
        this.registeredGraphs.set(graphId, graph);
        if (!this.executionCounts.has(graphId)) {
            this.executionCounts.set(graphId, {
                graphId,
                activeExecutions: 0,
                totalExecutions: 0,
            });
        }
    }
    /**
     * Unregister a graph instance
     */
    unregisterGraph(graphId) {
        this.registeredGraphs.delete(graphId);
        this.executionCounts.delete(graphId);
    }
    /**
     * Get all registered graphs
     */
    getAllRegisteredGraphs() {
        return Array.from(this.registeredGraphs.values());
    }
    /**
     * Register a new graph execution
     */
    registerExecution(graphId) {
        const counts = this.executionCounts.get(graphId);
        if (counts) {
            counts.activeExecutions++;
            counts.totalExecutions++;
        }
        else {
            this.executionCounts.set(graphId, {
                graphId,
                activeExecutions: 1,
                totalExecutions: 1,
            });
        }
    }
    /**
     * Unregister a graph execution
     */
    unregisterExecution(graphId) {
        const counts = this.executionCounts.get(graphId);
        if (counts && counts.activeExecutions > 0) {
            counts.activeExecutions--;
        }
    }
    /**
     * Clear all registered graphs, executions, and counts (without cleanup)
     */
    clearAll() {
        this.executionCounts.clear();
        this.registeredGraphs.clear();
    }
    /**
     * Global cleanup method that handles all registered graphs
     * Performs the complete cleanup sequence for each graph
     */
    cleanupAllGraphs() {
        const graphs = this.getAllRegisteredGraphs();
        const graphIds = Array.from(this.registeredGraphs.keys());
        for (let i = 0; i < graphs.length; i++) {
            const graph = graphs[i];
            const graphId = graphIds[i];
            try {
                graph.stopExecutor();
                graph.cleanupAllExecutions();
                graph.destroy();
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error(`  ❌ Error cleaning up graph ${graphId}:`, error);
            }
        }
        this.clearAll();
    }
    static destroy() {
        if (GraphExecutionManager.instance) {
            GraphExecutionManager.instance = null;
        }
    }
}
exports.GraphExecutionManager = GraphExecutionManager;
