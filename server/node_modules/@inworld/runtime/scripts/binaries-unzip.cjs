const fs = require('fs');
const os = require('os');
const path = require('path');
const decompress = require('decompress');
const decompressTargz = require('decompress-targz');
const decompressUnzip = require('decompress-unzip');
const {
  downloadUnzipBinaries,
  extractLibOnly,
  extractNodeAddonOnly,
} = require('./download-unzip-binaries.cjs');

async function unzipBinaries() {
  const platform = os.platform();
  const arch = os.arch();
  const platformArch = `${platform}_${arch}`;

  const binDir = path.join(__dirname, '..', 'bin');
  const sourceZip = path.join(binDir, `${platformArch}.zip`);
  const sourceTgz = path.join(binDir, `${platformArch}.tar.gz`);
  // Also look for pre-fetched official archives: inworld_api_* for this platform
  const platformMap = {
    darwin_arm64: 'darwin_aarch64',
    linux_x64: 'linux_x86_64',
    linux_arm64: 'linux_aarch64',
    win32_x64: 'windows_x64',
  };
  const mapped = platformMap[platformArch] || '';
  const archivePattern = new RegExp(
    `^inworld_api_.*_${mapped}_.*\\.(?:tar\\.gz|zip)$`,
  );
  const binEntries = fs.readdirSync(binDir);
  const apiArchives = binEntries.filter((f) => archivePattern.test(f));
  const apiArchiveCabi = apiArchives.find((f) => f.includes('_cpu_full_cabi.'));
  const apiArchiveNode = apiArchives.find((f) => f.includes('_cpu_full_node.'));
  const apiArchive = apiArchiveCabi || apiArchiveNode || null;
  const targetDir = path.join(binDir, platformArch);
  const versionFilePath = path.join(targetDir, 'version.txt');

  // Extract version from archive filename
  let currentVersion = null;
  if (apiArchive) {
    // Extract version from inworld_api_VERSION_platform pattern
    const versionMatch = apiArchive.match(/inworld_api_([^_]+)_/);
    currentVersion = versionMatch ? versionMatch[1] : null;
  } else if (fs.existsSync(sourceZip) || fs.existsSync(sourceTgz)) {
    // For custom archives, use filename as version
    const archiveName = fs.existsSync(sourceZip) ? path.basename(sourceZip) : path.basename(sourceTgz);
    currentVersion = archiveName;
  } else {
    // Try to get version from runtime-binaries-version.txt for download case
    try {
      const frameworkVersionPath = path.join(__dirname, '..', 'runtime-binaries-version.txt');
      if (fs.existsSync(frameworkVersionPath)) {
        currentVersion = fs.readFileSync(frameworkVersionPath, 'utf8').trim();
      }
    } catch (err) {
      console.log(`Could not read runtime-binaries-version.txt: ${err.message}`);
    }
  }

  // Check existing version
  let existingVersion = null;
  if (fs.existsSync(versionFilePath)) {
    try {
      existingVersion = fs.readFileSync(versionFilePath, 'utf8').trim();
    } catch (err) {
      console.log(`Could not read version file: ${err.message}`);
    }
  }

  // If versions match and target directory exists, use cached binaries
  if (currentVersion && existingVersion === currentVersion && fs.existsSync(targetDir)) {
    console.log(`Using cached binaries v${currentVersion} in ${targetDir}`);
    return;
  }

  console.log(`Version changed (${existingVersion} â†’ ${currentVersion}) or no cache found. Extracting binaries...`);

  const hasZip = fs.existsSync(sourceZip);
  const hasTgz = fs.existsSync(sourceTgz);
  const hasApi = Boolean(apiArchive);
  const hasApiCabi = Boolean(apiArchiveCabi);
  const hasApiNode = Boolean(apiArchiveNode);
  if (!hasZip && !hasTgz && !hasApi) {
    console.log(
      `No local archive found for ${platformArch}. Attempting to download release assets (using INWORLD_RUNTIME_RELEASE_TAG or runtime-binaries-version.txt) ...`,
    );
    await downloadUnzipBinaries();
    if (fs.existsSync(targetDir)) {
      console.log(`Using downloaded binaries in ${targetDir}`);
      // Try to write version file for downloaded binaries
      if (currentVersion) {
        try {
          fs.writeFileSync(versionFilePath, currentVersion, 'utf8');
          console.log(`Wrote version file for downloaded binaries: ${currentVersion}`);
        } catch (err) {
          console.log(`Warning: Could not write version file: ${err.message}`);
        }
      }
      return;
    }
    throw new Error(
      `No prebuilt archive found for ${platform} ${arch}. Expected one of: ${sourceZip} or ${sourceTgz}. ` +
        `Also attempted to download via scripts/download-unzip-binaries.cjs but target directory was not created.`,
    );
  }

  fs.rmSync(targetDir, { recursive: true, force: true });
  fs.mkdirSync(targetDir, { recursive: true });

  // Prefer extracting official inworld_api_* if present to match expected structure
  if (hasApi) {
    if (hasApiCabi) {
      const cabiFullPath = path.join(binDir, apiArchiveCabi);
      const cabiIsZip = apiArchiveCabi.endsWith('.zip');
      await extractLibOnly(cabiFullPath, targetDir, cabiIsZip);
    }
    if (hasApiNode) {
      const nodeFullPath = path.join(binDir, apiArchiveNode);
      const nodeIsZip = apiArchiveNode.endsWith('.zip');
      await extractNodeAddonOnly(nodeFullPath, targetDir, nodeIsZip);
    }
    if (!hasApiCabi && !hasApiNode && apiArchive) {
      const isZip = apiArchive.endsWith('.zip');
      const fullPath = path.join(binDir, apiArchive);
      await extractLibOnly(fullPath, targetDir, isZip);
    }
  } else {
    const archive = fs.existsSync(sourceZip) ? sourceZip : sourceTgz;
    const plugins = fs.existsSync(sourceZip)
      ? [decompressUnzip()]
      : [decompressTargz()];
    const files = await decompress(archive, targetDir, { plugins });

    // Set proper permissions for extracted files
    for (const file of files) {
      const filePath = path.join(targetDir, file.path);
      if (fs.existsSync(filePath)) {
        const stats = fs.statSync(filePath);
        if (stats.isFile()) {
          fs.chmodSync(filePath, 0o644);
        }
      }
    }
  }

  // Write version file after successful extraction
  if (currentVersion) {
    try {
      fs.writeFileSync(versionFilePath, currentVersion, 'utf8');
      console.log(`Wrote version file: ${currentVersion}`);
    } catch (err) {
      console.log(`Warning: Could not write version file: ${err.message}`);
    }
  }
}

unzipBinaries();
