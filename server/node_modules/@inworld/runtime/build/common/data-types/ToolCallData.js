"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListToolCallsResults = exports.ToolCallResult = exports.ListToolCallData = exports.ToolCallData = void 0;
const expose_binary_1 = require("../../expose_binary");
const messages_1 = require("../vector/messages");
const BaseData_1 = require("./BaseData");
/**
 * Class for managing a ToolCallData, which wraps a ToolCall object.
 */
class ToolCallData extends BaseData_1.BaseData {
    /**
     * Creates a new ToolCallData instance from a ToolCallInterface.
     *
     * @param {ToolCallInterface} toolCallInterface - The tool call interface to wrap
     */
    constructor(toolCallInterface) {
        const toolCall = messages_1.ToolCall.fromToolCallInterface(toolCallInterface);
        super(expose_binary_1.ToolCallDataFunctions.new(toolCall.getExternal()));
    }
    /**
     * Destroys the ToolCallData instance and frees associated resources.
     * This method should be called when the object is no longer needed to prevent memory leaks.
     */
    destroy() {
        expose_binary_1.ToolCallDataFunctions.delete(this.external);
    }
}
exports.ToolCallData = ToolCallData;
/**
 * Class for managing a collection of ToolCallData objects.
 *
 * This class provides functionality to manage multiple tool call data objects
 * as a single unit.
 */
class ListToolCallData extends BaseData_1.BaseData {
    /**
     * Creates a new ListToolCallData instance from an array of ToolCallInterface objects.
     *
     * @param {ToolCallInterface[]} toolCalls - Array of tool call interfaces to wrap
     */
    constructor(toolCalls) {
        const vector = expose_binary_1.VectorToolCallDataFunctions.new();
        toolCalls.forEach((toolCall) => {
            const toolCallData = new ToolCallData(toolCall);
            expose_binary_1.VectorToolCallDataFunctions.pushBack(vector, toolCallData.getExternal());
            toolCallData.destroy();
        });
        const external = expose_binary_1.ListToolCallDataFunctions.new(vector);
        expose_binary_1.VectorToolCallDataFunctions.delete(vector);
        super(external);
    }
    /**
     * Destroys the ListToolCallData instance and frees associated resources.
     * This method should be called when the object is no longer needed to prevent memory leaks.
     */
    destroy() {
        super.destroy();
    }
}
exports.ListToolCallData = ListToolCallData;
/**
 * Class for managing a single tool call result.
 *
 * This class represents the result of executing a tool call, containing the tool call ID
 * and the result string. It extends BaseData to provide consistent lifecycle management
 * and external reference handling.
 *
 * @example
 * ```typescript
 * const toolCallResult = new ToolCallResult('call_123', '{"temperature": 72}');
 * const result = toolCallResult.getToolCallResult();
 * console.log(result.toolCallId); // 'call_123'
 * console.log(result.result); // '{"temperature": 72}'
 * toolCallResult.destroy(); // Clean up when done
 * ```
 */
class ToolCallResult extends BaseData_1.BaseData {
    /**
     * Creates a new ToolCallResult instance.
     *
     * @param {string} toolCallId - The unique identifier of the tool call that was executed
     * @param {string} result - The result string returned by the executed tool/function
     */
    constructor(toolCallId, result) {
        super(expose_binary_1.ToolCallResultFunctions.new(toolCallId, result));
        this.toolCallId = toolCallId;
        this.result = result;
    }
    /**
     * @internal
     * Creates a new ToolCallResult instance from an external reference.
     *
     * This method is used internally by the runtime to create ToolCallResult instances
     * from external data sources.
     *
     * @param {ExternalReference} external - External reference to the tool call result data
     * @returns {ToolCallResult} A new ToolCallResult instance
     */
    static fromExternal(external) {
        const toolCallId = expose_binary_1.ToolCallResultFunctions.getToolCallId(external);
        const result = expose_binary_1.ToolCallResultFunctions.getResult(external);
        return new ToolCallResult(toolCallId, result);
    }
    /**
     * Checks if the ToolCallResult instance is valid.
     *
     * @returns {boolean} True if the instance is valid, false otherwise
     */
    isValid() {
        return expose_binary_1.ToolCallResultFunctions.isValid(this.external);
    }
    /**
     * Gets the tool call result as a ToolCallResultInterface.
     *
     * @returns {ToolCallResultInterface} Object containing the tool call ID and result string
     */
    getToolCallResult() {
        return {
            toolCallId: expose_binary_1.ToolCallResultFunctions.getToolCallId(this.external),
            result: expose_binary_1.ToolCallResultFunctions.getResult(this.external),
        };
    }
    /**
     * Destroys the ToolCallResult instance and frees associated resources.
     * This method should be called when the object is no longer needed to prevent memory leaks.
     */
    onDestroy() {
        expose_binary_1.ToolCallResultFunctions.delete(this.external);
    }
}
exports.ToolCallResult = ToolCallResult;
/**
 * Class for managing a collection of tool call results.
 *
 * This class provides functionality to manage multiple tool call results as a single unit.
 * It can be constructed from either an array of ToolCallResultInterface objects or an
 * external reference. It extends BaseData to provide consistent lifecycle management
 * and external reference handling.
 *
 * @example
 * ```typescript
 * // Create from array of results
 * const results: ToolCallResultInterface[] = [
 *   { toolCallId: 'call_1', result: '{"weather": "sunny"}' },
 *   { toolCallId: 'call_2', result: '{"time": "14:30"}' }
 * ];
 * const listResults = new ListToolCallsResults(results);
 *
 * // Get all results
 * const allResults = listResults.getToolCallResults();
 * console.log(allResults.length); // 2
 *
 * // Clean up
 * listResults.destroy();
 * ```
 */
class ListToolCallsResults extends BaseData_1.BaseData {
    /**
     * Creates a new ListToolCallsResults instance.
     *
     * @param {ToolCallResultInterface[] | ExternalReference} toolCallResultsOrExternal - Either an array of ToolCallResultInterface objects
     *                                    or an external reference to existing data
     */
    constructor(toolCallResultsOrExternal) {
        let external;
        let toolCallResults = null;
        if (Array.isArray(toolCallResultsOrExternal)) {
            const vector = expose_binary_1.VectorToolCallResultFunctions.new();
            toolCallResultsOrExternal.forEach((result) => {
                const toolCallResult = new ToolCallResult(result.toolCallId, result.result);
                toolCallResults.push(toolCallResult);
                expose_binary_1.VectorToolCallResultFunctions.pushBack(vector, toolCallResult.getExternal());
            });
            external = expose_binary_1.ListToolCallsResultsFunctions.new(vector);
            expose_binary_1.VectorToolCallResultFunctions.delete(vector);
        }
        else {
            external = toolCallResultsOrExternal;
        }
        super(external);
        this.toolCallResults = [];
        this.toolCallResults = toolCallResults;
    }
    /**
     * @internal
     * Creates a new ListToolCallsResults instance from an external reference.
     *
     * This method is used internally by the runtime to create ListToolCallsResults instances
     * from external data sources. It validates the external reference before creating the instance.
     *
     * @param {ExternalReference} external - External reference to the list tool calls results data
     * @returns {ListToolCallsResults | null} A new ListToolCallsResults instance if valid, null otherwise
     */
    static fromExternal(external) {
        const baseData = expose_binary_1.ListToolCallsResultsFunctions.toListToolCallsResults(external);
        if (baseData && expose_binary_1.ListToolCallsResultsFunctions.isValid(baseData)) {
            return new ListToolCallsResults(baseData);
        }
        return null;
    }
    /**
     * Gets all tool call results as an array of ToolCallResultInterface objects.
     *
     * This method returns the tool call results either from the cached internal array
     * or by extracting them from the external reference if the cache is not available.
     *
     * @returns {ToolCallResultInterface[]} Array of tool call result interfaces
     */
    getToolCallResults() {
        if (this.toolCallResults && this.toolCallResults.length > 0) {
            return this.toolCallResults;
        }
        if (this.external) {
            const toolCallResults = [];
            const vectorToolCallResults = expose_binary_1.ListToolCallsResultsFunctions.getToolCallResultsSwig(this.external);
            const size = expose_binary_1.VectorToolCallResultFunctions.size(vectorToolCallResults);
            for (let i = 0; i < size; i++) {
                const toolCallResultData = expose_binary_1.VectorToolCallResultFunctions.get(vectorToolCallResults, i);
                const toolCallResult = ToolCallResult.fromExternal(toolCallResultData).getToolCallResult();
                toolCallResults.push(toolCallResult);
            }
            return toolCallResults;
        }
        return [];
    }
    /**
     * Checks if the ListToolCallsResults instance is valid.
     *
     * @returns {boolean} True if the instance is valid, false otherwise
     */
    isValid() {
        return expose_binary_1.ListToolCallsResultsFunctions.isValid(this.external);
    }
    /**
     * Destroys the ListToolCallsResults instance and frees associated resources.
     *
     * This method cleans up all internal ToolCallResult instances and then calls
     * the parent destroy method. It should be called when the object is no longer
     * needed to prevent memory leaks.
     */
    destroy() {
        this.toolCallResults.forEach((toolCallResult) => {
            toolCallResult.destroy();
        });
        this.toolCallResults = [];
        super.destroy();
    }
}
exports.ListToolCallsResults = ListToolCallsResults;
