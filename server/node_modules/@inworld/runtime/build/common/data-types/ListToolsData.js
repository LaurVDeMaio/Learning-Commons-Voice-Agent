"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListToolsData = void 0;
const expose_binary_1 = require("../../expose_binary");
const messages_1 = require("../vector/messages");
const BaseData_1 = require("./BaseData");
const JsonData_1 = require("./JsonData");
/**
 * Class for handling list of tools data in graphs.
 * Extends BaseData with tools list-specific functionality.
 * @internal
 */
class ListToolsData extends BaseData_1.BaseData {
    constructor(toolsOrExternal) {
        let external;
        let tools = null;
        if (Array.isArray(toolsOrExternal)) {
            const vectorToolData = expose_binary_1.VectorToolDataFunctions.new();
            toolsOrExternal.forEach((toolInterface) => {
                const toolInstance = new messages_1.Tool(toolInterface);
                this.toolInstances.push(toolInstance);
                const toolData = expose_binary_1.ToolDataFunctions.new(toolInstance.getExternal());
                expose_binary_1.VectorToolDataFunctions.pushBack(vectorToolData, toolData);
            });
            external = expose_binary_1.ListToolsDataFunctions.new(vectorToolData);
            tools = toolsOrExternal;
            expose_binary_1.VectorToolDataFunctions.delete(vectorToolData);
        }
        else {
            external = toolsOrExternal;
        }
        super(external);
        this.tools = null;
        this.toolInstances = [];
        this.tools = tools;
    }
    /**
     * @internal
     * Creates a new ListToolsData instance from an external reference.
     *
     * @param {ExternalReference} external - The external reference to create the instance from
     * @returns {ListToolsData | null} A new ListToolsData instance or null if invalid
     */
    static fromExternal(external) {
        const baseData = expose_binary_1.ListToolsDataFunctions.toListToolsData(external);
        if (baseData && expose_binary_1.ListToolsDataFunctions.isValid(baseData)) {
            return new ListToolsData(baseData);
        }
        return null;
    }
    /**
     * Gets the tools list as an interface.
     * If external is set, it will parse from the external reference,
     * else it will return the tools array
     *
     * @returns {ListToolsInterface} The tools list interface object
     */
    getListTools() {
        if (this.external && this.tools === null) {
            // Parse from external reference
            const tools = [];
            const vectorToolData = expose_binary_1.ListToolsDataFunctions.getListToolsSwig(this.external);
            if (!expose_binary_1.VectorToolDataFunctions.isEmpty(vectorToolData)) {
                const size = expose_binary_1.VectorToolDataFunctions.size(vectorToolData);
                for (let i = 0; i < size; i++) {
                    const toolData = expose_binary_1.VectorToolDataFunctions.get(vectorToolData, i);
                    const tool = expose_binary_1.ToolDataFunctions.getTool(toolData);
                    let properties = {};
                    const propertiesString = expose_binary_1.ToolFunctions.getPropertiesAsString(tool);
                    if (propertiesString) {
                        const jsonData = new JsonData_1.JsonData(propertiesString);
                        properties = jsonData.getData();
                        jsonData.destroy();
                    }
                    const toolInterface = {
                        name: expose_binary_1.ToolFunctions.getName(tool),
                        description: expose_binary_1.ToolFunctions.getDescription(tool) || '',
                        properties: properties,
                    };
                    tools.push({ tool: toolInterface });
                }
            }
            return { list_tools: tools };
        }
        return {
            list_tools: (this.tools || []).map((tool) => ({ tool })),
        };
    }
    /**
     * Gets the tools array directly.
     *
     * @returns {ToolInterface[]} Array of tool interfaces
     */
    getTools() {
        return this.getListTools().list_tools.map((toolData) => toolData.tool);
    }
    /**
     * Checks if the ListToolsData is valid.
     *
     * @returns {boolean} True if valid, false otherwise
     */
    isValid() {
        return expose_binary_1.ListToolsDataFunctions.isValid(this.external);
    }
    /**
     * Cleans up resources used by the ListToolsData instance.
     */
    destroy() {
        // Clean up Tool instances
        for (const toolInstance of this.toolInstances) {
            toolInstance.destroy();
        }
        this.toolInstances = [];
        this.tools = null;
        super.destroy();
    }
}
exports.ListToolsData = ListToolsData;
