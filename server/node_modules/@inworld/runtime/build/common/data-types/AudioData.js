"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AudioData = void 0;
const expose_binary_1 = require("../../expose_binary");
const float_1 = require("../vector/float");
const BaseData_1 = require("./BaseData");
/**
 * Audio data for graph processing.
 *
 * Contains audio waveform data and sample rate information.
 */
class AudioData extends BaseData_1.BaseData {
    /**
     * Creates a new AudioData instance.
     *
     * @param {AudioChunkInterface} [audioData] - Optional audio data configuration
     */
    constructor(audioData) {
        const vectorFloat = new float_1.VectorFloat((audioData === null || audioData === void 0 ? void 0 : audioData.data) || []);
        try {
            super(expose_binary_1.AudioDataFunctions.new(vectorFloat.getExternal(), (audioData === null || audioData === void 0 ? void 0 : audioData.sampleRate) || 0));
        }
        finally {
            vectorFloat.destroy();
        }
    }
    /**
     * Retrieves the audio data as an AudioChunkInterface.
     *
     * @returns {AudioChunkInterface} Object containing audio data and sample rate
     */
    getData() {
        return {
            data: float_1.VectorFloat.toArray(expose_binary_1.AudioDataFunctions.waveForm(this.external)),
            sampleRate: expose_binary_1.AudioDataFunctions.sampleRate(this.external),
        };
    }
    /**
     * @internal
     * Creates an AudioData instance from an external reference.
     *
     * @param {ExternalReference} external - External reference to audio data
     * @returns {AudioData} New AudioData instance wrapping the external reference
     */
    static fromExternal(external) {
        const audioData = new AudioData();
        audioData.external = external;
        return audioData;
    }
}
exports.AudioData = AudioData;
