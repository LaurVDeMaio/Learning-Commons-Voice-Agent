"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextStream = void 0;
const expose_binary_1 = require("../../../expose_binary");
const inworld_1 = require("../../error/inworld");
const helpers_1 = require("../../helpers");
const transformation_stream_1 = require("./transformation_stream");
/**
 * Class for handling string-based streams.
 * Provides functionality to read text data from native stream implementations.
 * @internal
 */
class TextStream {
    /**
     * Creates a new TextStream instance.
     *
     * @param stream - External reference to the native stream implementation
     * @param onDestroy - Optional callback to execute when stream is consumed
     */
    constructor(stream, onDestroy) {
        this.stream = stream;
        this.onDestroy = onDestroy;
    }
    /**
     * Returns the external reference to the native stream implementation.
     *
     * @returns External reference object
     */
    getStream() {
        return this.stream;
    }
    /**
     * Asynchronously reads the next item from the stream.
     *
     * @returns Promise resolving to a result object with text content or done flag
     * @throws InworldError if reading from the stream fails
     */
    async next() {
        var _a, _b;
        while (await expose_binary_1.InputStreamFunctions.hasNext(this.stream)) {
            let inputStatus = await expose_binary_1.InputStreamFunctions.read(this.stream);
            if (!expose_binary_1.InputStreamFunctions.isOK(inputStatus)) {
                (_a = this.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
                throw new inworld_1.InworldError('Failed to read input stream', (0, helpers_1.getStatus)(inputStatus));
            }
            else {
                return {
                    text: expose_binary_1.InworldStringFunctions.get(inputStatus),
                    done: false,
                };
            }
        }
        (_b = this.onDestroy) === null || _b === void 0 ? void 0 : _b.call(this);
        return { done: true };
    }
    /**
     * Converts the stream to a text response with transformation capabilities.
     *
     * @param props - Transformation properties for text
     * @returns A TransformationStreamTextToText instance
     */
    toTextResponse(props) {
        return new transformation_stream_1.TransformationStreamTextToText(this.stream, props.transform, props === null || props === void 0 ? void 0 : props.filter);
    }
    /**
     * Converts the stream to a TTS output response with transformation capabilities.
     *
     * @param props - Transformation properties for TTS output
     * @returns A TransformationStreamTextToTTS instance
     */
    toTTSOutputResponse(props) {
        return new transformation_stream_1.TransformationStreamTextToTTS(this.stream, props.transform, props === null || props === void 0 ? void 0 : props.filter);
    }
    /**
     * Creates a new TextStream instance from an external reference.
     *
     * @param external - External reference to the native stream implementation
     * @returns A new TextStream instance
     * @internal
     */
    static fromExternal(external) {
        const stream = expose_binary_1.StreamStringFunctions.toStream(external);
        const streamData = expose_binary_1.StreamStringFunctions.getStream(stream);
        return new TextStream(streamData, () => {
            expose_binary_1.StreamStringFunctions.delete(stream);
            expose_binary_1.StreamStringFunctions.deleteStream(streamData);
        });
    }
}
exports.TextStream = TextStream;
