"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformationStreamTextToTTS = exports.TransformationStreamTextToText = exports.BaseTransformationStream = exports.TransformationStreamType = void 0;
/**
 * Currently, async functions cannot be executed directly in graph nodes.
 * We need to migrate to Node-API to handle async functions natively without deasync.
 *
 * Using deasync@1.0.4 specifically because newer versions have type definition issues
 * in index.d.ts that break yarn build, though ts-node still works.
 * TODO: Update once Node-API migration is complete.
 */
const deasync = __importStar(require("@kaciras/deasync"));
const koffi = __importStar(require("koffi"));
const uuid_1 = require("uuid");
const expose_binary_1 = require("../../../expose_binary");
const external_1 = require("../../error/external");
const inworld_1 = require("../../error/inworld");
const float_1 = require("../../vector/float");
const string_1 = require("../../vector/string");
const AudioData_1 = require("../AudioData");
var TransformationStreamType;
(function (TransformationStreamType) {
    TransformationStreamType["TEXT_TO_TEXT"] = "TEXT_TO_TEXT";
    TransformationStreamType["TEXT_TO_TTS"] = "TEXT_TO_TTS";
})(TransformationStreamType || (exports.TransformationStreamType = TransformationStreamType = {}));
/**
 * Base class for transformation streams.
 * @internal
 */
class BaseTransformationStream {
    constructor(options) {
        this.outputType = options.outputType;
        this.streamFunctions = BaseTransformationStream.getStreamFunctions(this.outputType);
        // Transform
        this.transformCallback = this.registerTransformCallback(options.transform);
        const transformExecutor = this.streamFunctions.newTransformExecutorExecutor(undefined, this.transformCallback);
        // Destructor
        this.destructorCallback = this.registerDestructorCallback();
        const destructor = expose_binary_1.TransformationStreamFunctions.newDestructor(undefined, this.destructorCallback);
        let fn;
        const props = [options.stream, transformExecutor];
        // Filter
        let filterExecutor;
        if (options.filter) {
            this.filterCallback = this.registerFilterCallback(options.filter);
            filterExecutor = this.streamFunctions.newFilterExecutorExecutor(undefined, this.filterCallback);
            fn = this.streamFunctions.newStreamWithFilter;
            props.push(filterExecutor);
        }
        else {
            fn = this.streamFunctions.newStreamWithoutFilter;
        }
        props.push(destructor);
        this.external = this.streamFunctions.newDataStream(expose_binary_1.TransformationStreamFunctions.value(fn(...props)), null);
        if (filterExecutor) {
            this.streamFunctions.deleteFilterExecutorExecutor(filterExecutor);
        }
        if (transformExecutor) {
            this.streamFunctions.deleteTransformExecutorExecutor(transformExecutor);
        }
        if (destructor) {
            expose_binary_1.TransformationStreamFunctions.deleteDestructor(destructor);
        }
    }
    /**
     * Returns the external reference to the native data implementation.
     *
     * @returns External reference object
     */
    getExternal() {
        return this.external;
    }
    destroy() {
        if (this.external) {
            this.streamFunctions.deleteStream(this.external);
            this.external = null;
        }
    }
    static getStreamFunctions(type) {
        switch (type) {
            case TransformationStreamType.TEXT_TO_TEXT:
                return expose_binary_1.TransformationStreamStrToStrFunctions;
            case TransformationStreamType.TEXT_TO_TTS:
                return expose_binary_1.TransformationStreamStrToTTSOutputFunctions;
            default:
                throw new inworld_1.InworldError(`Invalid transformation stream type: ${type}`);
        }
    }
    prepareOutput(transformResult) {
        switch (this.outputType) {
            case TransformationStreamType.TEXT_TO_TEXT:
                return transformResult;
            case TransformationStreamType.TEXT_TO_TTS:
                const { text, phonemes, timestamps, audio } = transformResult;
                const phonemesExternal = new string_1.VectorString(phonemes);
                const timestampsExternal = new float_1.VectorFloat(timestamps);
                const audioExternal = new AudioData_1.AudioData(audio);
                return expose_binary_1.TTSOutputFunctions.new(text, audioExternal.getExternal(), phonemesExternal.getExternal(), timestampsExternal.getExternal());
            default:
                throw new inworld_1.InworldError(`Invalid transformation stream type: ${this.outputType}`);
        }
    }
    static getError(e) {
        const error = new external_1.ExternalProcessError(e.message, external_1.ExternalProcessStatusCode.Unknown);
        return expose_binary_1.StatusOrBaseDataFunctions.newFromStatus(error.getExternal());
    }
    registerTransformCallback(transform) {
        const TransformCallback = koffi.proto(`TransformationStreamCallback-${(0, uuid_1.v4)()}`, 'void', ['void*', 'int']);
        return koffi.register((_, executionId) => {
            try {
                const input = this.streamFunctions.getTransformExecutorInput(executionId);
                if (expose_binary_1.InworldStringFunctions.isOK(input)) {
                    const transformResult = deasync.awaitSync(transform(expose_binary_1.InworldStringFunctions.get(input)));
                    this.streamFunctions.setTransformExecutorOutput(executionId, this.streamFunctions.newEntity(this.prepareOutput(transformResult)));
                }
                else {
                    throw new inworld_1.InworldError('TransformationStream: Invalid input');
                }
            }
            catch (e) {
                this.streamFunctions.setTransformExecutorOutput(executionId, BaseTransformationStream.getError(e));
            }
        }, koffi.pointer(TransformCallback));
    }
    registerFilterCallback(filter) {
        const FilterCallback = koffi.proto(`FilterStreamCallback-${(0, uuid_1.v4)()}`, 'void', [
            'void*',
            'int',
        ]);
        return koffi.register((_, executionId) => {
            var _a;
            try {
                const input = this.streamFunctions.getFilterExecutorInput(executionId);
                if (expose_binary_1.InworldStringFunctions.isOK(input)) {
                    this.streamFunctions.setFilterExecutorOutput(executionId, (_a = filter(expose_binary_1.InworldStringFunctions.get(input))) !== null && _a !== void 0 ? _a : false);
                }
                else {
                    throw new inworld_1.InworldError('TransformationStream: Invalid input');
                }
            }
            catch (_error) {
                this.streamFunctions.setFilterExecutorOutput(executionId, false);
            }
        }, koffi.pointer(FilterCallback));
    }
    registerDestructorCallback() {
        const DestructorCallback = koffi.proto(`TransformationStreamDestructorCallback-${(0, uuid_1.v4)()}`, 'void', ['void*']);
        // FIXME: Looks like this is not called on C++ side
        // Need to investigate the issue on that side and check how it works on Node.js side
        return koffi.register((_) => {
            if (this.filterCallback) {
                koffi.unregister(this.filterCallback);
                this.filterCallback = null;
            }
            if (this.transformCallback) {
                koffi.unregister(this.transformCallback);
                this.transformCallback = null;
            }
            if (this.destructorCallback) {
                koffi.unregister(this.destructorCallback);
                this.destructorCallback = null;
            }
        }, koffi.pointer(DestructorCallback));
    }
}
exports.BaseTransformationStream = BaseTransformationStream;
class TransformationStreamTextToText extends BaseTransformationStream {
    constructor(stream, transform, filter) {
        super({
            outputType: TransformationStreamType.TEXT_TO_TEXT,
            stream,
            transform,
            filter,
        });
    }
}
exports.TransformationStreamTextToText = TransformationStreamTextToText;
class TransformationStreamTextToTTS extends BaseTransformationStream {
    constructor(stream, transform, filter) {
        super({
            outputType: TransformationStreamType.TEXT_TO_TTS,
            stream,
            transform,
            filter,
        });
    }
}
exports.TransformationStreamTextToTTS = TransformationStreamTextToTTS;
