"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Messages = exports.ToolCalls = exports.Tools = exports.ToolCall = exports.Tool = exports.ContentItems = exports.ContentItem = exports.ImageUrlData = void 0;
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for managing an image URL.
 * @internal
 */
class ImageUrlData {
    constructor(external) {
        this.external = external;
    }
    static fromImageUrlInterface(imageUrlInterface) {
        const external = expose_binary_1.ImageUrlFunctions.new();
        expose_binary_1.ImageUrlFunctions.setUrl(external, imageUrlInterface.url);
        expose_binary_1.ImageUrlFunctions.setDetail(external, imageUrlInterface.detail || 'auto');
        return new ImageUrlData(external);
    }
    getExternal() {
        return this.external;
    }
    destroy() {
        if (this.external) {
            expose_binary_1.ImageUrlFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.ImageUrlData = ImageUrlData;
/**
 * Class for managing a content item.
 * @internal
 */
class ContentItem {
    constructor(external) {
        this.external = external;
    }
    static fromContentItemInterface(contentItemInterface) {
        const external = expose_binary_1.ContentItemFunctions.new();
        if (contentItemInterface.type === 'text' && contentItemInterface.text) {
            expose_binary_1.ContentItemFunctions.setText(external, contentItemInterface.text);
        }
        else if (contentItemInterface.type === 'image' &&
            contentItemInterface.image_url) {
            const imageUrl = ImageUrlData.fromImageUrlInterface(contentItemInterface.image_url);
            expose_binary_1.ContentItemFunctions.setImageUrl(external, imageUrl.getExternal());
            imageUrl.destroy();
        }
        return new ContentItem(external);
    }
    /**
     * @internal
     * @param external
     */
    static fromExternal(external) {
        return new ContentItem(external);
    }
    getContentItemInterface() {
        if (expose_binary_1.ContentItemFunctions.isImage(this.external)) {
            return {
                type: 'image',
                image_url: expose_binary_1.ContentItemFunctions.getImageUrl(this.external),
            };
        }
        else {
            return {
                type: 'text',
                text: expose_binary_1.ContentItemFunctions.getText(this.external),
            };
        }
    }
    getExternal() {
        return this.external;
    }
    destroy() {
        if (this.external) {
            expose_binary_1.ContentItemFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.ContentItem = ContentItem;
/**
 * Class for managing a collection of content items.
 * @internal
 */
class ContentItems {
    constructor(external) {
        this.external = external;
    }
    static fromContentItemInterfaces(contentItemInterfaces) {
        const external = expose_binary_1.ContentItemsVectorFunctions.new();
        for (const contentItem of contentItemInterfaces) {
            const contentItemInstance = ContentItem.fromContentItemInterface(contentItem);
            expose_binary_1.ContentItemsVectorFunctions.pushBack(external, contentItemInstance.getExternal());
            contentItemInstance.destroy();
        }
        return new ContentItems(external);
    }
    /**
     * @internal
     * @param external
     */
    static fromExternal(external) {
        return new ContentItems(external);
    }
    getContentItemInterfaces() {
        const size = expose_binary_1.ContentItemsVectorFunctions.size(this.external);
        const contentItemInterfaces = [];
        for (let i = 0; i < size; i++) {
            const contentItem = expose_binary_1.ContentItemsVectorFunctions.get(this.external, i);
            contentItemInterfaces.push(ContentItem.fromExternal(contentItem).getContentItemInterface());
        }
        return contentItemInterfaces;
    }
    getExternal() {
        return this.external;
    }
    destroy() {
        if (this.external) {
            expose_binary_1.ContentItemsVectorFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.ContentItems = ContentItems;
/**
 * Class for managing a tool definition.
 * @internal
 */
class Tool {
    constructor(external) {
        this.external = external;
    }
    static fromToolInterface(toolInterface) {
        const external = expose_binary_1.ToolFunctions.new();
        expose_binary_1.ToolFunctions.setName(external, toolInterface.name);
        expose_binary_1.ToolFunctions.setDescription(external, toolInterface.description);
        expose_binary_1.ToolFunctions.setPropertiesFromString(external, JSON.stringify(toolInterface.properties));
        return new Tool(external);
    }
    static fromExternal(external) {
        return new Tool(external);
    }
    getExternal() {
        return this.external;
    }
    getToolInterface() {
        return {
            name: expose_binary_1.ToolFunctions.getName(this.external),
            description: expose_binary_1.ToolFunctions.getDescription(this.external),
            properties: JSON.parse(expose_binary_1.ToolFunctions.getPropertiesAsString(this.external)),
        };
    }
    destroy() {
        if (this.external) {
            expose_binary_1.ToolFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.Tool = Tool;
/**
 * Class for managing a tool call.
 * @internal
 */
class ToolCall {
    constructor(external) {
        this.toolCall = external;
    }
    static fromToolCallInterface(toolCallInterface) {
        const external = expose_binary_1.ToolCallFunctions.new();
        expose_binary_1.ToolCallFunctions.setId(external, toolCallInterface.id);
        expose_binary_1.ToolCallFunctions.setName(external, toolCallInterface.name);
        expose_binary_1.ToolCallFunctions.setArgs(external, toolCallInterface.args);
        return new ToolCall(external);
    }
    /**
     * @internal
     * @param external
     */
    static fromExternal(external) {
        return new ToolCall(external);
    }
    getExternal() {
        return this.toolCall;
    }
    getToolCallInterface() {
        return {
            id: expose_binary_1.ToolCallFunctions.getId(this.toolCall),
            name: expose_binary_1.ToolCallFunctions.getName(this.toolCall),
            args: expose_binary_1.ToolCallFunctions.getArgs(this.toolCall),
        };
    }
    destroy() {
        if (this.toolCall) {
            expose_binary_1.ToolCallFunctions.delete(this.toolCall);
            this.toolCall = null;
        }
    }
}
exports.ToolCall = ToolCall;
/**
 * Class for managing a collection of tools.
 * @internal
 */
class Tools {
    constructor(external) {
        this.external = external;
    }
    static fromToolInterfaces(tools) {
        const external = expose_binary_1.ToolsVectorFunctions.new();
        for (const tool of tools) {
            const toolInstance = Tool.fromToolInterface(tool);
            expose_binary_1.ToolsVectorFunctions.pushBack(external, toolInstance.getExternal());
            toolInstance.destroy();
        }
        return new Tools(external);
    }
    static fromExternal(external) {
        return new Tools(external);
    }
    getExternal() {
        return this.external;
    }
    getTools() {
        const size = expose_binary_1.ToolsVectorFunctions.size(this.external);
        const tools = [];
        for (let i = 0; i < size; i++) {
            const tool = expose_binary_1.ToolsVectorFunctions.get(this.external, i);
            tools.push(Tool.fromExternal(tool).getToolInterface());
        }
        return tools;
    }
    destroy() {
        if (this.external) {
            expose_binary_1.ToolsVectorFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.Tools = Tools;
/**
 * Class for managing a collection of tool calls.
 * @internal
 */
class ToolCalls {
    constructor(external) {
        this.toolCalls = external;
    }
    static fromToolCallInterfaces(toolCallInterfaces) {
        const external = expose_binary_1.ToolCallsVectorFunctions.new();
        for (const toolCall of toolCallInterfaces) {
            const toolCallInstance = ToolCall.fromToolCallInterface(toolCall);
            expose_binary_1.ToolCallsVectorFunctions.pushBack(external, toolCallInstance.getExternal());
            toolCallInstance.destroy();
        }
        return new ToolCalls(external);
    }
    /**
     * Creates ToolCallInterface array from a native tool calls vector
     * @param {ExternalReference} toolCallsVector - External reference to tool calls vector
     * @returns {ToolCallInterface[]} Array of tool call interfaces
     * @static
     */
    static getToolCallInterfaces(toolCallsVector) {
        const toolCalls = [];
        if (!expose_binary_1.ToolCallsVectorFunctions.isEmpty(toolCallsVector)) {
            const size = expose_binary_1.ToolCallsVectorFunctions.size(toolCallsVector);
            for (let i = 0; i < size; i++) {
                const toolCall = expose_binary_1.ToolCallsVectorFunctions.get(toolCallsVector, i);
                const toolCallInstance = ToolCall.fromExternal(toolCall);
                toolCalls.push(toolCallInstance.getToolCallInterface());
                toolCallInstance.destroy();
            }
        }
        return toolCalls;
    }
    getExternal() {
        return this.toolCalls;
    }
    destroy() {
        if (this.toolCalls) {
            expose_binary_1.ToolCallsVectorFunctions.delete(this.toolCalls);
            this.toolCalls = null;
        }
    }
}
exports.ToolCalls = ToolCalls;
/**
 * @internal
 */
class Messages {
    constructor(external) {
        this.external = external;
    }
    static fromLLMMessageInterfaces(items) {
        const external = expose_binary_1.MessagesFunctions.new();
        items === null || items === void 0 ? void 0 : items.forEach((item) => {
            const message = expose_binary_1.MessageFunctions.new();
            expose_binary_1.MessageFunctions.setRole(message, item.role);
            if (typeof item.content === 'string') {
                expose_binary_1.MessageFunctions.setContent(message, item.content);
            }
            else {
                const contentItems = ContentItems.fromContentItemInterfaces(item.content);
                expose_binary_1.MessageFunctions.setContentItems(message, contentItems.getExternal());
                contentItems.destroy();
            }
            // Handle tool calls if present
            if (item.toolCalls && item.toolCalls.length > 0) {
                const toolCalls = ToolCalls.fromToolCallInterfaces(item.toolCalls);
                expose_binary_1.MessageFunctions.setToolCalls(message, toolCalls.getExternal());
                toolCalls.destroy();
            }
            // Handle tool call ID if present
            if (item.toolCallId) {
                expose_binary_1.MessageFunctions.setToolCallId(message, item.toolCallId);
            }
            expose_binary_1.MessagesFunctions.pushBack(external, message);
        });
        return new Messages(external);
    }
    getMessages() {
        const messages = [];
        const size = expose_binary_1.MessagesFunctions.size(this.external);
        for (let i = 0; i < size; i++) {
            const message = expose_binary_1.MessagesFunctions.get(this.external, i);
            let content = '';
            if (expose_binary_1.MessageFunctions.isTextContent(message)) {
                content = expose_binary_1.MessageFunctions.getContent(message);
            }
            else {
                const contentItems = ContentItems.fromExternal(expose_binary_1.MessageFunctions.getContentItems(message));
                content = contentItems.getContentItemInterfaces();
                contentItems.destroy();
            }
            messages.push({
                role: expose_binary_1.MessageFunctions.getRole(message),
                content: content,
                toolCalls: ToolCalls.getToolCallInterfaces(expose_binary_1.MessageFunctions.getToolCalls(message)),
                toolCallId: expose_binary_1.MessageFunctions.getToolCallId(message),
            });
        }
        return messages;
    }
    /**
     * @internal
     * @param external
     */
    static fromExternal(external) {
        return new Messages(external);
    }
    getExternal() {
        return this.external;
    }
    destroy() {
        if (this.external) {
            expose_binary_1.MessagesFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.Messages = Messages;
