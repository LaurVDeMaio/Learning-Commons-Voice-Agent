"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringStream = void 0;
const expose_binary_1 = require("../../expose_binary");
const error_1 = require("../error");
const helpers_1 = require("../helpers");
/**
 * Class for handling string-based streams.
 * Provides functionality to read text data from native stream implementations.
 * @internal
 */
class StringStream {
    /**
     * Creates a new StringStream instance.
     *
     * @param stream - External reference to the native stream implementation
     * @param onDestroy - Optional callback to execute when stream is consumed
     */
    constructor(stream, onDestroy) {
        this.stream = stream;
        this.onDestroy = onDestroy;
    }
    /**
     * Returns the external reference to the native stream implementation.
     *
     * @returns External reference object
     */
    get() {
        return this.stream;
    }
    /**
     * Asynchronously reads the next item from the stream.
     *
     * @returns Promise resolving to a result object with text content or done flag
     * @throws InworldError if reading from the stream fails
     */
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            while (expose_binary_1.InputStreamFunctions.hasNext(this.stream)) {
                let inputStatus = yield expose_binary_1.InputStreamFunctions.read(this.stream);
                if (!expose_binary_1.InputStreamFunctions.isOK(inputStatus)) {
                    (_a = this.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
                    throw new error_1.InworldError('Failed to read input stream', (0, helpers_1.getStatusContext)(inputStatus));
                }
                else {
                    return {
                        text: expose_binary_1.InworldStringFunctions.get(inputStatus),
                        done: false,
                    };
                }
            }
            (_b = this.onDestroy) === null || _b === void 0 ? void 0 : _b.call(this);
            return { done: true };
        });
    }
    /**
     * Synchronously reads the next item from the stream.
     *
     * @returns Result object with text content or done flag
     * @throws InworldError if reading from the stream fails
     */
    nextSync() {
        var _a;
        while (expose_binary_1.InputStreamFunctions.hasNext(this.stream)) {
            let inputStatus = expose_binary_1.InputStreamFunctions.readSync(this.stream);
            if (!expose_binary_1.InputStreamFunctions.isOK(inputStatus)) {
                throw new error_1.InworldError('Failed to read input stream', (0, helpers_1.getStatusContext)(inputStatus));
            }
            else {
                return {
                    text: expose_binary_1.InworldStringFunctions.get(inputStatus),
                    done: false,
                };
            }
        }
        (_a = this.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
        return { done: true };
    }
}
exports.StringStream = StringStream;
