"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentStream = void 0;
const expose_binary_1 = require("../../expose_binary");
const inworld_1 = require("../error/inworld");
const helpers_1 = require("../helpers");
const base_1 = require("./base");
const transformation_stream_1 = require("./transformation_stream");
/**
 * Class for handling string-based streams.
 * Provides functionality to read text data and tool calls from native stream implementations.
 * @internal
 */
class ContentStream extends base_1.BaseDataStream {
    /**
     * @internal
     * Creates a new ContentStream instance.
     *
     * @param {ExternalReference} stream - External reference to the native stream implementation
     * @param {() => void} [onDestroy] - Optional callback to execute when stream is consumed
     */
    constructor(stream, onDestroy) {
        super(stream, onDestroy);
    }
    /**
     * Extracts tool calls from a native tool calls vector
     * @param {ExternalReference} toolCallsVector - External reference to tool calls vector
     * @returns {ToolCallInterface[]} Array of tool call interfaces
     * @private
     */
    extractToolCalls(toolCallsVector) {
        const toolCalls = [];
        if (!expose_binary_1.ToolCallsVectorFunctions.isEmpty(toolCallsVector)) {
            const size = expose_binary_1.ToolCallsVectorFunctions.size(toolCallsVector);
            for (let i = 0; i < size; i++) {
                const toolCall = expose_binary_1.ToolCallsVectorFunctions.get(toolCallsVector, i);
                toolCalls.push({
                    id: expose_binary_1.ToolCallFunctions.getId(toolCall),
                    name: expose_binary_1.ToolCallFunctions.getName(toolCall),
                    args: expose_binary_1.ToolCallFunctions.getArgs(toolCall),
                });
            }
        }
        return toolCalls;
    }
    /**
     * Asynchronously reads the next item from the stream.
     *
     * @returns {Promise<ContentStreamIterationResult>} Promise resolving to a result object with text content and tool calls or done flag
     * @throws {InworldError} if reading from the stream fails
     */
    async next() {
        var _a, _b;
        while (await expose_binary_1.ContentStreamFunctions.hasNext(this.stream)) {
            let inputStatus = await expose_binary_1.ContentStreamFunctions.read(this.stream);
            if (!expose_binary_1.ContentStreamFunctions.isOK(inputStatus)) {
                (_a = this.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
                throw new inworld_1.InworldError('Failed to read input stream', (0, helpers_1.getStatus)(inputStatus));
            }
            else {
                const content = expose_binary_1.ContentStreamFunctions.getContent(inputStatus);
                const text = expose_binary_1.ContentStreamFunctions.getText(content);
                const toolCallsVector = expose_binary_1.ContentStreamFunctions.getToolCalls(content);
                const result = {
                    text,
                    done: false,
                };
                // Extract tool calls if they exist
                if (toolCallsVector) {
                    result.toolCalls = this.extractToolCalls(toolCallsVector);
                }
                return result;
            }
        }
        (_b = this.onDestroy) === null || _b === void 0 ? void 0 : _b.call(this);
        return { done: true };
    }
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                const result = await this.next();
                if (result.done) {
                    return { done: true, value: undefined };
                }
                return { done: false, value: result };
            },
        };
    }
    /**
     * Creates a new ContentStream instance from an external reference.
     *
     * @param {ExternalReference} external - External reference to the native stream implementation
     * @returns {ContentStream} A new ContentStream instance
     * @internal
     */
    static fromExternal(external) {
        return new ContentStream(external, () => {
            expose_binary_1.ContentStreamFunctions.delete(external);
        });
    }
    /**
     * Converts the stream to a text response format.
     * @param {TextStreamIterationToTextResponseInterface} props - Configuration for text response conversion
     * @returns {TransformationStreamTextToText} TransformationStreamTextToText instance
     */
    toTextResponse(props) {
        // For content streams, we need to extract text content and create a text transformation stream
        // This is a simplified implementation - in practice, you might want to handle tool calls differently
        return new transformation_stream_1.TransformationStreamTextToText(this.stream, props.transform);
    }
    /**
     * Converts the stream to a TTS output response format.
     * @param {Object} props - Configuration for TTS output response conversion
     * @param {(text: string) => Promise<TTSOutputInterface> | TTSOutputInterface} props.transform - Function that converts text to TTS output
     * @param {(text: string) => boolean} [props.filter] - Optional predicate function to filter text before processing
     * @returns {TransformationStreamTextToTTS} TransformationStreamTextToTTS instance
     */
    toTTSOutputResponse(props) {
        // For content streams, we need to extract text content and create a TTS transformation stream
        // This is a simplified implementation - in practice, you might want to handle tool calls differently
        return new transformation_stream_1.TransformationStreamTextToTTS(this.stream, props.transform);
    }
}
exports.ContentStream = ContentStream;
