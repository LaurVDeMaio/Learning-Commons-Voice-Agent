import { ContentStream, SpeechChunkStream, TextStream, TTSOutputStream } from '../../stream';
import { ClassificationResult } from './classification_result';
import { Content } from './content';
import { GoalAdvancement } from './goal_advancement';
import { KnowledgeRecords } from './knowledge_records';
import { ListTools } from './list_tools';
import { LLMChatRequest } from './llm_chat_request';
import { MatchedIntents } from './matched_intents';
import { MatchedKeywords } from './matched_keywords';
import { MemoryState } from './memory_state';
import { ToolCallResults } from './tool_call_results';
export * from '../../stream/speech_chunk';
export * from '../../stream/text';
export * from '../../stream/tts_output';
export * from './classification_result';
export * from './goal_advancement';
export * from './knowledge_records';
export * from './list_tools';
export * from './llm_chat_request';
export * from './matched_intents';
export * from './matched_keywords';
export * from './memory_state';
export * from './tool_call_results';
/**
 * Represents a custom-typed pointer to any structure.
 * This is a virtual TypeScript type that provides type safety without runtime overhead.
 * At runtime, this will just be the raw object, but TypeScript will understand the structure.
 *
 * @template T - The TypeScript type of the data structure
 *
 * @example
 * ```typescript
 * function process(input: Custom<{internalFields: string}>) {
 *   // TypeScript understands the structure
 *   console.log(input.internalFields);
 * }
 * ```
 */
export type Custom<T extends Object = any> = T;
/**
 * Type guards for CustomNodeInputTypes to enable easy type checking and switch-case patterns.
 * These functions help distinguish between different types in graph output streams.
 */
export declare namespace TypeGuards {
    function isString(value: CustomNodeInputTypes): value is string;
    function isCustom<T extends Object = any>(value: CustomNodeInputTypes): value is Custom<T>;
    function isClassificationResult(value: CustomNodeInputTypes): value is ClassificationResult;
    function isContent(value: CustomNodeInputTypes): value is Content;
    function isGoalAdvancement(value: CustomNodeInputTypes): value is GoalAdvancement;
    function isKnowledgeRecords(value: CustomNodeInputTypes): value is KnowledgeRecords;
    function isListTools(value: CustomNodeInputTypes): value is ListTools;
    function isLLMChatRequest(value: CustomNodeInputTypes): value is LLMChatRequest;
    function isMatchedIntents(value: CustomNodeInputTypes): value is MatchedIntents;
    function isMatchedKeywords(value: CustomNodeInputTypes): value is MatchedKeywords;
    function isMemoryState(value: CustomNodeInputTypes): value is MemoryState;
    function isToolCallResults(value: CustomNodeInputTypes): value is ToolCallResults;
    function isTextStream(value: CustomNodeInputTypes): value is TextStream;
    function isContentStream(value: CustomNodeInputTypes): value is ContentStream;
    function isTTSOutputStream(value: CustomNodeInputTypes): value is TTSOutputStream;
    function isSpeechChunkStream(value: CustomNodeInputTypes): value is SpeechChunkStream;
}
/**
 * Helper function to get a human-readable type name for CustomNodeInputTypes
 */
export declare function getTypeName(value: CustomNodeInputTypes): string;
/**
 * Helper function to process graph output stream responses with type safety.
 * This function makes it easy to handle different response types in a switch-like pattern.
 *
 * @param value - The response data to process
 * @param handlers - Object containing handler functions for each type
 * @returns The result from the appropriate handler
 *
 * @example
 * ```typescript
 * const result = processResponse(response.data, {
 *   string: (text) => `Got text: ${text}`,
 *   Custom: (custom) => `Got custom data: ${JSON.stringify(custom)}`,
 *   TextStream: async (stream) => {
 *     // Handle stream...
 *     return "Processed stream";
 *   },
 *   // Add other handlers as needed
 *   default: (value) => `Unknown type: ${getTypeName(value)}`
 * });
 * ```
 */
export declare function processGraphOutputResponse<T>(value: CustomNodeInputTypes | undefined, handlers: {
    string?: (value: string) => T;
    Custom?: <K extends Object>(value: Custom<K>) => T;
    ClassificationResult?: (value: ClassificationResult) => T;
    Content?: (value: Content) => T;
    GoalAdvancement?: (value: GoalAdvancement) => T;
    KnowledgeRecords?: (value: KnowledgeRecords) => T;
    ListTools?: (value: ListTools) => T;
    LLMChatRequest?: (value: LLMChatRequest) => T;
    MatchedIntents?: (value: MatchedIntents) => T;
    MatchedKeywords?: (value: MatchedKeywords) => T;
    MemoryState?: (value: MemoryState) => T;
    ToolCallResults?: (value: ToolCallResults) => T;
    TextStream?: (value: TextStream) => T;
    ContentStream?: (value: ContentStream) => T;
    TTSOutputStream?: (value: TTSOutputStream) => T;
    SpeechChunkStream?: (value: SpeechChunkStream) => T;
    default?: (value: CustomNodeInputTypes) => T;
}): T | undefined;
export type CustomNodeInputTypes = ClassificationResult | Content | GoalAdvancement | KnowledgeRecords | ListTools | LLMChatRequest | MatchedIntents | MatchedKeywords | MemoryState | ToolCallResults | TextStream | ContentStream | TTSOutputStream | SpeechChunkStream | Custom<any> | string;
export type CustomNodeOutputTypes = string | LLMChatRequest | TextStream | SpeechChunkStream | TTSOutputStream | ListTools | ToolCallResults | Custom<any>;
