"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGuards = void 0;
exports.getTypeName = getTypeName;
exports.processGraphOutputResponse = processGraphOutputResponse;
const stream_1 = require("../../stream");
const classification_result_1 = require("./classification_result");
const content_1 = require("./content");
const goal_advancement_1 = require("./goal_advancement");
const knowledge_records_1 = require("./knowledge_records");
const list_tools_1 = require("./list_tools");
const llm_chat_request_1 = require("./llm_chat_request");
const matched_intents_1 = require("./matched_intents");
const matched_keywords_1 = require("./matched_keywords");
const memory_state_1 = require("./memory_state");
const tool_call_results_1 = require("./tool_call_results");
__exportStar(require("../../stream/speech_chunk"), exports);
__exportStar(require("../../stream/text"), exports);
__exportStar(require("../../stream/tts_output"), exports);
__exportStar(require("./classification_result"), exports);
__exportStar(require("./goal_advancement"), exports);
__exportStar(require("./knowledge_records"), exports);
__exportStar(require("./list_tools"), exports);
__exportStar(require("./llm_chat_request"), exports);
__exportStar(require("./matched_intents"), exports);
__exportStar(require("./matched_keywords"), exports);
__exportStar(require("./memory_state"), exports);
__exportStar(require("./tool_call_results"), exports);
/**
 * Type guards for CustomNodeInputTypes to enable easy type checking and switch-case patterns.
 * These functions help distinguish between different types in graph output streams.
 */
var TypeGuards;
(function (TypeGuards) {
    function isString(value) {
        return typeof value === 'string';
    }
    TypeGuards.isString = isString;
    function isCustom(value) {
        return typeof value === 'object' && value !== null && !hasKnownType(value);
    }
    TypeGuards.isCustom = isCustom;
    function isClassificationResult(value) {
        return value instanceof classification_result_1.ClassificationResult;
    }
    TypeGuards.isClassificationResult = isClassificationResult;
    function isContent(value) {
        return value instanceof content_1.Content;
    }
    TypeGuards.isContent = isContent;
    function isGoalAdvancement(value) {
        return value instanceof goal_advancement_1.GoalAdvancement;
    }
    TypeGuards.isGoalAdvancement = isGoalAdvancement;
    function isKnowledgeRecords(value) {
        return value instanceof knowledge_records_1.KnowledgeRecords;
    }
    TypeGuards.isKnowledgeRecords = isKnowledgeRecords;
    function isListTools(value) {
        return value instanceof list_tools_1.ListTools;
    }
    TypeGuards.isListTools = isListTools;
    function isLLMChatRequest(value) {
        return value instanceof llm_chat_request_1.LLMChatRequest;
    }
    TypeGuards.isLLMChatRequest = isLLMChatRequest;
    function isMatchedIntents(value) {
        return value instanceof matched_intents_1.MatchedIntents;
    }
    TypeGuards.isMatchedIntents = isMatchedIntents;
    function isMatchedKeywords(value) {
        return value instanceof matched_keywords_1.MatchedKeywords;
    }
    TypeGuards.isMatchedKeywords = isMatchedKeywords;
    function isMemoryState(value) {
        return value instanceof memory_state_1.MemoryState;
    }
    TypeGuards.isMemoryState = isMemoryState;
    function isToolCallResults(value) {
        return value instanceof tool_call_results_1.ToolCallResults;
    }
    TypeGuards.isToolCallResults = isToolCallResults;
    function isTextStream(value) {
        return value instanceof stream_1.TextStream;
    }
    TypeGuards.isTextStream = isTextStream;
    function isContentStream(value) {
        return value instanceof stream_1.ContentStream;
    }
    TypeGuards.isContentStream = isContentStream;
    function isTTSOutputStream(value) {
        return value instanceof stream_1.TTSOutputStream;
    }
    TypeGuards.isTTSOutputStream = isTTSOutputStream;
    function isSpeechChunkStream(value) {
        return value instanceof stream_1.SpeechChunkStream;
    }
    TypeGuards.isSpeechChunkStream = isSpeechChunkStream;
    /**
     * Helper function to check if a value is one of the known typed classes
     * @internal
     */
    function hasKnownType(value) {
        return (value instanceof classification_result_1.ClassificationResult ||
            value instanceof content_1.Content ||
            value instanceof goal_advancement_1.GoalAdvancement ||
            value instanceof knowledge_records_1.KnowledgeRecords ||
            value instanceof list_tools_1.ListTools ||
            value instanceof llm_chat_request_1.LLMChatRequest ||
            value instanceof matched_intents_1.MatchedIntents ||
            value instanceof matched_keywords_1.MatchedKeywords ||
            value instanceof memory_state_1.MemoryState ||
            value instanceof tool_call_results_1.ToolCallResults ||
            value instanceof stream_1.TextStream ||
            value instanceof stream_1.ContentStream ||
            value instanceof stream_1.TTSOutputStream ||
            value instanceof stream_1.SpeechChunkStream);
    }
})(TypeGuards || (exports.TypeGuards = TypeGuards = {}));
/**
 * Helper function to get a human-readable type name for CustomNodeInputTypes
 */
function getTypeName(value) {
    if (TypeGuards.isString(value))
        return 'string';
    if (TypeGuards.isClassificationResult(value))
        return 'ClassificationResult';
    if (TypeGuards.isContent(value))
        return 'Content';
    if (TypeGuards.isGoalAdvancement(value))
        return 'GoalAdvancement';
    if (TypeGuards.isKnowledgeRecords(value))
        return 'KnowledgeRecords';
    if (TypeGuards.isListTools(value))
        return 'ListTools';
    if (TypeGuards.isLLMChatRequest(value))
        return 'LLMChatRequest';
    if (TypeGuards.isMatchedIntents(value))
        return 'MatchedIntents';
    if (TypeGuards.isMatchedKeywords(value))
        return 'MatchedKeywords';
    if (TypeGuards.isMemoryState(value))
        return 'MemoryState';
    if (TypeGuards.isToolCallResults(value))
        return 'ToolCallResults';
    if (TypeGuards.isTextStream(value))
        return 'TextStream';
    if (TypeGuards.isContentStream(value))
        return 'ContentStream';
    if (TypeGuards.isTTSOutputStream(value))
        return 'TTSOutputStream';
    if (TypeGuards.isSpeechChunkStream(value))
        return 'SpeechChunkStream';
    if (TypeGuards.isCustom(value))
        return 'Custom';
    return 'unknown';
}
/**
 * Helper function to process graph output stream responses with type safety.
 * This function makes it easy to handle different response types in a switch-like pattern.
 *
 * @param value - The response data to process
 * @param handlers - Object containing handler functions for each type
 * @returns The result from the appropriate handler
 *
 * @example
 * ```typescript
 * const result = processResponse(response.data, {
 *   string: (text) => `Got text: ${text}`,
 *   Custom: (custom) => `Got custom data: ${JSON.stringify(custom)}`,
 *   TextStream: async (stream) => {
 *     // Handle stream...
 *     return "Processed stream";
 *   },
 *   // Add other handlers as needed
 *   default: (value) => `Unknown type: ${getTypeName(value)}`
 * });
 * ```
 */
function processGraphOutputResponse(value, handlers) {
    if (!value)
        return undefined;
    if (TypeGuards.isString(value) && handlers.string) {
        return handlers.string(value);
    }
    if (TypeGuards.isCustom(value) && handlers.Custom) {
        return handlers.Custom(value);
    }
    if (TypeGuards.isClassificationResult(value) &&
        handlers.ClassificationResult) {
        return handlers.ClassificationResult(value);
    }
    if (TypeGuards.isContent(value) && handlers.Content) {
        return handlers.Content(value);
    }
    if (TypeGuards.isGoalAdvancement(value) && handlers.GoalAdvancement) {
        return handlers.GoalAdvancement(value);
    }
    if (TypeGuards.isKnowledgeRecords(value) && handlers.KnowledgeRecords) {
        return handlers.KnowledgeRecords(value);
    }
    if (TypeGuards.isListTools(value) && handlers.ListTools) {
        return handlers.ListTools(value);
    }
    if (TypeGuards.isLLMChatRequest(value) && handlers.LLMChatRequest) {
        return handlers.LLMChatRequest(value);
    }
    if (TypeGuards.isMatchedIntents(value) && handlers.MatchedIntents) {
        return handlers.MatchedIntents(value);
    }
    if (TypeGuards.isMatchedKeywords(value) && handlers.MatchedKeywords) {
        return handlers.MatchedKeywords(value);
    }
    if (TypeGuards.isMemoryState(value) && handlers.MemoryState) {
        return handlers.MemoryState(value);
    }
    if (TypeGuards.isToolCallResults(value) && handlers.ToolCallResults) {
        return handlers.ToolCallResults(value);
    }
    if (TypeGuards.isTextStream(value) && handlers.TextStream) {
        return handlers.TextStream(value);
    }
    if (TypeGuards.isContentStream(value) && handlers.ContentStream) {
        return handlers.ContentStream(value);
    }
    if (TypeGuards.isTTSOutputStream(value) && handlers.TTSOutputStream) {
        return handlers.TTSOutputStream(value);
    }
    if (TypeGuards.isSpeechChunkStream(value) && handlers.SpeechChunkStream) {
        return handlers.SpeechChunkStream(value);
    }
    if (handlers.default) {
        return handlers.default(value);
    }
    return undefined;
}
