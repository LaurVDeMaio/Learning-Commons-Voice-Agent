"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListToolsResponseData = void 0;
const expose_binary_1 = require("../../../expose_binary");
const messages_1 = require("../../vector/messages");
const base_data_1 = require("./base_data");
const json_data_1 = require("./json_data");
/**
 * Class for handling result of listing MCP tools in graphs.
 * Extends BaseData with tools list-specific functionality.
 * @internal
 */
class ListToolsResponseData extends base_data_1.BaseData {
    constructor(external) {
        super(external);
    }
    static fromToolInterfaces(tools) {
        const vectorToolData = expose_binary_1.VectorToolDataFunctions.new();
        tools.forEach((toolInterface) => {
            const tool = messages_1.Tool.fromToolInterface(toolInterface);
            const toolData = expose_binary_1.ToolDataFunctions.new(tool.getExternal());
            expose_binary_1.VectorToolDataFunctions.pushBack(vectorToolData, toolData);
            tool.destroy();
        });
        const external = expose_binary_1.ListToolsDataFunctions.new(vectorToolData);
        expose_binary_1.VectorToolDataFunctions.delete(vectorToolData);
        return new ListToolsResponseData(external);
    }
    /**
     * @internal
     * Creates a new ListToolsResponseData instance from an external reference.
     *
     * @param {ExternalReference} external - The external reference to create the instance from
     * @returns {ListToolsResponseData | null} A new ListToolsResponseData instance or null if invalid
     */
    static fromExternal(external) {
        const baseData = expose_binary_1.ListToolsDataFunctions.toListToolsData(external);
        if (baseData && expose_binary_1.ListToolsDataFunctions.isValid(baseData)) {
            return new ListToolsResponseData(baseData);
        }
        return null;
    }
    /**
     * Gets the tools list as an interface.
     * If external is set, it will parse from the external reference,
     * else it will return the tools array
     *
     * @returns {ListToolsResponseInterface} The tools list interface object
     */
    getListTools() {
        if (this.external) {
            // Parse from external reference
            const tools = [];
            const vectorToolData = expose_binary_1.ListToolsDataFunctions.getListToolsSwig(this.external);
            if (!expose_binary_1.VectorToolDataFunctions.isEmpty(vectorToolData)) {
                const size = expose_binary_1.VectorToolDataFunctions.size(vectorToolData);
                for (let i = 0; i < size; i++) {
                    const toolData = expose_binary_1.VectorToolDataFunctions.get(vectorToolData, i);
                    const tool = expose_binary_1.ToolDataFunctions.getTool(toolData);
                    let properties = {};
                    const propertiesString = expose_binary_1.ToolFunctions.getPropertiesAsString(tool);
                    if (propertiesString) {
                        const jsonData = new json_data_1.JsonData(propertiesString);
                        properties = jsonData.getData();
                        jsonData.destroy();
                    }
                    const toolInterface = {
                        name: expose_binary_1.ToolFunctions.getName(tool),
                        description: expose_binary_1.ToolFunctions.getDescription(tool) || '',
                        properties: properties,
                    };
                    tools.push(toolInterface);
                }
            }
            return { tools: tools };
        }
        return {
            tools: [],
        };
    }
    /**
     * Checks if the ListToolsResponseData is valid.
     *
     * @returns {boolean} True if valid, false otherwise
     */
    isValid() {
        return expose_binary_1.ListToolsDataFunctions.isValid(this.external);
    }
    /**
     * Cleans up resources used by the ListToolsResponseData instance.
     */
    destroy() {
        super.destroy();
    }
}
exports.ListToolsResponseData = ListToolsResponseData;
