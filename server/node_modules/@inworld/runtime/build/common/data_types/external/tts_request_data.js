"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TTSRequestData = void 0;
const expose_binary_1 = require("../../../expose_binary");
const voice_1 = require("../../voice/voice");
const base_data_1 = require("./base_data");
const text_data_1 = require("./text_data");
/**
 * Class for handling TTS requests in graphs.
 * Extends BaseData with TTS request-specific functionality.
 */
class TTSRequestData extends base_data_1.BaseData {
    constructor(requestOrExternal, voice) {
        // Compute external reference first
        let external;
        let initData;
        if (typeof requestOrExternal === 'string') {
            external = TTSRequestData.createFromString(requestOrExternal, voice);
            initData = {
                textData: new text_data_1.TextData(requestOrExternal),
                voice: voice,
                contentType: 'text',
                voiceObj: voice ? new voice_1.Voice(voice) : undefined,
            };
        }
        else if (TTSRequestData.isTTSRequestInterface(requestOrExternal)) {
            const result = TTSRequestData.createFromInterface(requestOrExternal);
            external = result.external;
            initData = {
                textData: result.textData,
                streamData: result.streamData,
                voice: requestOrExternal.voice,
                voiceObj: result.voiceObj,
                contentType: requestOrExternal.contentType,
            };
        }
        else {
            // Handle ExternalReference case
            external = requestOrExternal;
            initData = {
                contentType: 'text', // Default assumption
            };
        }
        // Call super first
        super(external);
        this.textData = null;
        this.streamData = null;
        // Then initialize instance properties
        this.textData = initData.textData || null;
        this.streamData = initData.streamData || null;
        this.voice = initData.voice;
        this.voiceObj = initData.voiceObj;
        this.contentType = initData.contentType;
    }
    /**
     * Type guard to check if object is TTSRequestInterface
     */
    static isTTSRequestInterface(obj) {
        return (typeof obj === 'object' &&
            obj !== null &&
            'contentType' in obj &&
            (obj.contentType === 'text' || obj.contentType === 'stream'));
    }
    /**
     * Creates TTSRequest from string input
     */
    static createFromString(text, voice) {
        return TTSRequestData.withOptionalVoice(voice, (optionalVoice) => {
            return expose_binary_1.TTSRequestFunctions.newWithString(text, optionalVoice);
        });
    }
    /**
     * Creates TTSRequest from TTSRequestInterface
     */
    static createFromInterface(request) {
        if (request.contentType === 'text' && request.text) {
            const external = TTSRequestData.withOptionalVoice(request.voice, (optionalVoice) => {
                return expose_binary_1.TTSRequestFunctions.newWithString(request.text, optionalVoice);
            });
            return {
                external,
                textData: new text_data_1.TextData(request.text),
                streamData: null,
                voiceObj: request.voice ? new voice_1.Voice(request.voice) : undefined,
            };
        }
        else if (request.contentType === 'stream' && request.stream) {
            const external = TTSRequestData.withOptionalVoice(request.voice, (optionalVoice) => {
                // Wrap the stream into DataStream first
                const dataStream = expose_binary_1.StreamStringFunctions.new(request.stream.getStream(), null);
                return expose_binary_1.TTSRequestFunctions.newWithDataStream(dataStream, optionalVoice);
            });
            return {
                external,
                textData: null,
                streamData: null, // Simplified for now
                voiceObj: request.voice ? new voice_1.Voice(request.voice) : undefined,
            };
        }
        else {
            throw new Error(`Invalid TTSRequest configuration: contentType=${request.contentType}`);
        }
    }
    /**
     * Helper method to safely handle optional voice creation and cleanup
     */
    static withOptionalVoice(voice, fn) {
        let optionalVoice = null;
        let voiceObj = null;
        try {
            if (voice) {
                voiceObj = new voice_1.Voice(voice);
                optionalVoice = expose_binary_1.OptionalVoiceFunctions.newWithValue(voiceObj.getExternal());
            }
            else {
                optionalVoice = expose_binary_1.OptionalVoiceFunctions.new();
            }
            return fn(optionalVoice);
        }
        finally {
            // Always cleanup optional voice
            if (optionalVoice) {
                expose_binary_1.OptionalVoiceFunctions.delete(optionalVoice);
            }
            // Don't cleanup voiceObj here - it will be managed by the TTSRequestData instance
        }
    }
    /**
     * @internal
     * Creates a new TTSRequestData instance from an external reference.
     *
     * @param {ExternalReference} external - The external reference to create the instance from
     * @returns {TTSRequestData | null} A new TTSRequestData instance or null if invalid
     */
    static fromExternal(external) {
        if (external && expose_binary_1.TTSRequestFunctions.isValid(external)) {
            return new TTSRequestData(external);
        }
        return null;
    }
    /**
     * Gets the TTSRequest data as an interface.
     * If external is set, it will parse the external reference,
     * else it will use the stored properties
     *
     * @returns {TTSRequestInterface} The TTSRequest interface object
     */
    getTTSRequest() {
        var _a, _b, _c;
        // If we have stored properties (from TTSRequestInterface constructor), use them
        if (this.textData && this.contentType === 'text') {
            return {
                contentType: 'text',
                text: this.textData.getText(),
                voice: this.voice,
            };
        }
        if (this.streamData && this.contentType === 'stream') {
            return {
                contentType: 'stream',
                stream: this.streamData.getStream(),
                voice: this.voice,
            };
        }
        // Otherwise, try to parse from external reference
        if (this.external) {
            const hasTextContent = expose_binary_1.TTSRequestFunctions.hasTextContent(this.external);
            const hasStreamContent = expose_binary_1.TTSRequestFunctions.hasStreamContent(this.external);
            if (hasTextContent) {
                return {
                    contentType: 'text',
                    text: ((_a = this.textData) === null || _a === void 0 ? void 0 : _a.getText()) || '',
                    voice: this.voice,
                };
            }
            else if (hasStreamContent) {
                return {
                    contentType: 'stream',
                    stream: (_b = this.streamData) === null || _b === void 0 ? void 0 : _b.getStream(),
                    voice: this.voice,
                };
            }
        }
        // Fallback
        return {
            contentType: 'text',
            text: ((_c = this.textData) === null || _c === void 0 ? void 0 : _c.getText()) || '',
            voice: this.voice,
        };
    }
    /**
     * Checks if the TTSRequest has text content.
     *
     * @returns {boolean} True if the request contains text content
     */
    hasTextContent() {
        if (this.external) {
            return expose_binary_1.TTSRequestFunctions.hasTextContent(this.external);
        }
        return this.contentType === 'text' && !!this.textData;
    }
    /**
     * Checks if the TTSRequest has stream content.
     *
     * @returns {boolean} True if the request contains stream content
     */
    hasStreamContent() {
        if (this.external) {
            return expose_binary_1.TTSRequestFunctions.hasStreamContent(this.external);
        }
        return this.contentType === 'stream' && !!this.streamData;
    }
    /**
     * Gets the voice configuration.
     *
     * @returns {VoiceInterface | undefined} The voice configuration if available
     */
    getVoice() {
        return this.voice;
    }
    /**
     * Cleans up resources used by the TTSRequestData instance.
     */
    destroy() {
        var _a, _b;
        (_a = this.textData) === null || _a === void 0 ? void 0 : _a.destroy();
        this.textData = null;
        // Note: TextStream has its own cleanup mechanism
        this.streamData = null;
        (_b = this.voiceObj) === null || _b === void 0 ? void 0 : _b.destroy();
        this.voiceObj = undefined;
        this.voice = undefined;
        super.destroy();
    }
}
exports.TTSRequestData = TTSRequestData;
