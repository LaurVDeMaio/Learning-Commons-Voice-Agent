"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntentMatcher = void 0;
const common_1 = require("../../common");
const inworld_1 = require("../../common/error/inworld");
const helpers_1 = require("../../common/helpers");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for intent matching functionality.
 * Provides methods to detect intents in user input text using multiple strategies:
 * - Strict matching (exact phrase matching)
 * - Embedding-based semantic matching
 * - LLM-based classification
 */
class IntentMatcher {
    /**
     * Creates a new IntentMatcher instance.
     *
     * @param external - External reference to the native intent matcher implementation
     * @internal
     */
    constructor(external) {
        this.external = null;
        this.external = external;
    }
    /**
     * Matches intents in the provided input text.
     * Returns matches sorted by confidence score (highest first).
     *
     * @param input - Text to analyze for intents
     * @returns Promise resolving to an array of intent matches
     * @throws InworldError if intent matching fails or matcher is not initialized
     */
    async matchIntents(input) {
        if (!this.isInitialized()) {
            throw new inworld_1.InworldError('IntentMatcher is not properly initialized or has been destroyed.');
        }
        if (!input || input.trim().length === 0) {
            return [];
        }
        let statusMatches;
        let matches = [];
        try {
            statusMatches = await expose_binary_1.IntentMatcherInterfaceFunctions.matchIntents(this.external, input);
            if (!expose_binary_1.StatusOrVectorIntentMatchFunctions.isOK(statusMatches)) {
                throw new inworld_1.InworldError('Failed to match intents', (0, helpers_1.getStatus)(statusMatches));
            }
            const matchesVectorRef = expose_binary_1.StatusOrVectorIntentMatchFunctions.getValue(statusMatches);
            matches = common_1.VectorIntentMatch.toArray(matchesVectorRef);
        }
        finally {
            if (statusMatches) {
                expose_binary_1.StatusOrVectorIntentMatchFunctions.delete(statusMatches);
            }
        }
        return matches;
    }
    /**
     * Returns the external reference to the native intent matcher implementation.
     *
     * @returns External reference object
     * @internal
     */
    getExternal() {
        return this.external;
    }
    /**
     * Checks if the intent matcher is properly initialized and ready for use.
     *
     * @returns True if the matcher is initialized, false otherwise
     */
    isInitialized() {
        return this.external !== null;
    }
    /**
     * Cleans up resources associated with this intent matcher.
     * Should be called when the matcher is no longer needed to prevent memory leaks.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.IntentMatcherInterfaceFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.IntentMatcher = IntentMatcher;
