"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TTS = void 0;
const common_1 = require("../../common");
const stream_1 = require("../../common/stream");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for text-to-speech processing.
 * Provides functionality to convert text into synthesized speech audio.
 */
class TTS {
    /**
     * Creates a new TTS instance.
     *
     * @param tts - External reference to the native TTS implementation
     * @internal
     */
    constructor(tts) {
        this.tts = tts;
    }
    /**
     * Returns the external reference to the native TTS implementation.
     *
     * @returns External reference object
     * @internal
     */
    getExternal() {
        return this.tts;
    }
    /**
     * Synthesizes speech from text using a specified voice.
     *
     * @param voice - Voice configuration or speaker ID string
     * @param text - Text to convert to speech
     * @returns A stream iterator for the synthesized audio chunks
     * @throws InworldError if speech synthesis fails
     */
    async synthesizeSpeech(voice, text) {
        return this.synthesizeSpeechWithInput(voice, { text });
    }
    /**
     * Synthesizes speech from input using a specified voice.
     * @private
     * @param voice - Voice configuration or speaker ID string
     * @param input - Speech synthesis input containing text and optional instruction
     * @returns A stream iterator for the synthesized audio chunks
     * @throws InworldError if speech synthesis fails
     */
    async synthesizeSpeechWithInput(voiceConfig, input) {
        let voiceObj = null;
        let iterator;
        try {
            // Create and configure the Voice object
            voiceObj = new common_1.Voice(voiceConfig);
            // Call the synthesizeSpeech function with or without instruction
            const ttsStreamStatus = input.instruction
                ? await expose_binary_1.TTSInterfaceFunctions.synthesizeSpeechWithInstruction(this.tts, voiceObj.getExternal(), input.text, input.instruction)
                : await expose_binary_1.TTSInterfaceFunctions.synthesizeSpeech(this.tts, voiceObj.getExternal(), input.text);
            const inputStream = expose_binary_1.SpeechChunkInputStreamFunctions.getStream(ttsStreamStatus);
            iterator = this.streamIterator(ttsStreamStatus, inputStream);
        }
        finally {
            if (voiceObj) {
                voiceObj.destroy();
            }
        }
        return iterator;
    }
    /**
     * Creates a stream iterator for processing synthesized speech chunks.
     *
     * @param statusOrInputStreamSpeechChunk - Status of the speech synthesis
     * @param inputStream - Input stream containing speech chunks
     * @returns Stream iterator for accessing audio chunks
     * @private
     */
    streamIterator(statusOrInputStreamSpeechChunk, inputStream) {
        const speechChunkStream = new stream_1.SpeechChunkStream(inputStream, () => {
            expose_binary_1.SpeechChunkInputStreamFunctions.delete(statusOrInputStreamSpeechChunk);
        });
        return {
            getStream() {
                return speechChunkStream.getStream();
            },
            async next() {
                return speechChunkStream.next();
            },
        };
    }
    /**
     * Cleans up resources associated with this TTS instance.
     */
    destroy() {
        if (this.tts) {
            expose_binary_1.TTSInterfaceFunctions.delete(this.tts);
            this.tts = null;
        }
    }
}
exports.TTS = TTS;
