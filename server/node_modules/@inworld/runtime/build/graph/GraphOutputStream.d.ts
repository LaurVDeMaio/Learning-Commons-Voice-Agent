import { ExternalReference } from '../common/data_types/common';
import { GraphExecutor } from './GraphExecutor';
import { GraphOutputStreamResponse } from './GraphOutputStreamResponse';
import { GraphOutputStreamDataType } from './nodes/types';
/**
 * Represents a handler for a graph execution.
 */
export declare class GraphOutputStream {
    /**
     * The index of the execution.
     */
    readonly index: number;
    /**
     * The execution ID.
     */
    private readonly executionId;
    /**
     * The graph executor associated with the execution.
     * @internal
     */
    private graphExecutor;
    /**
     * The data associated with the execution.
     */
    private data;
    /**
     * Optional callback to call when the stream is finished
     * @internal
     */
    private onStreamFinished?;
    /**
     * Creates a new GraphOutputStream instance.
     * @param index - The index of the execution
     * @param graphExecutor - The graph executor associated with the execution
     * @internal
     */
    constructor(graphExecutor: GraphExecutor, index: number, executionId: string, data: ExternalReference);
    /**
     * Handles the response from a node.
     * @returns A promise that resolves to the response from the node
     */
    next(): Promise<GraphOutputStreamResponse<GraphOutputStreamDataType>>;
    /**
     * Sets a callback to be called when the stream is finished.
     * This allows automatic cleanup without user intervention.
     *
     * @param callback - Function to call when stream ends
     */
    setOnFinished(callback: () => void): void;
    /**
     * Enables async iteration over graph output responses.
     */
    [Symbol.asyncIterator](): AsyncIterator<GraphOutputStreamResponse<GraphOutputStreamDataType>>;
    /**
     * Checks the status of data and throws an error if there's a problem.
     *
     * @param data - External reference to the data to check
     * @throws InworldError if the data contains an error status
     */
    private checkStatus;
}
