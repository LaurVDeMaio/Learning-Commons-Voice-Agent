import { AbstractComponent } from '../../components/abstract_component';
import { Node as GraphConfigNode } from '../../graph_config_schema';
export declare const INTERNAL_COMPONENTS: unique symbol;
export declare const TO_GRAPH_CONFIG_NODE: unique symbol;
/**
 * Base configuration for any graph node.
 */
export interface AbstractNodeProps {
    id?: string;
    reportToClient?: boolean;
}
/**
 * Abstract base class for all graph nodes.
 *
 * Provides common functionality such as ID generation, tracking of internal
 * components, and conversion to a graph configuration node.
 */
export declare abstract class AbstractNode {
    private static nodesByTypeCounter;
    protected reportToClient: boolean;
    id: string;
    [INTERNAL_COMPONENTS]: AbstractComponent[];
    /**
     * Creates a new `AbstractNode`.
     *
     * @param props - Node configuration with optional explicit `id` and
     *                `reportToClient` flag.
     */
    constructor(props: AbstractNodeProps);
    private static getId;
    /**
     * Adds an internal component to this node.
     *
     * @param component - The component to attach to this node.
     * @returns This node instance.
     */
    protected addComponent(component: AbstractComponent): this;
    /**
     * Returns the first internal component attached to this node.
     *
     * @throws {InworldError} If no components were added to the node.
     */
    protected getFirstComponent(): AbstractComponent;
    /**
     * Converts this DSL node to a serializable graph configuration node.
     *
     * Note: This indirection through a symbol preserves encapsulation while
     * still allowing builder utilities to access the conversion.
     */
    [TO_GRAPH_CONFIG_NODE](): GraphConfigNode;
    /**
     * Implemented by subclasses to provide their graph configuration
     * representation.
     */
    protected abstract toGraphConfigNode(): GraphConfigNode;
}
