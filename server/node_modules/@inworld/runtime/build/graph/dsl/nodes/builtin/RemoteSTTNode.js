"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteSTTNode = void 0;
const RemoteSTTComponent_1 = require("../../components/RemoteSTTComponent");
const constants_1 = require("../../constants");
const snakify_1 = __importDefault(require("../../utils/snakify"));
const AbstractNode_1 = require("./AbstractNode");
/**
 * Remote STT (Speech-to-Text) node for audio transcription.
 * You can either use a pre-configured STT component that could be reused across multiple nodes
 * or provide STT configuration, and the node will create a new component for you.
 *
 * @input {AudioData} {@link AudioData} - The data type that STTNode accepts as input
 * @output {TextData} {@link TextData} - The data type that STTNode accepts as output
 *
 * @example
 * ```typescript
 * // Using provider configuration
 * const sttNode = new RemoteSTTNode({
 *   id: 'my-stt-node',
 *   sttConfig: { language: { lang: 'en', locale: 'US' } }
 * });
 *
 * // Using existing STT component
 * const sttNodeWithComponent = new RemoteSTTNode({
 *   id: 'my-stt-node',
 *   sttComponent: existingSTTComponent
 * });
 * ```
 */
class RemoteSTTNode extends AbstractNode_1.AbstractNode {
    /**
     * Creates a new RemoteSTTNode instance.
     *
     * @param props - Configuration for the STT node. Can specify either STT settings
     *                or reference an existing STT component.
     */
    constructor(props) {
        var _a, _b;
        super(props !== null && props !== void 0 ? props : {});
        this.executionConfig = {
            sttComponentId: '',
            reportToClient: (_a = props === null || props === void 0 ? void 0 : props.reportToClient) !== null && _a !== void 0 ? _a : false,
        };
        let sttComponent;
        if (props && 'sttComponent' in props) {
            sttComponent = props.sttComponent;
        }
        else {
            const input = (_b = props === null || props === void 0 ? void 0 : props.sttConfig) !== null && _b !== void 0 ? _b : {};
            const merged = Object.assign(Object.assign(Object.assign({}, constants_1.DEFAULT_SPEECH_RECOGNITION_CONFIG), input), { language: Object.assign(Object.assign({}, constants_1.DEFAULT_SPEECH_RECOGNITION_CONFIG.language), input.language) });
            sttComponent = new RemoteSTTComponent_1.RemoteSTTComponent({
                id: `${this.id}_stt_component`,
                sttConfig: merged,
            });
        }
        this.executionConfig.sttComponentId = sttComponent.id;
        this.addComponent(sttComponent);
    }
    /**
     * Converts the STT node to a graph configuration node.
     *
     * @returns The configured STT node for graph execution
     */
    toGraphConfigNode() {
        return {
            id: this.id,
            type: 'STTNode',
            execution_config: {
                type: 'STTNodeExecutionConfig',
                properties: (0, snakify_1.default)(this.executionConfig),
            },
        };
    }
}
exports.RemoteSTTNode = RemoteSTTNode;
