type ClassReference<T extends BaseInputType> = new (...args: any[]) => T;
declare class BaseInputType {
    name: string;
    constructor(name: string);
}
declare const MyCustomInput: new (opts?: {
    test1: string;
}) => BaseInputType & {
    test1: string;
};
declare class InputType extends BaseInputType {
    name: string;
    private static _brand;
    test: string;
    constructor(name: string);
}
declare class InputType2 extends BaseInputType {
    name: string;
    private static _brand;
    test: string;
    constructor(name: string);
}
declare class InputType3 extends BaseInputType {
    name: string;
    private static _brand;
    test: string;
    constructor(name: string);
}
declare const _InputTypesList: readonly [typeof InputType3, typeof InputType2, StringConstructor, new (opts?: {
    test1: string;
}) => BaseInputType & {
    test1: string;
}];
declare const _OutputTypeList: readonly [StringConstructor, typeof InputType];
type AllowedInput = (typeof _InputTypesList)[number];
type AllowedOutput = (typeof _OutputTypeList)[number];
type InstanceTypes<T extends readonly AllowedInput[]> = {
    -readonly [P in keyof T]: T[P] extends StringConstructor ? string : T[P] extends ClassReference<BaseInputType> ? InstanceType<T[P]> : never;
};
declare abstract class TestNode {
    abstract readonly inputTypes: readonly AllowedInput[];
    abstract readonly outputType: AllowedOutput;
    abstract process(...inputs: InstanceTypes<this['inputTypes']>): BaseInputType | string;
}
export declare class TestNodeTest extends TestNode {
    readonly inputTypes: readonly [typeof InputType2, StringConstructor, new (opts?: {
        test1: string;
    }) => BaseInputType & {
        test1: string;
    }];
    readonly outputType: StringConstructor;
    process(input: InputType2, input2: string, input3: InstanceType<typeof MyCustomInput>): string;
}
export {};
