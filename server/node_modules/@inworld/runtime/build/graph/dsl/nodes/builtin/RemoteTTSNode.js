"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteTTSNode = void 0;
const RemoteTTSComponent_1 = require("../../components/RemoteTTSComponent");
const constants_1 = require("../../constants");
const snakify_1 = __importDefault(require("../../utils/snakify"));
const AbstractNode_1 = require("./AbstractNode");
/**
 * Remote TTS (Text-to-Speech) node for audio synthesis.
 * You can either use a pre-configured TTS component that could be reused across multiple nodes
 * or provide synthesis configuration, and the node will create a new component for you.
 *
 * @input {TextData | TextStreamData | TTSRequestData} {@link TextData} | {@link TextStreamData} | {@link TTSRequestData} - The data type that TTSNode accepts as input
 * @output {TTSOutputData} {@link TTSOutputData} - The data type that TTSNode accepts as output
 *
 * @example
 * ```typescript
 * // Using provider configuration
 * const ttsNode = new RemoteTTSNode({
 *   id: 'my-tts-node',
 *   synthesisConfig: {
 *     type: 'inworld',
 *     config: { inference: { temperature: 1.0 } }
 *   }
 * });
 *
 * // Using existing TTS component
 * const ttsNodeWithComponent = new RemoteTTSNode({
 *   id: 'my-tts-node',
 *   ttsComponent: existingTTSComponent
 * });
 * ```
 */
class RemoteTTSNode extends AbstractNode_1.AbstractNode {
    mergeSynthesisConfigWithDefault(input) {
        var _a;
        return {
            type: constants_1.DEFAULT_SPEECH_SYNTHESIS_CONFIG.type,
            config: {
                modelId: (_a = input === null || input === void 0 ? void 0 : input.modelId) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_SPEECH_SYNTHESIS_CONFIG.config.model_id,
                inference: Object.assign(Object.assign(Object.assign({}, constants_1.DEFAULT_SPEECH_SYNTHESIS_CONFIG.config.inference), ((input === null || input === void 0 ? void 0 : input.temperature) ? { temperature: input.temperature } : {})), ((input === null || input === void 0 ? void 0 : input.speakingRate) ? { speakingRate: input.speakingRate } : {})),
                postprocessing: Object.assign(Object.assign({}, constants_1.DEFAULT_SPEECH_SYNTHESIS_CONFIG.config.postprocessing), ((input === null || input === void 0 ? void 0 : input.sampleRate) ? { sampleRate: input.sampleRate } : {})),
            },
        };
    }
    /**
     * Creates a new RemoteTTSNode instance.
     *
     * @param props - Configuration for the TTS node. Can specify either synthesis settings
     *                or reference an existing TTS component, but not both.
     */
    constructor(props) {
        var _a, _b, _c;
        super(props !== null && props !== void 0 ? props : {});
        this.executionConfig = {
            ttsComponentId: '',
            voice: {
                speakerId: (_a = props === null || props === void 0 ? void 0 : props.speakerId) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_TTS_VOICE.speaker_id,
                languageCode: (_b = props === null || props === void 0 ? void 0 : props.languageCode) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TTS_VOICE.language_code,
            },
            synthesisConfig: this.mergeSynthesisConfigWithDefault(props),
            reportToClient: (_c = props === null || props === void 0 ? void 0 : props.reportToClient) !== null && _c !== void 0 ? _c : false,
        };
        let ttsComponent;
        if (props && 'ttsComponent' in props) {
            ttsComponent = props.ttsComponent;
        }
        else {
            ttsComponent = new RemoteTTSComponent_1.RemoteTTSComponent({
                id: `${this.id}_tts_component`,
                synthesisConfig: this.mergeSynthesisConfigWithDefault(props),
            });
        }
        this.executionConfig.ttsComponentId = ttsComponent.id;
        this.addComponent(ttsComponent);
    }
    /**
     * Converts the TTS node to a graph configuration node.
     *
     * @returns The configured TTS node for graph execution
     */
    toGraphConfigNode() {
        return {
            id: this.id,
            type: 'TTSNode',
            execution_config: {
                type: 'TTSNodeExecutionConfig',
                properties: (0, snakify_1.default)(this.executionConfig),
            },
        };
    }
}
exports.RemoteTTSNode = RemoteTTSNode;
