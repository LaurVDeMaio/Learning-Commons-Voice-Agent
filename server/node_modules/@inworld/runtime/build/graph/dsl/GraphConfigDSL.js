"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_PROVIDER = exports.DEFAULT_EMBEDDER_MODEL_NAME = exports.DEFAULT_LLM_MODEL_NAME = exports.DEFAULT_RETRIEVAL_CONFIG = exports.DEFAULT_INTENT_MATCHER_CONFIG = exports.DEFAULT_TEXT_CONFIG = exports.Graph = exports.SubgraphBuilder = exports.ComponentFactory = exports.NodeFactory = void 0;
const uuid_1 = require("uuid");
const graph_1 = require("../graph");
const snakify_1 = __importDefault(require("./utils/snakify"));
// Factory-style DSL similar to NodeFactory from runtime
class NodeFactory {
    // LLM Nodes
    static createRemoteLLMChatNode(config) {
        var _a, _b;
        if ('executionConfig' in config) {
            return {
                id: config.id,
                type: 'LLMChatNode',
                execution_config: {
                    type: 'LLMChatNodeExecutionConfig',
                    properties: Object.assign({}, (0, snakify_1.default)(config.executionConfig)),
                },
            };
        }
        else {
            return {
                id: config.id,
                type: 'LLMChatNode',
                execution_config: {
                    type: 'LLMChatNodeExecutionConfig',
                    properties: {
                        llm_component_id: `${config.id}_llm_component`,
                        text_generation_config: config.llmConfig.textGenerationConfig
                            ? (0, snakify_1.default)(config.llmConfig.textGenerationConfig)
                            : exports.DEFAULT_TEXT_CONFIG,
                        stream: (_a = config.llmConfig.stream) !== null && _a !== void 0 ? _a : false,
                        report_to_client: (_b = config.llmConfig.reportToClient) !== null && _b !== void 0 ? _b : false,
                    },
                },
                llmConfig: {
                    provider: config.llmConfig.provider,
                    modelName: config.llmConfig.modelName,
                    apiKey: config.llmConfig.apiKey,
                    textGenerationConfig: config.llmConfig.textGenerationConfig,
                },
            };
        }
    }
    static createRemoteLLMCompletionNode(config) {
        var _a, _b;
        if ('executionConfig' in config) {
            return {
                id: config.id,
                type: 'LLMCompletionNode',
                execution_config: {
                    type: 'LLMCompletionNodeExecutionConfig',
                    properties: Object.assign({}, (0, snakify_1.default)(config.executionConfig)),
                },
            };
        }
        else {
            return {
                id: config.id,
                type: 'LLMCompletionNode',
                execution_config: {
                    type: 'LLMCompletionNodeExecutionConfig',
                    properties: {
                        llm_component_id: `${config.id}_llm_component`,
                        text_generation_config: config.llmConfig.textGenerationConfig
                            ? (0, snakify_1.default)(config.llmConfig.textGenerationConfig)
                            : exports.DEFAULT_TEXT_CONFIG,
                        stream: (_a = config.llmConfig.stream) !== null && _a !== void 0 ? _a : false,
                        report_to_client: (_b = config.llmConfig.reportToClient) !== null && _b !== void 0 ? _b : false,
                    },
                },
                llmConfig: {
                    provider: config.llmConfig.provider,
                    modelName: config.llmConfig.modelName,
                    apiKey: config.llmConfig.apiKey,
                    textGenerationConfig: config.llmConfig.textGenerationConfig,
                },
            };
        }
    }
    // Intent Node
    static createIntentNode(config) {
        var _a;
        return {
            id: config.id,
            type: 'IntentNode',
            creation_config: {
                type: 'IntentNodeCreationConfig',
                properties: {
                    intents: config.intents,
                    embedder_component_id: config.embedderComponentId,
                    llm_component_id: config.llmComponentId,
                },
            },
            execution_config: {
                type: 'IntentNodeExecutionConfig',
                properties: {
                    matcher_config: (0, snakify_1.default)(config.matcherConfig) || exports.DEFAULT_INTENT_MATCHER_CONFIG,
                    report_to_client: (_a = config.reportToClient) !== null && _a !== void 0 ? _a : false,
                },
            },
        };
    }
    // Knowledge Node
    static createKnowledgeNode(config) {
        return {
            id: config.id,
            type: 'KnowledgeNode',
            creation_config: {
                type: 'KnowledgeNodeCreationConfig',
                properties: {
                    knowledge_id: config.knowledgeId,
                    knowledge_records: config.knowledgeRecords,
                    knowledge_component_id: config.knowledgeComponentId,
                },
            },
            execution_config: {
                type: 'KnowledgeNodeExecutionConfig',
                properties: {
                    knowledge_ids: [config.knowledgeId],
                    retrieval_config: (0, snakify_1.default)(config.retrievalConfig) || exports.DEFAULT_RETRIEVAL_CONFIG,
                },
            },
        };
    }
    // TTS Node
    static createRemoteTTSNode(config) {
        return {
            id: config.id,
            type: 'TTSNode',
            execution_config: {
                type: 'TTSNodeExecutionConfig',
                properties: {
                    tts_component_id: config.ttsComponentId,
                    voice: (0, snakify_1.default)(config.voice),
                    synthesis_config: (0, snakify_1.default)(config.synthesisConfig),
                },
            },
        };
    }
    // STT Node
    static createRemoteSTTNode(config) {
        return {
            id: config.id,
            type: 'STTNode',
            execution_config: {
                type: 'STTNodeExecutionConfig',
                properties: {
                    stt_component_id: config.sttComponentId,
                },
            },
        };
    }
    // Text Chunking Node
    static createTextChunkingNode(config) {
        return {
            id: config.id,
            type: 'TextChunkingNode',
            execution_config: {
                type: 'NodeExecutionConfig',
                properties: {
                    report_to_client: !!config.reportToClient,
                },
            },
        };
    }
    // Text Aggregator Node
    static createTextAggregatorNode(config) {
        return {
            id: config.id,
            type: 'TextAggregatorNode',
            execution_config: {
                type: 'NodeExecutionConfig',
                properties: {
                    report_to_client: !!config.reportToClient,
                },
            },
        };
    }
    // Random Canned Text Node
    static createRandomCannedTextNode(config) {
        return {
            id: config.id,
            type: 'RandomCannedTextNode',
            execution_config: {
                type: 'RandomCannedTextNodeExecutionConfig',
                properties: {
                    canned_phrases: config.cannedPhrases,
                },
            },
        };
    }
    // LLM Chat Request Builder Node
    static createLLMChatRequestBuilderNode(config) {
        return {
            id: config.id,
            type: 'LLMChatRequestBuilderNode',
            execution_config: {
                type: 'LLMChatRequestBuilderNodeExecutionConfig',
                properties: {
                    messages: config.messages,
                    tools: config.tools,
                    tool_choice: config.toolChoice,
                    response_format: config.responseFormat,
                    report_to_client: config.reportToClient,
                },
            },
        };
    }
    static createProxyNode(config) {
        return {
            id: config.id,
            type: 'ProxyNode',
            execution_config: {
                type: 'NodeExecutionConfig',
                properties: {
                    report_to_client: !!config.reportToClient,
                },
            },
        };
    }
    // MCP List Tools Node
    static createMCPListToolsNode(config) {
        var _a;
        return {
            id: config.id,
            type: 'MCPListToolsNode',
            execution_config: {
                type: 'MCPListToolsNodeExecutionConfig',
                properties: {
                    mcp_component_id: config.mcpComponentId,
                    report_to_client: (_a = config.reportToClient) !== null && _a !== void 0 ? _a : false,
                },
            },
        };
    }
    // MCP List Tools Node
    static createMCPCallToolNode(config) {
        var _a;
        return {
            id: config.id,
            type: 'MCPCallToolNode',
            execution_config: {
                type: 'MCPCallToolNodeExecutionConfig',
                properties: {
                    mcp_component_id: config.mcpComponentId,
                    report_to_client: (_a = config.reportToClient) !== null && _a !== void 0 ? _a : false,
                },
            },
        };
    }
    static createCustomNode(config) {
        const node = {
            id: config.id,
            type: config.type,
        };
        if (config.executionConfig) {
            node.execution_config = {
                type: 'CustomNodeExecutionConfig',
                properties: Object.assign({}, (0, snakify_1.default)(config.executionConfig)),
            };
        }
        return node;
    }
    // SubgraphNode
    static createSubgraphNode(config) {
        return {
            id: config.id,
            type: 'SubgraphNode',
            subgraph_id: config.subgraphId,
            parameters: config.parameters,
        };
    }
}
exports.NodeFactory = NodeFactory;
// Component Factory for creating components
class ComponentFactory {
    static createRemoteLLMComponent(config) {
        return {
            id: config.id,
            type: 'LLMInterface',
            creation_config: {
                type: 'RemoteLLMConfig',
                properties: {
                    provider: config.provider,
                    model_name: config.modelName,
                    api_key: config.apiKey,
                    default_config: config.defaultConfig
                        ? (0, snakify_1.default)(config.defaultConfig)
                        : exports.DEFAULT_TEXT_CONFIG,
                },
            },
        };
    }
    static createRemoteEmbedderComponent(config) {
        return {
            id: config.id,
            type: 'TextEmbedderInterface',
            creation_config: {
                type: 'RemoteTextEmbedderConfig',
                properties: {
                    provider: config.provider,
                    model_name: config.modelName,
                    api_key: config.apiKey,
                },
            },
        };
    }
    static createRemoteKnowledgeComponent(config) {
        return {
            id: config.id,
            type: 'KnowledgeInterface',
            creation_config: {
                type: 'RemoteKnowledgeConfig',
                properties: {
                    knowledge_compile_config: {
                        parsing_config: {
                            max_chars_per_chunk: config.maxCharsPerChunk || 1000,
                            max_chunks_per_document: config.maxChunksPerDocument || 10,
                        },
                    },
                    api_key: config.apiKey,
                },
            },
        };
    }
    static createRemoteSTTComponent(config) {
        return {
            id: config.id,
            type: 'STTInterface',
            creation_config: {
                type: 'RemoteSTTConfig',
                properties: (0, snakify_1.default)(config.sttConfig),
            },
        };
    }
    static createRemoteTTSComponent(config) {
        return {
            id: config.id,
            type: 'TTSInterface',
            creation_config: {
                type: 'RemoteTTSConfig',
                properties: {
                    api_key: config.apiKey,
                    synthesis_config: (0, snakify_1.default)(config.synthesisConfig),
                },
            },
        };
    }
    static createMCPClientComponent(config) {
        return {
            id: config.id,
            type: 'MCPClientInterface',
            creation_config: {
                type: 'MCPClientCreationConfig',
                properties: {
                    session_config: (0, snakify_1.default)(config.sessionConfig),
                },
            },
        };
    }
}
exports.ComponentFactory = ComponentFactory;
// Subgraph builder class
class SubgraphBuilder {
    constructor(id) {
        this.nodes = [];
        this.edges = [];
        this.subgraph = {
            id,
        };
    }
    // Add parameters to the subgraph
    addParameter(config) {
        if (!this.subgraph.parameters) {
            this.subgraph.parameters = [];
        }
        this.subgraph.parameters.push(config);
        return this;
    }
    // Add multiple parameters
    addParameters(parameters) {
        parameters.forEach((param) => this.addParameter(param));
        return this;
    }
    // Add a node to the subgraph
    addNode(node) {
        this.nodes.push(node);
        return this;
    }
    // Add an edge to the subgraph
    addEdge(fromNode, toNode, options) {
        const fromId = typeof fromNode === 'string' ? fromNode : fromNode.id;
        const toId = typeof toNode === 'string' ? toNode : toNode.id;
        const edge = {
            from_node: fromId,
            to_node: toId,
        };
        if (options === null || options === void 0 ? void 0 : options.conditionExpression) {
            edge.condition_expression = options.conditionExpression;
        }
        if ((options === null || options === void 0 ? void 0 : options.optional) !== undefined) {
            edge.optional = options.optional;
        }
        if ((options === null || options === void 0 ? void 0 : options.loop) !== undefined) {
            edge.loop = options.loop;
        }
        this.edges.push(edge);
        return this;
    }
    // Set the start node (subgraphs can only have one start node)
    setStartNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.startNode = nodeId;
        return this;
    }
    // Set the end node (subgraphs can only have one end node)
    setEndNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.endNode = nodeId;
        return this;
    }
    // Build the final subgraph
    build() {
        // Ensure we have at least one node
        if (this.nodes.length === 0) {
            throw new Error('Subgraph must have at least one node');
        }
        this.subgraph.nodes = this.nodes;
        this.subgraph.edges = this.edges.length > 0 ? this.edges : undefined;
        this.subgraph.start_nodes = this.startNode ? [this.startNode] : undefined;
        this.subgraph.end_nodes = this.endNode ? [this.endNode] : undefined;
        return this.subgraph;
    }
}
exports.SubgraphBuilder = SubgraphBuilder;
// Graph builder similar to the runtime Graph class
class Graph {
    constructor(id) {
        this.nodes = [];
        this.edges = [];
        this.components = [];
        this.subgraphs = [];
        this.startNodes = [];
        this.endNodes = [];
        this.config = {
            schema_version: '1.0.0',
            main: {
                id: id || (0, uuid_1.v4)(),
                nodes: [],
                edges: [],
                end_nodes: [],
            },
        };
    }
    // Add a subgraph to the graph
    addSubgraph(subgraph) {
        const finalSubgraph = subgraph instanceof SubgraphBuilder ? subgraph.build() : subgraph;
        this.subgraphs.push(finalSubgraph);
        return this;
    }
    addNode(node) {
        var _a;
        // process in-place component provisioning for llm node
        if ((node.type === 'LLMChatNode' || node.type === 'LLMCompletionNode') &&
            'llmConfig' in node) {
            const llmConfig = node.llmConfig;
            if (!this.components.find((c) => c.id === node.execution_config.properties.llm_component_id)) {
                this.addComponent(ComponentFactory.createRemoteLLMComponent({
                    apiKey: llmConfig.apiKey,
                    defaultConfig: (_a = llmConfig.textGenerationConfig) !== null && _a !== void 0 ? _a : exports.DEFAULT_TEXT_CONFIG,
                    id: node.execution_config.properties.llm_component_id,
                    modelName: llmConfig.modelName,
                    provider: llmConfig.provider,
                }));
            }
            delete node.llmConfig;
        }
        this.nodes.push(node);
        return this;
    }
    // Add edges (similar to runtime)
    addEdge(fromNode, toNode, options) {
        const fromId = typeof fromNode === 'string' ? fromNode : fromNode.id;
        const toId = typeof toNode === 'string' ? toNode : toNode.id;
        const edge = {
            from_node: fromId,
            to_node: toId,
        };
        if (options === null || options === void 0 ? void 0 : options.conditionExpression) {
            edge.condition_expression = options.conditionExpression;
        }
        if ((options === null || options === void 0 ? void 0 : options.optional) !== undefined) {
            edge.optional = options.optional;
        }
        if ((options === null || options === void 0 ? void 0 : options.loop) !== undefined) {
            edge.loop = options.loop;
        }
        this.edges.push(edge);
        return this;
    }
    // Add components
    addComponent(component) {
        this.components.push(component);
        return this;
    }
    // Set start/end nodes (similar to runtime)
    setStartNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.startNodes = [nodeId];
        return this;
    }
    setEndNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.endNodes = [nodeId];
        return this;
    }
    setStartNodes(nodes) {
        this.startNodes = nodes.map((n) => (typeof n === 'string' ? n : n.id));
        return this;
    }
    setEndNodes(nodes) {
        this.endNodes = nodes.map((n) => (typeof n === 'string' ? n : n.id));
        return this;
    }
    // Build the final configuration
    build() {
        this.config.main.nodes = this.nodes;
        this.config.main.edges = this.edges;
        this.config.main.start_nodes =
            this.startNodes.length > 0
                ? this.startNodes
                : undefined;
        this.config.main.end_nodes = this.endNodes;
        if (this.components.length > 0) {
            this.config.components = this.components;
        }
        if (this.subgraphs.length > 0) {
            this.config.subgraphs = this.subgraphs;
        }
        return this.config;
    }
    // Get JSON string (for compatibility with runtime Graph)
    toJSON() {
        return JSON.stringify(this.build(), null, 2);
    }
    getExecutor() {
        return new graph_1.Graph({
            jsonConfig: this.toJSON(),
        });
    }
}
exports.Graph = Graph;
// Default configurations
exports.DEFAULT_TEXT_CONFIG = {
    max_new_tokens: 2500,
    max_prompt_length: 100,
    repetition_penalty: 1,
    top_p: 1,
    temperature: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
    stop_sequences: ['\n\n'],
};
exports.DEFAULT_INTENT_MATCHER_CONFIG = {
    embedding: {
        similarity_threshold: 0.88,
    },
    llm: {
        generation_config: exports.DEFAULT_TEXT_CONFIG,
        prompt_template: '',
        embedding_similarity_threshold: 0.7,
        max_embedding_matches_for_llm: 5,
    },
    top_n_intents: 3,
};
exports.DEFAULT_RETRIEVAL_CONFIG = {
    threshold: 0.7,
    top_k: 5,
};
// Default model constants
exports.DEFAULT_LLM_MODEL_NAME = 'meta-llama/Llama-3.1-70b-Instruct';
exports.DEFAULT_EMBEDDER_MODEL_NAME = 'text-embedding-ada-002';
exports.DEFAULT_PROVIDER = 'inworld';
