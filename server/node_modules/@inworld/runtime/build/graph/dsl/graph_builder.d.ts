import { EdgeConditionCallback } from '../EdgeConditionExecutor';
import { Graph } from '../graph';
import { CustomEdgeConditionReference } from '../nodes/types';
import { AbstractComponent } from './components/abstract_component';
import { RemoteEmbedderComponent } from './components/remote_embedder_component';
import { RemoteLLMComponent } from './components/remote_llm_component';
import { Camelize } from './constants';
import { Component, Node, Subgraph, TextGenerationConfig } from './graph_config_schema';
import { AbstractNode, INTERNAL_COMPONENTS } from './nodes/builtin/abstract_node';
export type IntentSubgraphProps = {
    intents: {
        name: string;
        phrases: string[];
    }[];
    promptTemplate: string;
    llmComponent?: RemoteLLMComponent | {
        provider?: string;
        modelName?: string;
        defaultConfig?: Camelize<TextGenerationConfig>;
    };
    embedderComponent?: RemoteEmbedderComponent | {
        provider?: string;
        modelName?: string;
    };
    similarityThreshold?: number;
    textGenerationConfig?: Camelize<TextGenerationConfig>;
    maxIntentsForLLM?: number;
    maxPhrasesPerIntent?: number;
    embeddingSimilarityThreshold?: number;
    topNIntents?: number;
};
/**
 * Tool choice configuration for LLM chat request builder.
 * Can specify either a string type or a function with a name.
 *
 * For string values: "none", "auto", "required":
 *  - "none": the model will not call any tool and instead generates a message
 *  - "auto": the model can pick between generating a message or calling tools
 *  - "required": The model must call one or more tools
 * And function specifies a particular tool the model should use
 */
export type RequestBuilderToolChoice = {
    type?: 'string';
    [k: string]: unknown;
} | {
    type?: 'function';
    function: {
        type: 'function';
        name: string;
    };
};
/**
 * Builder class for creating subgraphs with a fluent API.
 * Subgraphs are reusable graph components that can be referenced by other graphs.
 *
 * @example
 * ```typescript
 * const subgraph = new SubgraphBuilder('my_subgraph')
 *   .addParameter({ name: 'user_input', type: 'string' })
 *   .addNode(intentNode)
 *   .addNode(llmNode)
 *   .addEdge(intentNode, llmNode)
 *   .setStartNode(intentNode)
 *   .setEndNode(llmNode)
 *   .build();
 * ```
 */
export declare class SubgraphBuilder {
    private subgraph;
    [INTERNAL_COMPONENTS]: Component[];
    private nodes;
    private edges;
    private startNode;
    private endNode;
    /**
     * Creates a new subgraph builder with the specified ID.
     *
     * @constructor
     * @param {string} id - Unique identifier for the subgraph
     */
    constructor(id: string);
    /**
     * Adds a parameter to the subgraph that can be passed from the parent graph.
     *
     * @param {Object} config - Parameter configuration
     * @param {string} config.name - Parameter name
     * @param {string} config.type - Parameter type ('string', 'number', 'integer', 'boolean')
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addParameter(config: {
        name: string;
        type: 'string' | 'number' | 'integer' | 'boolean';
    }): this;
    private addComponent;
    /**
     * Adds multiple parameters to the subgraph at once.
     *
     * @param {Array<Object>} parameters - Array of parameter configurations
     * @param {string} parameters[].name - Parameter name
     * @param {string} parameters[].type - Parameter type ('string', 'number', 'integer', 'boolean')
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addParameters(parameters: {
        name: string;
        type: 'string' | 'number' | 'integer' | 'boolean';
    }[]): this;
    /**
     * Adds a node to the subgraph.
     *
     * @param {AbstractNode} node - Node to add to the subgraph
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addNode(node: Node | AbstractNode): this;
    private addClassNode;
    /**
     * Adds an edge connecting two nodes in the subgraph.
     *
     * @param {AbstractNode} fromNode - Source node or node ID
     * @param {AbstractNode} toNode - Destination node or node ID
     * @param {Object} [options] - Optional edge configuration
     * @param {string} [options.conditionExpression] - CEL expression for conditional execution
     * @param {CustomEdgeConditionReference} [options.conditionRef] - Reference to a custom edge condition
     * @param {boolean} [options.optional] - Whether the edge is optional
     * @param {boolean} [options.loop] - Whether the edge creates a loop
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addEdge(fromNode: AbstractNode | Node | string, toNode: AbstractNode | Node | string, options?: {
        conditionExpression?: string;
        conditionRef?: CustomEdgeConditionReference;
        optional?: boolean;
        loop?: boolean;
    }): this;
    /**
     * Sets the start node of the subgraph (subgraphs can only have one start node).
     *
     * @param {AbstractNode} node - Start node or node ID
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    setStartNode(node: Node | string | AbstractNode): this;
    /**
     * Sets the end node of the subgraph (subgraphs can only have one end node).
     *
     * @param {AbstractNode} node - End node or node ID
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    setEndNode(node: Node | string | AbstractNode): this;
    /**
     * Builds and returns the final subgraph configuration.
     *
     * @returns {Subgraph} The completed subgraph configuration
     * @throws {Error} If the subgraph has no nodes
     */
    build(): Subgraph;
}
/**
 * Represents the properties required to initialize and configure a graph builder.
 *
 * @typedef {Object} GraphBuilderProps
 * @property {string} id - A unique identifier for the graph instance. This field is required.
 * @property {string} [apiKey] - An optional Inworld API key. In order to Remote nodes to work, you need to pass it here or via environment variable INWORLD_API_KEY.
 * @property {string} [appName] - An optional name of the application utilizing the graph builder. Used in observability reporting.
 * @property {string} [appVersion] - An optional version of the application utilizing the graph builder. Used in observability reporting.
 * @property {boolean} [enableRemoteConfig] - An optional flag to enable remote config, which allows one-click experiment deployment from Inworld portal.
 */
export type GraphBuilderProps = {
    id: string;
    apiKey?: string;
    appName?: string;
    appVersion?: string;
    enableRemoteConfig?: boolean;
};
/**
 * Main graph builder class for creating complete graph configurations.
 * Provides a fluent API for building graphs with nodes, edges, components, and subgraphs.
 *
 * @example
 * ```typescript
 * const graph = new Graph('my_graph')
 *   .addComponent(llmComponent)
 *   .addComponent(embedderComponent)
 *   .addNode(intentNode)
 *   .addNode(llmNode)
 *   .addEdge(intentNode, llmNode)
 *   .setStartNode(intentNode)
 *   .setEndNode(llmNode)
 *   .build();
 * ```
 */
export declare class GraphBuilder {
    protected nodes: Node[];
    protected startNodes: string[];
    protected endNodes: string[];
    private enableRemoteConfig;
    private config;
    private edges;
    private components;
    private subgraphs;
    private apiKey;
    /**
     * Creates a new graph builder.
     * Accepts either an options object or a graph ID string.
     *
     * @constructor
     * @param {GraphBuilderProps | string} opts - Graph builder options or graph ID string
     */
    constructor(opts: GraphBuilderProps | string);
    /**
     * Adds a subgraph to the graph configuration.
     *
     * @param {SubgraphBuilder} subgraph - Subgraph builder instance to be added
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addSubgraph(subgraph: SubgraphBuilder): this;
    /**
     * Adds an intent subgraph to the graph.
     * @param {string} id - Unique identifier for the subgraph
     * @param {Object} parameters - Intent subgraph parameters
     * @param {Array} parameters.intents - Array of intent configurations
     * @param {string} parameters.promptTemplate - Template for LLM prompting
     * @param {RemoteLLMComponent|Object} [parameters.llmComponent] - LLM component instance or configuration
     * @param {RemoteEmbedderComponent|Object} [parameters.embedderComponent] - Embedder component instance or configuration
     * @param {number} [parameters.similarityThreshold] - Similarity threshold for matching
     * @param {TextGenerationConfig} [parameters.textGenerationConfig] - Text generation configuration
     * @param {number} [parameters.maxIntentsForLLM] - Maximum intents to send to LLM
     * @param {number} [parameters.maxPhrasesPerIntent] - Maximum phrases per intent
     * @param {number} [parameters.embeddingSimilarityThreshold] - Embedding similarity threshold
     * @param {number} [parameters.topNIntents] - Number of top intents to return
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addIntentSubgraph(id: string, parameters: IntentSubgraphProps): this;
    /**
     * Adds a node to the graph.
     * If an {@link AbstractNode} is provided without corresponding component, internal components are automatically added.
     *
     * @param {AbstractNode} node - Node to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addNode(node: Node | AbstractNode): this;
    private addClassNode;
    /**
     * Adds an edge connecting two nodes in the graph.
     *
     * @param {AbstractNode} fromNode - Source node
     * @param {AbstractNodeg} toNode - Destination node
     * @param {Object} [options] - Optional edge configuration
     * @param {string} [options.conditionExpression] - CEL expression for conditional execution
     * @param {CustomEdgeConditionReference|EdgeConditionCallback} [options.condition] - Reference to a registered custom condition or a callback to register one
     * @param {boolean} [options.optional] - Whether the edge is optional
     * @param {boolean} [options.loop] - Whether the edge creates a loop
     *
     * @returns {GraphBuilder} The builder instance for method chaining
     */
    addEdge(fromNode: AbstractNode | Node | string, toNode: AbstractNode | Node | string, options?: {
        conditionExpression?: string;
        condition?: CustomEdgeConditionReference | EdgeConditionCallback;
        optional?: boolean;
        loop?: boolean;
    }): this;
    /**
     * Adds a component to the graph configuration.
     *
     * @param {AbstractComponent} component - Component to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addComponent(component: Component | AbstractComponent): this;
    /**
     * Sets the start node of the graph.
     *
     * @param {AbstractNode} node - Start node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNode(node: Node | string | AbstractNode): this;
    /**
     * Sets the end node of the graph.
     *
     * @param {AbstractNode} node - End node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNode(node: Node | string | AbstractNode): this;
    /**
     * Sets multiple start nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of start nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNodes(nodes: (Node | string | AbstractNode)[]): this;
    /**
     * Sets multiple end nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of end nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNodes(nodes: (Node | string | AbstractNode)[]): this;
    private getSchema;
    /**
     * Converts the graph configuration to a JSON string.
     *
     * @returns {string} JSON string representation of the graph configuration
     */
    private toJSON;
    /**
     * Creates a graph executor instance for running the graph.
     *
     * @returns {Graph} GraphExecutor instance configured with this graph
     */
    build(): Graph;
}
