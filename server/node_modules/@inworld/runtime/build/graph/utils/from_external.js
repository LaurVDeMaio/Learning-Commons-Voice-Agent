"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromExternal = fromExternal;
const data_types_1 = require("../../common/data_types");
const expose_binary_1 = require("../../expose_binary");
/**
 * Converts an external reference to a GraphOutputStreamResponse.
 * @param external - The external reference to convert
 * @returns
 */
function fromExternal(external) {
    // FIXME: Replace by more clear type detection.
    // The corresponding method should be exposed from the C++ side while koffi is used.
    // Node-API is expected to be helpful as well since it provides native types.
    return (toListToolsResponseData(external) ||
        toToolCallsResults(external) ||
        toLLMChatResponse(external) ||
        toLLMCompletionResponse(external) ||
        toTextStream(external) ||
        toTTSStream(external) ||
        toSpeechChunkStream(external) ||
        toKnowledgeRecords(external) ||
        toIntents(external) ||
        toMatchedKeywords(external) ||
        toClassificationResult(external) ||
        toGoalAdvancement(external) ||
        toMemoryState(external) ||
        toText(external) ||
        toLLMChatRequest(external) ||
        toTTSRequest(external) ||
        toCustom(external) ||
        null);
}
function toListToolsResponseData(next) {
    const listToolsResponseData = data_types_1.ListToolsResponseData.fromExternal(next);
    if (listToolsResponseData) {
        return data_types_1.GraphTypes.ListToolsResponse.from(listToolsResponseData);
    }
}
function toToolCallsResults(next) {
    const toolCallsResults = data_types_1.ToolCallResponseData.fromExternal(next);
    if (toolCallsResults) {
        return data_types_1.GraphTypes.ToolCallResponse.from(toolCallsResults);
    }
}
function toLLMChatResponse(next) {
    const llmChatResponseData = data_types_1.LLMChatResponseData.fromExternal(next);
    if (llmChatResponseData) {
        if (llmChatResponseData.isStreaming()) {
            return llmChatResponseData.getContentStream();
        }
        else {
            return data_types_1.GraphTypes.Content.from(llmChatResponseData.getContent());
        }
    }
}
function toLLMCompletionResponse(next) {
    const baseData = expose_binary_1.LLMCompletionResponseFunctions.toBaseData(next);
    const isValid = expose_binary_1.LLMCompletionResponseFunctions.isValid(baseData);
    if (isValid) {
        const isStreaming = expose_binary_1.LLMCompletionResponseFunctions.isStreaming(baseData);
        if (isStreaming) {
            return new data_types_1.GraphTypes.TextStream(expose_binary_1.LLMCompletionResponseFunctions.getStream(baseData));
        }
        else {
            return expose_binary_1.LLMCompletionResponseFunctions.getText(baseData);
        }
    }
}
function toTextStream(next) {
    const stream = expose_binary_1.StreamStringFunctions.toStream(next);
    const isValid = expose_binary_1.StreamStringFunctions.isValid(stream);
    if (isValid) {
        return data_types_1.GraphTypes.TextStream.fromExternal(stream);
    }
}
function toTTSStream(next) {
    const stream = expose_binary_1.TTSOutputFunctions.toStream(next);
    const isValid = expose_binary_1.TTSOutputFunctions.isValid(stream);
    if (isValid) {
        const streamData = stream ? expose_binary_1.TTSOutputFunctions.getStream(stream) : null;
        if (streamData) {
            return data_types_1.GraphTypes.TTSOutputStream.fromExternal(streamData);
        }
    }
}
function toSpeechChunkStream(next) {
    const stream = expose_binary_1.SpeechChunkFunctions.fromBaseData(next);
    const isValid = expose_binary_1.SpeechChunkFunctions.isValid(stream);
    if (isValid) {
        return data_types_1.GraphTypes.SpeechChunkStream.fromExternal(stream);
    }
}
function toKnowledgeRecords(next) {
    const baseData = data_types_1.KnowledgeRecordsData.fromExternal(next);
    const records = baseData.getRecords();
    if (baseData && records) {
        return data_types_1.GraphTypes.KnowledgeRecords.from(baseData);
    }
}
function toIntents(next) {
    const baseData = data_types_1.MatchedIntentsData.fromExternal(next);
    const matchers = baseData.getMatchers();
    if (baseData && matchers) {
        return data_types_1.GraphTypes.MatchedIntents.from(baseData);
    }
}
function toMatchedKeywords(next) {
    const baseData = data_types_1.MatchedKeywordsData.fromExternal(next);
    const matchers = baseData.getMatchers();
    if (baseData && matchers) {
        return data_types_1.GraphTypes.MatchedKeywords.from(baseData);
    }
}
function toClassificationResult(next) {
    const baseData = data_types_1.ClassificationResultData.fromExternal(next);
    const classes = baseData.getClasses();
    if (baseData && classes) {
        return data_types_1.GraphTypes.ClassificationResult.from(baseData);
    }
}
function toGoalAdvancement(next) {
    const baseData = data_types_1.GoalAdvancementData.fromExternal(next);
    const goals = baseData.getGoals();
    if (baseData && goals) {
        return data_types_1.GraphTypes.GoalAdvancement.from(baseData);
    }
}
function toMemoryState(next) {
    const baseData = data_types_1.MemoryStateData.fromExternal(next);
    const state = baseData.getState();
    if (baseData && state) {
        return data_types_1.GraphTypes.MemoryState.from(baseData);
    }
}
function toText(next) {
    const text = expose_binary_1.TextFunctions.asText(next);
    const isValid = expose_binary_1.TextFunctions.isValid(text);
    if (isValid) {
        // FIXME: This is a hack to get the text from the JSON string
        return JSON.parse(data_types_1.TextData.fromExternal(next).getText()).text;
    }
}
function toLLMChatRequest(next) {
    const baseData = expose_binary_1.LLMChatRequestFunctions.toBaseData(next);
    if (baseData && expose_binary_1.LLMChatRequestFunctions.isValid(baseData)) {
        const llmChatRequest = data_types_1.LLMChatRequestData.fromExternal(next);
        if (llmChatRequest) {
            return data_types_1.GraphTypes.LLMChatRequest.from(llmChatRequest);
        }
    }
}
function toTTSRequest(next) {
    const baseData = expose_binary_1.TTSRequestFunctions.toBaseData(next);
    if (baseData && expose_binary_1.TTSRequestFunctions.isValid(baseData)) {
        const ttsRequest = data_types_1.TTSRequestData.fromExternal(next);
        if (ttsRequest) {
            return data_types_1.GraphTypes.TTSRequest.from(ttsRequest);
        }
    }
}
function toCustom(next) {
    const jsonData = data_types_1.JsonData.fromExternal(next);
    if (jsonData && jsonData.isValid()) {
        const jsonString = jsonData.getJsonString();
        return JSON.parse(jsonString);
    }
}
