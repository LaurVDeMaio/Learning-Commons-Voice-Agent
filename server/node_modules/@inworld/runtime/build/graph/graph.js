"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graph = void 0;
const node_console_1 = require("node:console");
const uuid_1 = require("uuid");
const common_1 = require("../common");
const auth_1 = require("../common/auth");
const helpers_1 = require("../common/helpers");
const expose_binary_1 = require("../expose_binary");
const GraphExecutor_1 = require("./GraphExecutor");
const GraphManagerConfig_1 = require("./GraphManagerConfig");
const GraphOutputStream_1 = require("./GraphOutputStream");
const GraphSchemaValidator_1 = __importDefault(require("./GraphSchemaValidator"));
const to_external_1 = require("./utils/to_external");
const isDeclarativeGraphOptions = (options) => {
    return (typeof options === 'object' && options !== null && 'jsonConfig' in options);
};
function toNativeMap(tags) {
    if (!tags)
        return undefined;
    const map = expose_binary_1.HashMapStringToStringFunctions.new();
    for (const [k, v] of Object.entries(tags)) {
        expose_binary_1.HashMapStringToStringFunctions.set(map, k, v);
    }
    return map;
}
/**
 * Represents a graph that can be executed.
 */
class Graph {
    getGraphExecutionManager() {
        // Dynamic import to avoid circular dependency
        const { GraphExecutionManager } = require('./GraphExecutionManager');
        return GraphExecutionManager.getInstance();
    }
    /**
     * Creates a new Graph instance.
     *
     * @param options
     */
    constructor(options) {
        this.options = options;
        this.jsonConfig = '';
        this.compiled = null;
        this.external = null;
        this.executor = null;
        this.parser = null;
        this.graphManagerConfig = null;
        if (isDeclarativeGraphOptions(this.options)) {
            GraphSchemaValidator_1.default.validate(options === null || options === void 0 ? void 0 : options.jsonConfig);
            this.jsonConfig = this.options.jsonConfig;
            this.graphId = JSON.parse(this.jsonConfig).main.id;
            this.graphManagerConfig = new GraphManagerConfig_1.GraphManagerConfig();
            const authEndpoint = (0, auth_1.getAuthEndpointFromEnv)();
            (0, node_console_1.assert)(authEndpoint, 'INWORLD_ENDPOINT is not set');
            this.graphManagerConfig.configEnvironmentVariables = toNativeMap({
                INWORLD_API_KEY: this.options.apiKey,
            });
            this.graphManagerConfig.address = authEndpoint;
            this.graphManagerConfig.inworldApiKey = this.options.apiKey;
            this.graphManagerConfig.enableRemoteConfig =
                !!this.options.enableRemoteConfig;
            this.getGraphExecutionManager().registerGraph(this.graphId, this);
            this.initializeExecutor();
        }
    }
    /**
     * Validates that the compiled graph is ready for execution.
     *
     * @private
     */
    validateCompiledGraph() {
        if (!this.compiled) {
            throw new Error('Graph is not compiled');
        }
    }
    start(input, executionIdOrUserContext, userContext) {
        let executionId;
        if (executionIdOrUserContext &&
            typeof executionIdOrUserContext === 'string') {
            executionId = executionIdOrUserContext;
        }
        else {
            executionId = (0, uuid_1.v4)();
        }
        if (executionId.trim() === '') {
            throw new common_1.InworldError('Execution ID cannot be empty');
        }
        if (!userContext && typeof executionIdOrUserContext === 'object') {
            userContext = executionIdOrUserContext;
        }
        const data = (0, to_external_1.toExternal)(input);
        let index;
        if (userContext) {
            index = this.executor.execute(data, executionId, userContext);
        }
        else {
            index = this.executor.execute(data, executionId);
        }
        const outputStream = new GraphOutputStream_1.GraphOutputStream(this.executor, index, executionId, data);
        outputStream.setOnFinished(() => {
            this.closeExecution(index);
        });
        return outputStream;
    }
    /**
     * Visualizes the compiled graph and saves the visualization to a file.
     *
     * @param path - File path where the visualization will be saved
     */
    async visualize(path) {
        const status = await expose_binary_1.GraphFunctions.visualize(this.compiled, path);
        if (!expose_binary_1.StatusFunctions.isOK(status)) {
            throw new common_1.InworldError('Failed to visualize graph', (0, helpers_1.getStatus)(status));
        }
    }
    /**
     * Closes a specific execution.
     *
     * @param outputStream - Output stream of the execution to close
     */
    closeExecution(outputStream) {
        if (this.executor) {
            if (typeof outputStream === 'number') {
                this.executor.closeExecution(outputStream);
            }
            else {
                this.executor.closeExecution(outputStream.index);
            }
        }
    }
    /**
     * Returns the JSON configuration of the graph.
     *
     * @returns The JSON configuration of the graph
     */
    toJSON() {
        return this.jsonConfig;
    }
    /**
     * Cleans up all active executions.
     */
    cleanupAllExecutions() {
        if (this.executor) {
            this.executor.cleanupAllExecutions();
        }
    }
    /**
     * Stops the graph executor.
     */
    stopExecutor() {
        if (this.executor) {
            this.executor.stop();
        }
    }
    /**
     * Gets the unique identifier for this graph.
     *
     * @returns The graph's unique ID
     */
    getGraphId() {
        return this.graphId;
    }
    /**
     * Cleans up resources associated with this graph.
     */
    destroy() {
        this.getGraphExecutionManager().unregisterGraph(this.graphId);
        if (this.executor) {
            this.executor.destroy();
            this.executor = null;
        }
        if (this.parser) {
            expose_binary_1.ConfigParserFunctions.delete(this.parser);
            this.parser = null;
        }
        if (this.graphManagerConfig) {
            this.graphManagerConfig.destroy();
            this.graphManagerConfig = null;
        }
    }
    initializeExecutor() {
        if (!this.compiled) {
            this.compile();
        }
        this.validateCompiledGraph();
        if (!this.executor) {
            let executorConfig = undefined;
            if (isDeclarativeGraphOptions(this.options)) {
                const managerConfig = this.graphManagerConfig.getExternal();
                executorConfig = expose_binary_1.GraphExecutorConfigFunctions.new();
                expose_binary_1.GraphExecutorConfigFunctions.setGraphManagerConfig(executorConfig, managerConfig);
            }
            this.executor = new GraphExecutor_1.GraphExecutor(this.compiled, this.graphId, executorConfig);
            this.executor.start();
        }
    }
    compile() {
        if (this.jsonConfig) {
            const statusOrParser = expose_binary_1.ConfigParserFunctions.new();
            if (!expose_binary_1.ConfigParserFunctions.statusOrOk(statusOrParser)) {
                const status = expose_binary_1.ConfigParserFunctions.statusOrStatus(statusOrParser);
                const errorMessage = expose_binary_1.StatusFunctions.toString(status);
                expose_binary_1.ConfigParserFunctions.statusOrDelete(statusOrParser);
                throw new common_1.InworldError(`Failed to create parser: ${errorMessage}`);
            }
            this.parser = expose_binary_1.ConfigParserFunctions.statusOrValue(statusOrParser);
            if ((0, helpers_1.getStatus)(statusOrParser) !== 'OK') {
                throw new common_1.InworldError(`Failed to create parser: ${(0, helpers_1.getStatus)(statusOrParser)}`);
            }
            expose_binary_1.ConfigParserFunctions.statusOrDelete(statusOrParser);
            try {
                const statusOrCompiledGraph = expose_binary_1.ConfigParserFunctions.parseWithSubstitutions(this.parser, this.jsonConfig, toNativeMap(Object.assign(Object.assign({}, this.options.substitutions), { INWORLD_API_KEY: this.options.apiKey })));
                if (!expose_binary_1.ConfigParserFunctions.statusOrCompiledGraphOk(statusOrCompiledGraph)) {
                    const status = expose_binary_1.ConfigParserFunctions.statusOrCompiledGraphStatus(statusOrCompiledGraph);
                    const errorMessage = expose_binary_1.StatusFunctions.toString(status);
                    throw new common_1.InworldError(`Failed to parse graph: ${errorMessage}`);
                }
                this.compiled = expose_binary_1.ConfigParserFunctions.statusOrCompiledGraphValue(statusOrCompiledGraph);
                expose_binary_1.ConfigParserFunctions.statusOrCompiledGraphDelete(statusOrCompiledGraph);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error('Failed to parse graph config: ');
                throw error;
            }
        }
    }
}
exports.Graph = Graph;
