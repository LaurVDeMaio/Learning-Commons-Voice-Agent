"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphOutputStreamResponse = void 0;
const type_mapping_1 = require("../common/data_types/type_mapping");
/**
 * Represents a response from a graph output stream.
 * This class contains all possible data types that can be returned
 * from graph nodes during execution. Each type serves a specific purpose
 * in the graph processing pipeline.
 */
class GraphOutputStreamResponse {
    /**
     * Creates a new GraphOutputStreamResponse instance.
     *
     * @param data - The graph output stream data, if available
     * @param done - Whether the graph has finished executing. When true, indicates that
     *               the graph execution has completed and no more data will be streamed.
     */
    constructor(data, done = false) {
        this.data = data;
        this.done = done;
    }
    get typeName() {
        return (0, type_mapping_1.getTypeName)(this.data);
    }
    /**
     * Sets a callback to be called when response processing is complete.
     * This is called after all handlers in processResponse have finished executing.
     *
     * @param callback - Function to call when processing is complete
     * @internal
     */
    setOnProcessingComplete(callback) {
        this.onProcessingComplete = callback;
    }
    isString() {
        return type_mapping_1.GraphTypesTypeGuards.isString(this.data);
    }
    isCustom() {
        return type_mapping_1.GraphTypesTypeGuards.isCustom(this.data);
    }
    isClassificationResult() {
        return type_mapping_1.GraphTypesTypeGuards.isClassificationResult(this.data);
    }
    isContent() {
        return type_mapping_1.GraphTypesTypeGuards.isContent(this.data);
    }
    isGoalAdvancement() {
        return type_mapping_1.GraphTypesTypeGuards.isGoalAdvancement(this.data);
    }
    isKnowledgeRecords() {
        return type_mapping_1.GraphTypesTypeGuards.isKnowledgeRecords(this.data);
    }
    isListToolsResponse() {
        return type_mapping_1.GraphTypesTypeGuards.isListToolsResponse(this.data);
    }
    isLLMChatRequest() {
        return type_mapping_1.GraphTypesTypeGuards.isLLMChatRequest(this.data);
    }
    isMatchedIntents() {
        return type_mapping_1.GraphTypesTypeGuards.isMatchedIntents(this.data);
    }
    isMatchedKeywords() {
        return type_mapping_1.GraphTypesTypeGuards.isMatchedKeywords(this.data);
    }
    isMemoryState() {
        return type_mapping_1.GraphTypesTypeGuards.isMemoryState(this.data);
    }
    isToolCallResponse() {
        return type_mapping_1.GraphTypesTypeGuards.isToolCallResponse(this.data);
    }
    isTextStream() {
        return type_mapping_1.GraphTypesTypeGuards.isTextStream(this.data);
    }
    isContentStream() {
        return type_mapping_1.GraphTypesTypeGuards.isContentStream(this.data);
    }
    isTTSOutputStream() {
        return type_mapping_1.GraphTypesTypeGuards.isTTSOutputStream(this.data);
    }
    isSpeechChunkStream() {
        return type_mapping_1.GraphTypesTypeGuards.isSpeechChunkStream(this.data);
    }
    /**
     * Processes the graph output stream response with type safety using a visitor pattern.
     * This function makes it easy to handle different response types in a switch-like pattern.
     *
     * @param handlers - Object containing handler functions for each type
     * @returns The result from the appropriate handler
     *
     * @example
     * ```typescript
     * const result = response.visit({
     *   string: (text) => `Got text: ${text}`,
     *   Custom: (custom) => `Got custom data: ${JSON.stringify(custom)}`,
     *   TextStream: async (stream) => {
     *     // Handle stream...
     *     return "Processed stream";
     *   },
     *   // Add other handlers as needed
     *   default: (value) => {
     *     console.log(`Unknown type received from stream.`);
     *   },
     * });
     * ```
     */
    async processResponse(handlers) {
        let result;
        if (this.done && handlers.done) {
            // do not break on done, there might be data present;
            result = handlers.done();
            if (this.onProcessingComplete) {
                this.onProcessingComplete();
            }
        }
        if (this.done && !this.data) {
            if (this.onProcessingComplete) {
                this.onProcessingComplete();
            }
            return Promise.resolve();
        }
        if (this.isString() && handlers.string) {
            result = handlers.string(this.data);
        }
        else if (this.isCustom() && handlers.Custom) {
            result = handlers.Custom(this.data);
        }
        else if (this.isClassificationResult() && handlers.ClassificationResult) {
            result = handlers.ClassificationResult(this.data);
        }
        else if (this.isContent() && handlers.Content) {
            result = handlers.Content(this.data);
        }
        else if (this.isGoalAdvancement() && handlers.GoalAdvancement) {
            result = handlers.GoalAdvancement(this.data);
        }
        else if (this.isKnowledgeRecords() && handlers.KnowledgeRecords) {
            result = handlers.KnowledgeRecords(this.data);
        }
        else if (this.isListToolsResponse() && handlers.ListToolsResponse) {
            result = handlers.ListToolsResponse(this.data);
        }
        else if (this.isLLMChatRequest() && handlers.LLMChatRequest) {
            result = handlers.LLMChatRequest(this.data);
        }
        else if (this.isMatchedIntents() && handlers.MatchedIntents) {
            result = handlers.MatchedIntents(this.data);
        }
        else if (this.isMatchedKeywords() && handlers.MatchedKeywords) {
            result = handlers.MatchedKeywords(this.data);
        }
        else if (this.isMemoryState() && handlers.MemoryState) {
            result = handlers.MemoryState(this.data);
        }
        else if (this.isToolCallResponse() && handlers.ToolCallResponse) {
            result = handlers.ToolCallResponse(this.data);
        }
        else if (this.isTextStream() && handlers.TextStream) {
            result = handlers.TextStream(this.data);
        }
        else if (this.isContentStream() && handlers.ContentStream) {
            result = handlers.ContentStream(this.data);
        }
        else if (this.isTTSOutputStream() && handlers.TTSOutputStream) {
            result = handlers.TTSOutputStream(this.data);
        }
        else if (this.isSpeechChunkStream() && handlers.SpeechChunkStream) {
            result = handlers.SpeechChunkStream(this.data);
        }
        else if (handlers.default) {
            result = handlers.default(this.data);
        }
        if (this.onProcessingComplete) {
            this.onProcessingComplete();
        }
        if (result) {
            return Promise.resolve(result);
        }
    }
}
exports.GraphOutputStreamResponse = GraphOutputStreamResponse;
