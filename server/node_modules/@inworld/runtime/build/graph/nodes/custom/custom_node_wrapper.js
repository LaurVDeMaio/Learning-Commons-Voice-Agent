"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomNodeWrapper = void 0;
/**
 * Currently, async functions cannot be executed directly in graph nodes.
 * We need to migrate to Node-API to handle async functions natively without deasync.
 *
 * Using deasync@1.0.4 specifically because newer versions have type definition issues
 * in index.d.ts that break yarn build, though ts-node still works.
 * TODO: Update once Node-API migration is complete.
 */
const deasync = __importStar(require("@kaciras/deasync"));
const koffi = __importStar(require("koffi"));
const uuid_1 = require("uuid");
const common_1 = require("../../../common");
const data_types_1 = require("../../../common/data_types");
const external_1 = require("../../../common/error/external");
const expose_binary_1 = require("../../../expose_binary");
const fromExternal_1 = require("../../utils/fromExternal");
const toExternal_1 = require("../../utils/toExternal");
const node_1 = require("../node");
/**
 * Wrapper class that integrates custom node logic with the graph runtime.
 * Bridges between JavaScript code and the native graph implementation.
 *
 * @template I - Input type. Can be CustomInputDataType, CustomInputDataType[], or any custom type
 * @template O - Output type. Can be CustomOutputDataType or any custom type
 */
class CustomNodeWrapper extends node_1.Node {
    /**
     * Creates a new CustomNodeWrapper instance.
     *
     * @param props - Custom node wrapper creation properties
     * @throws InworldError if result type is not supported
     * @internal
     */
    constructor({ id, process, executionConfigPtr, }) {
        const ExternalProcessCallback = koffi.proto(`ExternalProcessCallback-${id}-${(0, uuid_1.v4)()}`, 'void', ['void *', 'int']);
        const callback = (executionId) => {
            const externalInputs = expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.getInputs(executionId);
            const inputs = data_types_1.VectorBaseData.toArray(externalInputs);
            if (!(inputs === null || inputs === void 0 ? void 0 : inputs.length)) {
                throw new external_1.ExternalProcessError(`No inputs provided for custom node ${id}`, external_1.ExternalProcessStatusCode.InvalidArgument);
            }
            // if (inputs.length !== this.inputTypes.length) {
            //   throw new ExternalProcessError(
            //     `Invalid number of inputs for custom node ${id}, expected ${this.inputTypes}, got ${inputs}`,
            //     ExternalProcessStatusCode.InvalidArgument,
            //   );
            // }
            for (let i = 0; i < inputs.length; i++) {
                inputs[i] = (0, fromExternal_1.fromExternal)(inputs[i]);
            }
            // TODO: remove this once we have a proper context.
            // TODO: move this to separate file during the cleanup.
            let fakeContext = {
                executionConfig: {},
            };
            if (this.executionConfigPtr) {
                const isExecutionConfigValid = expose_binary_1.ExecutionConfigFunctions.nodeExecutionConfigIsValid(this.executionConfigPtr);
                if (isExecutionConfigValid) {
                    const serializedExecutionConfig = expose_binary_1.ExecutionConfigFunctions.toJsonString(this.executionConfigPtr);
                    if (expose_binary_1.InworldStringFunctions.isOK(serializedExecutionConfig)) {
                        fakeContext.executionConfig.properties = JSON.parse(expose_binary_1.InworldStringFunctions.get(serializedExecutionConfig));
                    }
                    else {
                        throw new common_1.InworldError('NodeExecutionConfig: Invalid input');
                    }
                }
            }
            const result = deasync.awaitSync(process(fakeContext, inputs));
            const output = (0, toExternal_1.toExternal)(result);
            const outputPtr = expose_binary_1.StatusOrBaseDataFunctions.newFromBaseData(output.getExternal());
            this.setResult(executionId, outputPtr);
            expose_binary_1.StatusOrBaseDataFunctions.delete(outputPtr);
        };
        const externalProcess = koffi.register((_, executionId) => {
            try {
                callback(executionId);
            }
            catch (e) {
                let error = e;
                if (!(error instanceof external_1.ExternalProcessError)) {
                    error = new external_1.ExternalProcessError(error.message, external_1.ExternalProcessStatusCode.Unknown);
                }
                this.setResult(executionId, expose_binary_1.StatusOrBaseDataFunctions.newFromStatus(error.getExternal()));
            }
        }, koffi.pointer(ExternalProcessCallback));
        const processExecutor = expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.new(id, externalProcess);
        super(id, expose_binary_1.CustomNodeWrapperFunctions.new(id, executionConfigPtr, processExecutor));
        expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.delete(processExecutor);
        this.externalProcess = externalProcess;
        this.executionConfigPtr = executionConfigPtr;
    }
    /**
     * Cleans up resources associated with this custom node wrapper.
     */
    destroy() {
        if (this.getExternal()) {
            expose_binary_1.CustomNodeWrapperFunctions.delete(this.getExternal());
            this.external = null;
        }
        if (this.externalProcess) {
            koffi.unregister(this.externalProcess);
            this.externalProcess = null;
        }
    }
    setResult(executionId, output) {
        expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.setOutput(executionId, output);
    }
}
exports.CustomNodeWrapper = CustomNodeWrapper;
