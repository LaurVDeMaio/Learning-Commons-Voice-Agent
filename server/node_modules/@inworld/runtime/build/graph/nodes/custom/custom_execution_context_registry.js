"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomExecutionContextRegistry = void 0;
const custom_context_datastore_1 = require("./custom_context_datastore");
/**
 * That entire thing would be replaced with a native implementation as soon as we
 * move code to 0.8.
 */
const CONTEXT_STORE_TTL_MS = 5 * 60 * 1000; // default 5 minutes
const SWEEP_INTERVAL_MS = 30 * 1000; // default 30 seconds
/**
 * Registry for per-execution `DataStore` instances.
 *
 * - Each execution ID maps to a `DataStore`.
 * - Entries have a TTL and are prolonged on access.
 * - A background sweeper removes expired entries to prevent leaks.
 *
 * Usage:
 * - Call `CustomExecutionContextRegistry.getInstance().get(id)` to obtain a
 *   `DataStore` for the given execution ID. This will create it if missing and
 *   prolong its TTL on each call.
 * - Call `dispose(id)` to remove a specific store, or `clearAll()` to remove all.
 */
class CustomExecutionContextRegistry {
    constructor() {
        this.contextStores = new Map();
        this.contextStoreTtlMs = CONTEXT_STORE_TTL_MS;
        this.sweepHandle = null;
    }
    /**
     * Returns the singleton instance of the registry.
     */
    static getInstance() {
        if (!CustomExecutionContextRegistry.instance) {
            CustomExecutionContextRegistry.instance =
                new CustomExecutionContextRegistry();
        }
        return CustomExecutionContextRegistry.instance;
    }
    /**
     * Returns the `DataStore` for the given execution ID.
     * Creates a new store if it doesn't exist yet, and prolongs its TTL.
     */
    get(executionId) {
        let entry = this.contextStores.get(executionId);
        if (!entry) {
            entry = { store: new custom_context_datastore_1.DataStore(), expiresAt: 0 };
            this.contextStores.set(executionId, entry);
        }
        this.bump(executionId);
        this.ensureSweeper();
        return entry.store;
    }
    /**
     * Disposes and removes the `DataStore` for the given execution ID.
     * Returns true when a store existed and was removed.
     */
    dispose(executionId) {
        const entry = this.contextStores.get(executionId);
        if (!entry)
            return false;
        try {
            entry.store.clear();
        }
        finally {
            this.contextStores.delete(executionId);
        }
        this.maybeStopSweeper();
        return true;
    }
    /**
     * Clears and disposes all `DataStore` entries.
     * Stops the background sweeper if running.
     */
    clearAll() {
        for (const entry of this.contextStores.values()) {
            entry.store.clear();
        }
        this.contextStores.clear();
        this.stopSweeper();
    }
    bump(executionId) {
        const entry = this.contextStores.get(executionId);
        if (entry)
            entry.expiresAt = Date.now() + this.contextStoreTtlMs;
    }
    ensureSweeper() {
        if (this.sweepHandle)
            return;
        const sweepEvery = Math.min(this.contextStoreTtlMs, SWEEP_INTERVAL_MS);
        this.sweepHandle = setInterval(() => this.sweep(), sweepEvery);
    }
    stopSweeper() {
        if (this.sweepHandle) {
            clearInterval(this.sweepHandle);
            this.sweepHandle = null;
        }
    }
    maybeStopSweeper() {
        if (this.contextStores.size === 0)
            this.stopSweeper();
    }
    sweep() {
        const now = Date.now();
        for (const [id, entry] of this.contextStores) {
            if (entry.expiresAt <= now) {
                try {
                    entry.store.clear();
                }
                finally {
                    this.contextStores.delete(id);
                }
            }
        }
        this.maybeStopSweeper();
    }
}
exports.CustomExecutionContextRegistry = CustomExecutionContextRegistry;
