"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomExecutionContextRegistry = exports.DataStore = void 0;
const inworld_1 = require("../../../common/error/inworld");
/**
 * Stores data shared between nodes during an execution.
 * Provides typed accessors and resource-safe deletion.
 */
class DataStore {
    constructor() {
        this.store = new Map();
    }
    /**
     * Adds data only if the key does not already exist.
     * Returns true if added, false if the key was already present.
     */
    add(key, data) {
        if (this.store.has(key))
            return false;
        this.store.set(key, data);
        return true;
    }
    /** Gets data for a key or undefined if not present. */
    get(key) {
        return this.store.get(key);
    }
    /** Gets data or throws if it does not exist. */
    require(key) {
        const value = this.store.get(key);
        if (!value) {
            throw new inworld_1.InworldError(`Data not found for key: ${key}`);
        }
        return value;
    }
    /**
     * Gets data and asserts it matches the requested constructor. Throws if the
     * key is missing or the stored value does not match the requested type.
     */
    getAs(key, ctor) {
        const value = this.get(key);
        if (value === undefined)
            return undefined;
        if (value instanceof ctor)
            return value;
        throw new inworld_1.InworldError(`Data for key '${key}' is not of type ${ctor.name}`);
    }
    /**
     * Gets data and asserts it matches the requested constructor. Throws if
     * missing or of different type.
     */
    requireAs(key, ctor) {
        const value = this.require(key);
        if (value instanceof ctor)
            return value;
        throw new inworld_1.InworldError(`Data for key '${key}' is not of type ${ctor.name}`);
    }
    /** Returns the value or the provided default when absent. */
    getOrDefault(key, defaultValue) {
        var _a;
        return (_a = this.store.get(key)) !== null && _a !== void 0 ? _a : defaultValue;
    }
    /**
     * Returns the typed value when present and of the expected type; otherwise the default.
     */
    getAsOrDefault(key, defaultValue, ctor) {
        const value = this.store.get(key);
        if (value && value instanceof ctor)
            return value;
        return defaultValue;
    }
    /** True if the store contains the key. */
    has(key) {
        return this.store.has(key);
    }
    /** Returns all keys in insertion order. */
    keys() {
        return [...this.store.keys()];
    }
    /** Number of entries. */
    size() {
        return this.store.size;
    }
    /** True if no entries are present. */
    isEmpty() {
        return this.store.size === 0;
    }
    /**
     * Deletes an entry.
     * Returns true if the key existed.
     */
    delete(key) {
        return this.store.delete(key);
    }
    /**
     * Clears the store. By default destroys all stored values to release native resources.
     */
    clear() {
        this.store.clear();
    }
}
exports.DataStore = DataStore;
/**
 * Registry mapping execution IDs to their associated DataStore.
 */
class CustomExecutionContextRegistry {
    constructor() {
        this.executionContextRegistry = new Map();
    }
    static getInstance() {
        if (!CustomExecutionContextRegistry.instance) {
            CustomExecutionContextRegistry.instance =
                new CustomExecutionContextRegistry();
        }
        return CustomExecutionContextRegistry.instance;
    }
    /** Returns an existing store for the execution ID, or undefined. */
    get(executionId) {
        return this.executionContextRegistry.get(executionId);
    }
    /** Returns the store for the execution ID, creating it if missing. */
    getOrCreate(executionId) {
        let store = this.executionContextRegistry.get(executionId);
        if (!store) {
            store = new DataStore();
            this.executionContextRegistry.set(executionId, store);
        }
        return store;
    }
    /** Initializes a fresh store for the execution ID, replacing any existing one. */
    init(executionId) {
        const store = new DataStore();
        const existing = this.executionContextRegistry.get(executionId);
        if (existing)
            existing.clear();
        this.executionContextRegistry.set(executionId, store);
        return store;
    }
    /**
     * Disposes and removes the store for an execution ID.
     * Returns true if a store existed.
     */
    dispose(executionId) {
        const store = this.executionContextRegistry.get(executionId);
        if (!store)
            return false;
        store.clear();
        return this.executionContextRegistry.delete(executionId);
    }
    /** Clears all stores. */
    clearAll() {
        for (const store of this.executionContextRegistry.values()) {
            store.clear();
        }
        this.executionContextRegistry.clear();
    }
}
exports.CustomExecutionContextRegistry = CustomExecutionContextRegistry;
