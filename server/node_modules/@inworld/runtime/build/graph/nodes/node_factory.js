"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeFactory = void 0;
const intent_1 = require("../../primitives/intent");
const ComponentRegistry_1 = __importDefault(require("../ComponentRegistry"));
const builtin_1 = require("./builtin");
const IntentNode_1 = require("./builtin/IntentNode");
const TextAggregatorNode_1 = require("./builtin/TextAggregatorNode");
const NodeExecutionConfig_1 = require("./NodeExecutionConfig");
/**
 * Factory class for creating various types of graph nodes.
 * Provides methods to easily create and configure common node types.
 */
class NodeFactory {
    /**
     * Creates a remote LLM (Large Language Model) node.
     *
     * @param props - Configuration parameters for the LLM node
     * @returns Promise resolving to a new LLM node
     */
    static async createRemoteLLMNode(props) {
        await ComponentRegistry_1.default.registerRemoteLLMComponent(props.executionConfig.llm_component_id, props.llmConfig);
        return new builtin_1.LLMChatNode({
            id: props.id,
            executionConfig: props.executionConfig,
        });
    }
    /**
     * Creates a local LLM (Large Language Model) node.
     *
     * @param props - Configuration parameters for the LLM node
     * @returns Promise resolving to a new LLM node
     */
    static async createLocalLLMNode(props) {
        await ComponentRegistry_1.default.registerLocalLLMComponent(props.id, props.llmConfig);
        return new builtin_1.LLMChatNode({
            id: props.id,
            executionConfig: props.executionConfig,
        });
    }
    /**
     * Creates a remote LLM Completion node.
     *
     * @param props - Configuration parameters for the LLM completion node
     * @returns Promise resolving to a new LLM completion node
     */
    static async createRemoteLLMCompletionNode(props) {
        await ComponentRegistry_1.default.registerRemoteLLMComponent(props.executionConfig.llm_component_id, props.llmConfig);
        return new builtin_1.LLMCompletionNode({
            id: props.id,
            executionConfig: props.executionConfig,
        });
    }
    /**
     * Creates a remote STT (Speech-to-Text) node.
     *
     * @param props - Configuration parameters for the STT node
     * @returns Promise resolving to a new STT node
     */
    static async createRemoteSTTNode(props) {
        await ComponentRegistry_1.default.registerRemoteSTTComponent(props.executionConfig.stt_component_id, props.sttConfig);
        return new builtin_1.STTNode({
            id: props.id,
            executionConfig: props.executionConfig,
        });
    }
    /**
     * Creates a local STT (Speech-to-Text) node.
     *
     * @param props - Configuration parameters for the STT node
     * @returns Promise resolving to a new STT node
     */
    static async createLocalSTTNode(props) {
        await ComponentRegistry_1.default.registerLocalSTTComponent(props.executionConfig.stt_component_id, props.sttConfig);
        return new builtin_1.STTNode({
            id: props.id,
            executionConfig: props.executionConfig,
        });
    }
    /**
     * Creates a remote TTS (Text-to-Speech) node.
     *
     * @param props - Configuration parameters for the TTS node
     * @returns Promise resolving to a new TTS node
     */
    static async createRemoteTTSNode(props) {
        await ComponentRegistry_1.default.registerRemoteTTSComponent(props.executionConfig.tts_component_id, props.ttsConfig);
        return new builtin_1.TTSNode({
            id: props.id,
            executionConfig: props.executionConfig,
        });
    }
    /**
     * Creates a text chunking node.
     *
     * @param props - Configuration parameters for the text chunking node
     * @returns A new text chunking node
     */
    static createTextChunkingNode(props) {
        const executionConfig = props.executionConfig
            ? new NodeExecutionConfig_1.TextChunkingNodeExecutionConfig(props.executionConfig)
            : undefined;
        return new builtin_1.TextChunkingNode({
            id: props.id,
            executionConfig,
        });
    }
    /**
     * Creates an intent matching node.
     *
     * @param props - Configuration parameters for the intent node
     * @returns Promise resolving to a new intent node
     */
    static async createIntentNode(props) {
        const intentMatcher = await intent_1.IntentMatcherFactory.create({
            config: props.executionConfig.matcherConfig,
            textEmbedder: props.textEmbedder,
            llm: props.llm,
        });
        return new IntentNode_1.IntentNode({
            id: props.id,
            intentMatcher,
            executionConfig: props.executionConfig,
        });
    }
    /**
     * Creates a text aggregator node.
     *
     * @param props - Configuration parameters for the text aggregator node
     * @returns A new text aggregator node
     */
    static createTextAggregatorNode(props) {
        const executionConfig = props.executionConfig
            ? new NodeExecutionConfig_1.TextAggregatorNodeExecutionConfig(props.executionConfig)
            : undefined;
        return new TextAggregatorNode_1.TextAggregatorNode({
            id: props.id,
            executionConfig,
        });
    }
    /**
     * Creates a remote knowledge node.
     *
     * @param props - Configuration parameters for the knowledge node
     * @returns A new knowledge node
     */
    static async createRemoteKnowledgeNode(props) {
        return new builtin_1.KnowledgeNode(props);
    }
}
exports.NodeFactory = NodeFactory;
