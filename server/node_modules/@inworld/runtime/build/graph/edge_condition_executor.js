"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeConditionExecutor = void 0;
/**
 * Currently, async functions cannot be executed directly in graph nodes.
 * We need to migrate to Node-API to handle async functions natively without deasync.
 *
 * Using deasync@1.0.4 specifically because newer versions have type definition issues
 * in index.d.ts that break yarn build, though ts-node still works.
 * TODO: Update once Node-API migration is complete.
 */
const deasync = __importStar(require("@kaciras/deasync"));
const koffi = __importStar(require("koffi"));
const uuid_1 = require("uuid");
const common_1 = require("../common");
const data_types_1 = require("../common/data_types");
const stream_1 = require("../common/stream");
const expose_binary_1 = require("../expose_binary");
/**
 * EdgeConditionExecutor class for implementing conditional edge logic.
 * Allows edges to be traversed only when specific conditions are met.
 * @internal
 */
class EdgeConditionExecutor {
    /**
     * Creates a new EdgeConditionExecutor with a condition callback.
     *
     * @param condition - Function that determines if the edge should be traversed
     */
    constructor(condition) {
        this.external = null;
        this.externalCallback = null;
        const ExternalConditionCallback = koffi.proto(`ExternalConditionCallback-${(0, uuid_1.v4)()}`, 'void', ['int']);
        const callback = (executionId) => {
            let result = false;
            try {
                const input = expose_binary_1.EdgeConditionExecutorFunctions.getInput(executionId);
                const inputData = this.getInputData(input);
                expose_binary_1.EdgeConditionExecutorFunctions.setOutput(executionId, deasync.awaitSync(condition(inputData)));
            }
            catch (_error) {
                // On error, don't traverse the edge
                expose_binary_1.EdgeConditionExecutorFunctions.setOutput(executionId, result);
            }
        };
        const externalCondition = koffi.register((executionId) => {
            callback(executionId);
        }, koffi.pointer(ExternalConditionCallback));
        this.external = expose_binary_1.EdgeConditionExecutorFunctions.new(externalCondition, externalCondition);
        this.externalCallback = externalCondition;
    }
    /**
     * Gets the external reference for use with C++ bindings.
     *
     * @returns External reference pointer
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this executor.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.EdgeConditionExecutorFunctions.delete(this.external);
            this.external = null;
        }
        if (this.externalCallback) {
            koffi.unregister(this.externalCallback);
            this.externalCallback = null;
        }
    }
    getInputData(input) {
        try {
            // Text stream
            const textStream = expose_binary_1.StreamStringFunctions.toStream(input);
            if (textStream) {
                return stream_1.TextStream.fromExternal(textStream);
            }
            // TTS stream
            const ttsStream = expose_binary_1.TTSOutputFunctions.toStream(input);
            if (ttsStream) {
                return stream_1.TTSOutputStream.fromExternal(ttsStream);
            }
            // Knowledge records
            const records = data_types_1.KnowledgeRecords.fromExternal(input).getRecords();
            if (records) {
                return records;
            }
            // Matched intents
            const matchedIntents = data_types_1.MatchedIntents.fromExternal(input).getMatchers();
            if (matchedIntents) {
                return matchedIntents;
            }
            // Plain text
            const text = expose_binary_1.BaseDataFunctions.asText(input) || input;
            if (text) {
                return data_types_1.TextData.fromExternal(text).getText();
            }
        }
        catch (error) {
            throw new common_1.InworldError('Invalid input data for edge condition executor', error);
        }
    }
}
exports.EdgeConditionExecutor = EdgeConditionExecutor;
