"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphOutputStream = void 0;
const data_types_1 = require("../common/data_types");
const inworld_1 = require("../common/error/inworld");
const stream_1 = require("../common/stream");
const expose_binary_1 = require("../expose_binary");
const types_1 = require("./nodes/types");
/**
 * Represents a handler for a graph execution.
 */
class GraphOutputStream {
    /**
     * Creates a new GraphOutputStream instance.
     * @param index - The index of the execution
     * @param graphExecutor - The graph executor associated with the execution
     * @internal
     */
    constructor(graphExecutor, index, data) {
        this.index = index;
        this.graphExecutor = graphExecutor;
        this.data = data;
    }
    /**
     * Handles the response from a node.
     * @returns A promise that resolves to the response from the node
     */
    async next() {
        while (this.index && (await this.graphExecutor.hasNext(this.index))) {
            const next = await this.graphExecutor.next(this.index);
            this.checkStatus(next);
            // FIXME: Replace by more clear type detection.
            // The corresponding method should be exposed from the C++ side while koffi is used.
            // Node-API is expected to be helpful as well since it provides native types.
            // MCP List tools data
            const listToolsData = this.toListToolsData(next);
            if (listToolsData) {
                return listToolsData;
            }
            // MCP tool calls results
            const toolCallsResults = this.toToolCallsResults(next);
            if (toolCallsResults) {
                return toolCallsResults;
            }
            // LLM chat response
            const llmChatResponse = this.toLLMChatResponse(next);
            if (llmChatResponse) {
                return llmChatResponse;
            }
            // LLM completion response
            const llmCompletionResponse = this.toLLMCompletionResponse(next);
            if (llmCompletionResponse) {
                return llmCompletionResponse;
            }
            // String stream
            const textStream = this.toTextStream(next);
            if (textStream) {
                return textStream;
            }
            // TTS stream
            const ttsStream = this.toTTSStream(next);
            if (ttsStream) {
                return ttsStream;
            }
            // Speech chunk stream
            const speechChunkStream = this.toSpeechChunkStream(next);
            if (speechChunkStream) {
                return speechChunkStream;
            }
            // Knowledge records
            const knowledgeRecords = this.toKnowledgeRecords(next);
            if (knowledgeRecords) {
                return knowledgeRecords;
            }
            // Intents
            const intents = this.toIntents(next);
            if (intents) {
                return intents;
            }
            // Keywords
            const keywords = this.toMatchedKeywords(next);
            if (keywords) {
                return keywords;
            }
            // Classification result
            const classes = this.toClassificationResult(next);
            if (classes) {
                return classes;
            }
            // Goal advancement
            const goalAdvancement = this.toGoalAdvancement(next);
            if (goalAdvancement) {
                return goalAdvancement;
            }
            // Memory state
            const memoryState = this.toMemoryState(next);
            if (memoryState) {
                return memoryState;
            }
            // LLM chat request
            const llmChatRequest = this.toLLMChatRequest(next);
            if (llmChatRequest) {
                return llmChatRequest;
            }
            // JSON data
            const json = this.toJson(next);
            if (json) {
                return json;
            }
            // Plain text data
            const text = this.toText(next);
            if (text) {
                return text;
            }
        }
        this.data.destroy();
        return {
            done: true,
        };
    }
    /**
     * Checks the status of data and throws an error if there's a problem.
     *
     * @param data - External reference to the data to check
     * @throws InworldError if the data contains an error status
     */
    checkStatus(data) {
        const status = data_types_1.BaseData.getError(data);
        if (status) {
            throw new inworld_1.InworldError('Graph Output Stream error', status);
        }
    }
    toListToolsData(next) {
        const listToolsData = data_types_1.ListToolsData.fromExternal(next);
        if (listToolsData) {
            return {
                type: types_1.GraphOutputStreamResponseType.LIST_TOOLS_DATA,
                data: listToolsData.getListTools(),
                done: true,
            };
        }
    }
    toToolCallsResults(next) {
        const toolCallsResults = data_types_1.ListToolCallsResults.fromExternal(next);
        if (toolCallsResults) {
            return {
                type: types_1.GraphOutputStreamResponseType.TOOL_CALLS_RESULTS,
                data: toolCallsResults.getToolCallResults(),
                done: true,
            };
        }
    }
    toLLMChatResponse(next) {
        const llmChatResponse = data_types_1.LLMChatResponse.fromExternal(next);
        if (llmChatResponse) {
            if (llmChatResponse.isStreaming()) {
                return {
                    type: types_1.GraphOutputStreamResponseType.CONTENT_STREAM,
                    data: llmChatResponse.getContentStream(),
                    done: false,
                };
            }
            else {
                return {
                    type: types_1.GraphOutputStreamResponseType.CONTENT,
                    data: llmChatResponse.getContent(),
                    done: true,
                };
            }
        }
    }
    toLLMCompletionResponse(next) {
        const baseData = expose_binary_1.LLMCompletionResponseFunctions.toBaseData(next);
        const isValid = expose_binary_1.LLMCompletionResponseFunctions.isValid(baseData);
        if (isValid) {
            const isStreaming = expose_binary_1.LLMCompletionResponseFunctions.isStreaming(baseData);
            if (isStreaming) {
                return {
                    type: types_1.GraphOutputStreamResponseType.TEXT_STREAM,
                    data: new stream_1.TextStream(expose_binary_1.LLMCompletionResponseFunctions.getStream(baseData)),
                    done: false,
                };
            }
            else {
                return {
                    type: types_1.GraphOutputStreamResponseType.TEXT,
                    data: expose_binary_1.LLMCompletionResponseFunctions.getText(baseData),
                    done: true,
                };
            }
        }
    }
    toTextStream(next) {
        const stream = expose_binary_1.StreamStringFunctions.toStream(next);
        const isValid = expose_binary_1.StreamStringFunctions.isValid(stream);
        if (isValid) {
            return {
                type: types_1.GraphOutputStreamResponseType.TEXT_STREAM,
                data: stream_1.TextStream.fromExternal(stream),
                done: false,
            };
        }
    }
    toTTSStream(next) {
        const stream = expose_binary_1.TTSOutputFunctions.toStream(next);
        const isValid = expose_binary_1.TTSOutputFunctions.isValid(stream);
        if (isValid) {
            const streamData = stream ? expose_binary_1.TTSOutputFunctions.getStream(stream) : null;
            if (streamData) {
                return {
                    type: types_1.GraphOutputStreamResponseType.TTS_OUTPUT_STREAM,
                    data: stream_1.TTSOutputStream.fromExternal(streamData),
                    done: false,
                };
            }
        }
    }
    toSpeechChunkStream(next) {
        const stream = expose_binary_1.SpeechChunkFunctions.fromBaseData(next);
        const isValid = expose_binary_1.SpeechChunkFunctions.isValid(stream);
        if (isValid) {
            return {
                type: types_1.GraphOutputStreamResponseType.TTS_OUTPUT_STREAM,
                data: stream_1.SpeechChunkStream.fromExternal(stream),
                done: false,
            };
        }
    }
    toKnowledgeRecords(next) {
        const records = data_types_1.KnowledgeRecords.fromExternal(next).getRecords();
        if (records) {
            return {
                type: types_1.GraphOutputStreamResponseType.KNOWLEDGE,
                data: records,
                done: true,
            };
        }
    }
    toIntents(next) {
        const intents = data_types_1.MatchedIntents.fromExternal(next).getMatchers();
        if (intents) {
            return {
                type: types_1.GraphOutputStreamResponseType.MATCHED_INTENTS,
                data: intents,
                done: true,
            };
        }
    }
    toMatchedKeywords(next) {
        const keywords = data_types_1.MatchedKeywords.fromExternal(next).getMatchers();
        if (keywords) {
            return {
                type: types_1.GraphOutputStreamResponseType.MATCHED_KEYWORDS,
                data: keywords,
                done: true,
            };
        }
    }
    toClassificationResult(next) {
        const classes = data_types_1.ClassificationResult.fromExternal(next).getClasses();
        if (classes) {
            return {
                type: types_1.GraphOutputStreamResponseType.CLASSIFICATION_RESULT,
                data: classes,
                done: true,
            };
        }
    }
    toGoalAdvancement(next) {
        const goalAdvancement = data_types_1.GoalAdvancement.fromExternal(next).getGoals();
        if (goalAdvancement) {
            return {
                type: types_1.GraphOutputStreamResponseType.GOAL_ADVANCEMENT,
                data: goalAdvancement,
                done: true,
            };
        }
    }
    toMemoryState(next) {
        const memoryState = data_types_1.MemoryState.fromExternal(next).getState();
        if (memoryState) {
            return {
                type: types_1.GraphOutputStreamResponseType.MEMORY_STATE,
                data: memoryState,
                done: true,
            };
        }
    }
    toText(next) {
        const text = expose_binary_1.TextFunctions.asText(next);
        const isValid = expose_binary_1.TextFunctions.isValid(text);
        if (isValid) {
            // FIXME: This is a hack to get the text from the JSON string
            return {
                type: types_1.GraphOutputStreamResponseType.TEXT,
                data: JSON.parse(data_types_1.TextData.fromExternal(next).getText()).text,
                done: false,
            };
        }
    }
    toLLMChatRequest(next) {
        const baseData = expose_binary_1.LLMChatRequestFunctions.toBaseData(next);
        if (baseData && expose_binary_1.LLMChatRequestFunctions.isValid(baseData)) {
            const llmChatRequest = data_types_1.LLMChatRequest.fromExternal(next);
            if (llmChatRequest) {
                return {
                    type: types_1.GraphOutputStreamResponseType.LLM_CHAT_REQUEST,
                    data: llmChatRequest.getLLMChatRequest(),
                    done: true,
                };
            }
        }
    }
    toJson(next) {
        const jsonData = data_types_1.JsonData.fromExternal(next);
        if (jsonData && jsonData.isValid()) {
            const jsonString = jsonData.getJsonString();
            // horrible hack to detect if the json is in fact a text;
            const jsonStringParsed = JSON.parse(jsonString);
            let actualJson;
            if (jsonStringParsed.text) {
                try {
                    actualJson = JSON.parse(jsonStringParsed.text);
                }
                catch (_a) {
                    // if the text is not a valid json, return, that should be a regular text then;
                    return;
                }
            }
            else {
                actualJson = jsonStringParsed;
            }
            return {
                type: types_1.GraphOutputStreamResponseType.JSON,
                data: actualJson,
                done: true,
            };
        }
    }
}
exports.GraphOutputStream = GraphOutputStream;
